
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model barang
 * 
 */
export type barang = $Result.DefaultSelection<Prisma.$barangPayload>
/**
 * Model employee
 * 
 */
export type employee = $Result.DefaultSelection<Prisma.$employeePayload>
/**
 * Model inventory
 * 
 */
export type inventory = $Result.DefaultSelection<Prisma.$inventoryPayload>
/**
 * Model level
 * 
 */
export type level = $Result.DefaultSelection<Prisma.$levelPayload>
/**
 * Model mekanik
 * 
 */
export type mekanik = $Result.DefaultSelection<Prisma.$mekanikPayload>
/**
 * Model member
 * 
 */
export type member = $Result.DefaultSelection<Prisma.$memberPayload>
/**
 * Model order_barang
 * 
 */
export type order_barang = $Result.DefaultSelection<Prisma.$order_barangPayload>
/**
 * Model order_barang_detail
 * 
 */
export type order_barang_detail = $Result.DefaultSelection<Prisma.$order_barang_detailPayload>
/**
 * Model status
 * 
 */
export type status = $Result.DefaultSelection<Prisma.$statusPayload>
/**
 * Model transaksi
 * 
 */
export type transaksi = $Result.DefaultSelection<Prisma.$transaksiPayload>
/**
 * Model transaksi_detail
 * 
 */
export type transaksi_detail = $Result.DefaultSelection<Prisma.$transaksi_detailPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model vehicle_category
 * 
 */
export type vehicle_category = $Result.DefaultSelection<Prisma.$vehicle_categoryPayload>
/**
 * Model vehicle_merk
 * 
 */
export type vehicle_merk = $Result.DefaultSelection<Prisma.$vehicle_merkPayload>
/**
 * Model vehicle_type
 * 
 */
export type vehicle_type = $Result.DefaultSelection<Prisma.$vehicle_typePayload>
/**
 * Model vehicle_year
 * 
 */
export type vehicle_year = $Result.DefaultSelection<Prisma.$vehicle_yearPayload>
/**
 * Model warehouse
 * 
 */
export type warehouse = $Result.DefaultSelection<Prisma.$warehousePayload>
/**
 * Model warehouse_inventory
 * 
 */
export type warehouse_inventory = $Result.DefaultSelection<Prisma.$warehouse_inventoryPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Barangs
 * const barangs = await prisma.barang.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Barangs
   * const barangs = await prisma.barang.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.barang`: Exposes CRUD operations for the **barang** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Barangs
    * const barangs = await prisma.barang.findMany()
    * ```
    */
  get barang(): Prisma.barangDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.employeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.inventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.level`: Exposes CRUD operations for the **level** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Levels
    * const levels = await prisma.level.findMany()
    * ```
    */
  get level(): Prisma.levelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mekanik`: Exposes CRUD operations for the **mekanik** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mekaniks
    * const mekaniks = await prisma.mekanik.findMany()
    * ```
    */
  get mekanik(): Prisma.mekanikDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.memberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order_barang`: Exposes CRUD operations for the **order_barang** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Order_barangs
    * const order_barangs = await prisma.order_barang.findMany()
    * ```
    */
  get order_barang(): Prisma.order_barangDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order_barang_detail`: Exposes CRUD operations for the **order_barang_detail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Order_barang_details
    * const order_barang_details = await prisma.order_barang_detail.findMany()
    * ```
    */
  get order_barang_detail(): Prisma.order_barang_detailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.status`: Exposes CRUD operations for the **status** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Statuses
    * const statuses = await prisma.status.findMany()
    * ```
    */
  get status(): Prisma.statusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaksi`: Exposes CRUD operations for the **transaksi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transaksis
    * const transaksis = await prisma.transaksi.findMany()
    * ```
    */
  get transaksi(): Prisma.transaksiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaksi_detail`: Exposes CRUD operations for the **transaksi_detail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transaksi_details
    * const transaksi_details = await prisma.transaksi_detail.findMany()
    * ```
    */
  get transaksi_detail(): Prisma.transaksi_detailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle_category`: Exposes CRUD operations for the **vehicle_category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicle_categories
    * const vehicle_categories = await prisma.vehicle_category.findMany()
    * ```
    */
  get vehicle_category(): Prisma.vehicle_categoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle_merk`: Exposes CRUD operations for the **vehicle_merk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicle_merks
    * const vehicle_merks = await prisma.vehicle_merk.findMany()
    * ```
    */
  get vehicle_merk(): Prisma.vehicle_merkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle_type`: Exposes CRUD operations for the **vehicle_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicle_types
    * const vehicle_types = await prisma.vehicle_type.findMany()
    * ```
    */
  get vehicle_type(): Prisma.vehicle_typeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle_year`: Exposes CRUD operations for the **vehicle_year** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicle_years
    * const vehicle_years = await prisma.vehicle_year.findMany()
    * ```
    */
  get vehicle_year(): Prisma.vehicle_yearDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouse`: Exposes CRUD operations for the **warehouse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Warehouses
    * const warehouses = await prisma.warehouse.findMany()
    * ```
    */
  get warehouse(): Prisma.warehouseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouse_inventory`: Exposes CRUD operations for the **warehouse_inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Warehouse_inventories
    * const warehouse_inventories = await prisma.warehouse_inventory.findMany()
    * ```
    */
  get warehouse_inventory(): Prisma.warehouse_inventoryDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    barang: 'barang',
    employee: 'employee',
    inventory: 'inventory',
    level: 'level',
    mekanik: 'mekanik',
    member: 'member',
    order_barang: 'order_barang',
    order_barang_detail: 'order_barang_detail',
    status: 'status',
    transaksi: 'transaksi',
    transaksi_detail: 'transaksi_detail',
    users: 'users',
    vehicle_category: 'vehicle_category',
    vehicle_merk: 'vehicle_merk',
    vehicle_type: 'vehicle_type',
    vehicle_year: 'vehicle_year',
    warehouse: 'warehouse',
    warehouse_inventory: 'warehouse_inventory'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "barang" | "employee" | "inventory" | "level" | "mekanik" | "member" | "order_barang" | "order_barang_detail" | "status" | "transaksi" | "transaksi_detail" | "users" | "vehicle_category" | "vehicle_merk" | "vehicle_type" | "vehicle_year" | "warehouse" | "warehouse_inventory"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      barang: {
        payload: Prisma.$barangPayload<ExtArgs>
        fields: Prisma.barangFieldRefs
        operations: {
          findUnique: {
            args: Prisma.barangFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barangPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.barangFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barangPayload>
          }
          findFirst: {
            args: Prisma.barangFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barangPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.barangFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barangPayload>
          }
          findMany: {
            args: Prisma.barangFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barangPayload>[]
          }
          create: {
            args: Prisma.barangCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barangPayload>
          }
          createMany: {
            args: Prisma.barangCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.barangCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barangPayload>[]
          }
          delete: {
            args: Prisma.barangDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barangPayload>
          }
          update: {
            args: Prisma.barangUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barangPayload>
          }
          deleteMany: {
            args: Prisma.barangDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.barangUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.barangUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barangPayload>[]
          }
          upsert: {
            args: Prisma.barangUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$barangPayload>
          }
          aggregate: {
            args: Prisma.BarangAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBarang>
          }
          groupBy: {
            args: Prisma.barangGroupByArgs<ExtArgs>
            result: $Utils.Optional<BarangGroupByOutputType>[]
          }
          count: {
            args: Prisma.barangCountArgs<ExtArgs>
            result: $Utils.Optional<BarangCountAggregateOutputType> | number
          }
        }
      }
      employee: {
        payload: Prisma.$employeePayload<ExtArgs>
        fields: Prisma.employeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.employeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.employeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          findFirst: {
            args: Prisma.employeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.employeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          findMany: {
            args: Prisma.employeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>[]
          }
          create: {
            args: Prisma.employeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          createMany: {
            args: Prisma.employeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.employeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>[]
          }
          delete: {
            args: Prisma.employeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          update: {
            args: Prisma.employeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          deleteMany: {
            args: Prisma.employeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.employeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.employeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>[]
          }
          upsert: {
            args: Prisma.employeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.employeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.employeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      inventory: {
        payload: Prisma.$inventoryPayload<ExtArgs>
        fields: Prisma.inventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          findFirst: {
            args: Prisma.inventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          findMany: {
            args: Prisma.inventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>[]
          }
          create: {
            args: Prisma.inventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          createMany: {
            args: Prisma.inventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.inventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>[]
          }
          delete: {
            args: Prisma.inventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          update: {
            args: Prisma.inventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          deleteMany: {
            args: Prisma.inventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.inventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.inventoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>[]
          }
          upsert: {
            args: Prisma.inventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.inventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.inventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      level: {
        payload: Prisma.$levelPayload<ExtArgs>
        fields: Prisma.levelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.levelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.levelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelPayload>
          }
          findFirst: {
            args: Prisma.levelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.levelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelPayload>
          }
          findMany: {
            args: Prisma.levelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelPayload>[]
          }
          create: {
            args: Prisma.levelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelPayload>
          }
          createMany: {
            args: Prisma.levelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.levelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelPayload>[]
          }
          delete: {
            args: Prisma.levelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelPayload>
          }
          update: {
            args: Prisma.levelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelPayload>
          }
          deleteMany: {
            args: Prisma.levelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.levelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.levelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelPayload>[]
          }
          upsert: {
            args: Prisma.levelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelPayload>
          }
          aggregate: {
            args: Prisma.LevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLevel>
          }
          groupBy: {
            args: Prisma.levelGroupByArgs<ExtArgs>
            result: $Utils.Optional<LevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.levelCountArgs<ExtArgs>
            result: $Utils.Optional<LevelCountAggregateOutputType> | number
          }
        }
      }
      mekanik: {
        payload: Prisma.$mekanikPayload<ExtArgs>
        fields: Prisma.mekanikFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mekanikFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mekanikPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mekanikFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mekanikPayload>
          }
          findFirst: {
            args: Prisma.mekanikFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mekanikPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mekanikFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mekanikPayload>
          }
          findMany: {
            args: Prisma.mekanikFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mekanikPayload>[]
          }
          create: {
            args: Prisma.mekanikCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mekanikPayload>
          }
          createMany: {
            args: Prisma.mekanikCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mekanikCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mekanikPayload>[]
          }
          delete: {
            args: Prisma.mekanikDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mekanikPayload>
          }
          update: {
            args: Prisma.mekanikUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mekanikPayload>
          }
          deleteMany: {
            args: Prisma.mekanikDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mekanikUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.mekanikUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mekanikPayload>[]
          }
          upsert: {
            args: Prisma.mekanikUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mekanikPayload>
          }
          aggregate: {
            args: Prisma.MekanikAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMekanik>
          }
          groupBy: {
            args: Prisma.mekanikGroupByArgs<ExtArgs>
            result: $Utils.Optional<MekanikGroupByOutputType>[]
          }
          count: {
            args: Prisma.mekanikCountArgs<ExtArgs>
            result: $Utils.Optional<MekanikCountAggregateOutputType> | number
          }
        }
      }
      member: {
        payload: Prisma.$memberPayload<ExtArgs>
        fields: Prisma.memberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.memberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.memberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>
          }
          findFirst: {
            args: Prisma.memberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.memberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>
          }
          findMany: {
            args: Prisma.memberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>[]
          }
          create: {
            args: Prisma.memberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>
          }
          createMany: {
            args: Prisma.memberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.memberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>[]
          }
          delete: {
            args: Prisma.memberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>
          }
          update: {
            args: Prisma.memberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>
          }
          deleteMany: {
            args: Prisma.memberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.memberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.memberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>[]
          }
          upsert: {
            args: Prisma.memberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.memberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.memberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      order_barang: {
        payload: Prisma.$order_barangPayload<ExtArgs>
        fields: Prisma.order_barangFieldRefs
        operations: {
          findUnique: {
            args: Prisma.order_barangFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barangPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.order_barangFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barangPayload>
          }
          findFirst: {
            args: Prisma.order_barangFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barangPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.order_barangFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barangPayload>
          }
          findMany: {
            args: Prisma.order_barangFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barangPayload>[]
          }
          create: {
            args: Prisma.order_barangCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barangPayload>
          }
          createMany: {
            args: Prisma.order_barangCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.order_barangCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barangPayload>[]
          }
          delete: {
            args: Prisma.order_barangDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barangPayload>
          }
          update: {
            args: Prisma.order_barangUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barangPayload>
          }
          deleteMany: {
            args: Prisma.order_barangDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.order_barangUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.order_barangUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barangPayload>[]
          }
          upsert: {
            args: Prisma.order_barangUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barangPayload>
          }
          aggregate: {
            args: Prisma.Order_barangAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder_barang>
          }
          groupBy: {
            args: Prisma.order_barangGroupByArgs<ExtArgs>
            result: $Utils.Optional<Order_barangGroupByOutputType>[]
          }
          count: {
            args: Prisma.order_barangCountArgs<ExtArgs>
            result: $Utils.Optional<Order_barangCountAggregateOutputType> | number
          }
        }
      }
      order_barang_detail: {
        payload: Prisma.$order_barang_detailPayload<ExtArgs>
        fields: Prisma.order_barang_detailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.order_barang_detailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barang_detailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.order_barang_detailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barang_detailPayload>
          }
          findFirst: {
            args: Prisma.order_barang_detailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barang_detailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.order_barang_detailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barang_detailPayload>
          }
          findMany: {
            args: Prisma.order_barang_detailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barang_detailPayload>[]
          }
          create: {
            args: Prisma.order_barang_detailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barang_detailPayload>
          }
          createMany: {
            args: Prisma.order_barang_detailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.order_barang_detailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barang_detailPayload>[]
          }
          delete: {
            args: Prisma.order_barang_detailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barang_detailPayload>
          }
          update: {
            args: Prisma.order_barang_detailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barang_detailPayload>
          }
          deleteMany: {
            args: Prisma.order_barang_detailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.order_barang_detailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.order_barang_detailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barang_detailPayload>[]
          }
          upsert: {
            args: Prisma.order_barang_detailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_barang_detailPayload>
          }
          aggregate: {
            args: Prisma.Order_barang_detailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder_barang_detail>
          }
          groupBy: {
            args: Prisma.order_barang_detailGroupByArgs<ExtArgs>
            result: $Utils.Optional<Order_barang_detailGroupByOutputType>[]
          }
          count: {
            args: Prisma.order_barang_detailCountArgs<ExtArgs>
            result: $Utils.Optional<Order_barang_detailCountAggregateOutputType> | number
          }
        }
      }
      status: {
        payload: Prisma.$statusPayload<ExtArgs>
        fields: Prisma.statusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.statusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.statusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusPayload>
          }
          findFirst: {
            args: Prisma.statusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.statusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusPayload>
          }
          findMany: {
            args: Prisma.statusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusPayload>[]
          }
          create: {
            args: Prisma.statusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusPayload>
          }
          createMany: {
            args: Prisma.statusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.statusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusPayload>[]
          }
          delete: {
            args: Prisma.statusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusPayload>
          }
          update: {
            args: Prisma.statusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusPayload>
          }
          deleteMany: {
            args: Prisma.statusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.statusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.statusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusPayload>[]
          }
          upsert: {
            args: Prisma.statusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusPayload>
          }
          aggregate: {
            args: Prisma.StatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatus>
          }
          groupBy: {
            args: Prisma.statusGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.statusCountArgs<ExtArgs>
            result: $Utils.Optional<StatusCountAggregateOutputType> | number
          }
        }
      }
      transaksi: {
        payload: Prisma.$transaksiPayload<ExtArgs>
        fields: Prisma.transaksiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transaksiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transaksiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>
          }
          findFirst: {
            args: Prisma.transaksiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transaksiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>
          }
          findMany: {
            args: Prisma.transaksiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>[]
          }
          create: {
            args: Prisma.transaksiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>
          }
          createMany: {
            args: Prisma.transaksiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.transaksiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>[]
          }
          delete: {
            args: Prisma.transaksiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>
          }
          update: {
            args: Prisma.transaksiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>
          }
          deleteMany: {
            args: Prisma.transaksiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transaksiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.transaksiUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>[]
          }
          upsert: {
            args: Prisma.transaksiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>
          }
          aggregate: {
            args: Prisma.TransaksiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaksi>
          }
          groupBy: {
            args: Prisma.transaksiGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransaksiGroupByOutputType>[]
          }
          count: {
            args: Prisma.transaksiCountArgs<ExtArgs>
            result: $Utils.Optional<TransaksiCountAggregateOutputType> | number
          }
        }
      }
      transaksi_detail: {
        payload: Prisma.$transaksi_detailPayload<ExtArgs>
        fields: Prisma.transaksi_detailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transaksi_detailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_detailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transaksi_detailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_detailPayload>
          }
          findFirst: {
            args: Prisma.transaksi_detailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_detailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transaksi_detailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_detailPayload>
          }
          findMany: {
            args: Prisma.transaksi_detailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_detailPayload>[]
          }
          create: {
            args: Prisma.transaksi_detailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_detailPayload>
          }
          createMany: {
            args: Prisma.transaksi_detailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.transaksi_detailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_detailPayload>[]
          }
          delete: {
            args: Prisma.transaksi_detailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_detailPayload>
          }
          update: {
            args: Prisma.transaksi_detailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_detailPayload>
          }
          deleteMany: {
            args: Prisma.transaksi_detailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transaksi_detailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.transaksi_detailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_detailPayload>[]
          }
          upsert: {
            args: Prisma.transaksi_detailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_detailPayload>
          }
          aggregate: {
            args: Prisma.Transaksi_detailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaksi_detail>
          }
          groupBy: {
            args: Prisma.transaksi_detailGroupByArgs<ExtArgs>
            result: $Utils.Optional<Transaksi_detailGroupByOutputType>[]
          }
          count: {
            args: Prisma.transaksi_detailCountArgs<ExtArgs>
            result: $Utils.Optional<Transaksi_detailCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      vehicle_category: {
        payload: Prisma.$vehicle_categoryPayload<ExtArgs>
        fields: Prisma.vehicle_categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehicle_categoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehicle_categoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_categoryPayload>
          }
          findFirst: {
            args: Prisma.vehicle_categoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehicle_categoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_categoryPayload>
          }
          findMany: {
            args: Prisma.vehicle_categoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_categoryPayload>[]
          }
          create: {
            args: Prisma.vehicle_categoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_categoryPayload>
          }
          createMany: {
            args: Prisma.vehicle_categoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.vehicle_categoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_categoryPayload>[]
          }
          delete: {
            args: Prisma.vehicle_categoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_categoryPayload>
          }
          update: {
            args: Prisma.vehicle_categoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_categoryPayload>
          }
          deleteMany: {
            args: Prisma.vehicle_categoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehicle_categoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.vehicle_categoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_categoryPayload>[]
          }
          upsert: {
            args: Prisma.vehicle_categoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_categoryPayload>
          }
          aggregate: {
            args: Prisma.Vehicle_categoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle_category>
          }
          groupBy: {
            args: Prisma.vehicle_categoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_categoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.vehicle_categoryCountArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_categoryCountAggregateOutputType> | number
          }
        }
      }
      vehicle_merk: {
        payload: Prisma.$vehicle_merkPayload<ExtArgs>
        fields: Prisma.vehicle_merkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehicle_merkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_merkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehicle_merkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_merkPayload>
          }
          findFirst: {
            args: Prisma.vehicle_merkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_merkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehicle_merkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_merkPayload>
          }
          findMany: {
            args: Prisma.vehicle_merkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_merkPayload>[]
          }
          create: {
            args: Prisma.vehicle_merkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_merkPayload>
          }
          createMany: {
            args: Prisma.vehicle_merkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.vehicle_merkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_merkPayload>[]
          }
          delete: {
            args: Prisma.vehicle_merkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_merkPayload>
          }
          update: {
            args: Prisma.vehicle_merkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_merkPayload>
          }
          deleteMany: {
            args: Prisma.vehicle_merkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehicle_merkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.vehicle_merkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_merkPayload>[]
          }
          upsert: {
            args: Prisma.vehicle_merkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_merkPayload>
          }
          aggregate: {
            args: Prisma.Vehicle_merkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle_merk>
          }
          groupBy: {
            args: Prisma.vehicle_merkGroupByArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_merkGroupByOutputType>[]
          }
          count: {
            args: Prisma.vehicle_merkCountArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_merkCountAggregateOutputType> | number
          }
        }
      }
      vehicle_type: {
        payload: Prisma.$vehicle_typePayload<ExtArgs>
        fields: Prisma.vehicle_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehicle_typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehicle_typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typePayload>
          }
          findFirst: {
            args: Prisma.vehicle_typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehicle_typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typePayload>
          }
          findMany: {
            args: Prisma.vehicle_typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typePayload>[]
          }
          create: {
            args: Prisma.vehicle_typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typePayload>
          }
          createMany: {
            args: Prisma.vehicle_typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.vehicle_typeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typePayload>[]
          }
          delete: {
            args: Prisma.vehicle_typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typePayload>
          }
          update: {
            args: Prisma.vehicle_typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typePayload>
          }
          deleteMany: {
            args: Prisma.vehicle_typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehicle_typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.vehicle_typeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typePayload>[]
          }
          upsert: {
            args: Prisma.vehicle_typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_typePayload>
          }
          aggregate: {
            args: Prisma.Vehicle_typeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle_type>
          }
          groupBy: {
            args: Prisma.vehicle_typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.vehicle_typeCountArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_typeCountAggregateOutputType> | number
          }
        }
      }
      vehicle_year: {
        payload: Prisma.$vehicle_yearPayload<ExtArgs>
        fields: Prisma.vehicle_yearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehicle_yearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_yearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehicle_yearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_yearPayload>
          }
          findFirst: {
            args: Prisma.vehicle_yearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_yearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehicle_yearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_yearPayload>
          }
          findMany: {
            args: Prisma.vehicle_yearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_yearPayload>[]
          }
          create: {
            args: Prisma.vehicle_yearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_yearPayload>
          }
          createMany: {
            args: Prisma.vehicle_yearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.vehicle_yearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_yearPayload>[]
          }
          delete: {
            args: Prisma.vehicle_yearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_yearPayload>
          }
          update: {
            args: Prisma.vehicle_yearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_yearPayload>
          }
          deleteMany: {
            args: Prisma.vehicle_yearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehicle_yearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.vehicle_yearUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_yearPayload>[]
          }
          upsert: {
            args: Prisma.vehicle_yearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_yearPayload>
          }
          aggregate: {
            args: Prisma.Vehicle_yearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle_year>
          }
          groupBy: {
            args: Prisma.vehicle_yearGroupByArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_yearGroupByOutputType>[]
          }
          count: {
            args: Prisma.vehicle_yearCountArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_yearCountAggregateOutputType> | number
          }
        }
      }
      warehouse: {
        payload: Prisma.$warehousePayload<ExtArgs>
        fields: Prisma.warehouseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.warehouseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehousePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.warehouseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehousePayload>
          }
          findFirst: {
            args: Prisma.warehouseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehousePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.warehouseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehousePayload>
          }
          findMany: {
            args: Prisma.warehouseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehousePayload>[]
          }
          create: {
            args: Prisma.warehouseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehousePayload>
          }
          createMany: {
            args: Prisma.warehouseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.warehouseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehousePayload>[]
          }
          delete: {
            args: Prisma.warehouseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehousePayload>
          }
          update: {
            args: Prisma.warehouseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehousePayload>
          }
          deleteMany: {
            args: Prisma.warehouseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.warehouseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.warehouseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehousePayload>[]
          }
          upsert: {
            args: Prisma.warehouseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehousePayload>
          }
          aggregate: {
            args: Prisma.WarehouseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouse>
          }
          groupBy: {
            args: Prisma.warehouseGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseGroupByOutputType>[]
          }
          count: {
            args: Prisma.warehouseCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseCountAggregateOutputType> | number
          }
        }
      }
      warehouse_inventory: {
        payload: Prisma.$warehouse_inventoryPayload<ExtArgs>
        fields: Prisma.warehouse_inventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.warehouse_inventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehouse_inventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.warehouse_inventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehouse_inventoryPayload>
          }
          findFirst: {
            args: Prisma.warehouse_inventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehouse_inventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.warehouse_inventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehouse_inventoryPayload>
          }
          findMany: {
            args: Prisma.warehouse_inventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehouse_inventoryPayload>[]
          }
          create: {
            args: Prisma.warehouse_inventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehouse_inventoryPayload>
          }
          createMany: {
            args: Prisma.warehouse_inventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.warehouse_inventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehouse_inventoryPayload>[]
          }
          delete: {
            args: Prisma.warehouse_inventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehouse_inventoryPayload>
          }
          update: {
            args: Prisma.warehouse_inventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehouse_inventoryPayload>
          }
          deleteMany: {
            args: Prisma.warehouse_inventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.warehouse_inventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.warehouse_inventoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehouse_inventoryPayload>[]
          }
          upsert: {
            args: Prisma.warehouse_inventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warehouse_inventoryPayload>
          }
          aggregate: {
            args: Prisma.Warehouse_inventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouse_inventory>
          }
          groupBy: {
            args: Prisma.warehouse_inventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Warehouse_inventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.warehouse_inventoryCountArgs<ExtArgs>
            result: $Utils.Optional<Warehouse_inventoryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    barang?: barangOmit
    employee?: employeeOmit
    inventory?: inventoryOmit
    level?: levelOmit
    mekanik?: mekanikOmit
    member?: memberOmit
    order_barang?: order_barangOmit
    order_barang_detail?: order_barang_detailOmit
    status?: statusOmit
    transaksi?: transaksiOmit
    transaksi_detail?: transaksi_detailOmit
    users?: usersOmit
    vehicle_category?: vehicle_categoryOmit
    vehicle_merk?: vehicle_merkOmit
    vehicle_type?: vehicle_typeOmit
    vehicle_year?: vehicle_yearOmit
    warehouse?: warehouseOmit
    warehouse_inventory?: warehouse_inventoryOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BarangCountOutputType
   */

  export type BarangCountOutputType = {
    inventory: number
    order_barang_detail: number
    transaksi_detail: number
  }

  export type BarangCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | BarangCountOutputTypeCountInventoryArgs
    order_barang_detail?: boolean | BarangCountOutputTypeCountOrder_barang_detailArgs
    transaksi_detail?: boolean | BarangCountOutputTypeCountTransaksi_detailArgs
  }

  // Custom InputTypes
  /**
   * BarangCountOutputType without action
   */
  export type BarangCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarangCountOutputType
     */
    select?: BarangCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BarangCountOutputType without action
   */
  export type BarangCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inventoryWhereInput
  }

  /**
   * BarangCountOutputType without action
   */
  export type BarangCountOutputTypeCountOrder_barang_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_barang_detailWhereInput
  }

  /**
   * BarangCountOutputType without action
   */
  export type BarangCountOutputTypeCountTransaksi_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaksi_detailWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    mekanik: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mekanik?: boolean | EmployeeCountOutputTypeCountMekanikArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountMekanikArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mekanikWhereInput
  }


  /**
   * Count Type LevelCountOutputType
   */

  export type LevelCountOutputType = {
    warehouse: number
  }

  export type LevelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | LevelCountOutputTypeCountWarehouseArgs
  }

  // Custom InputTypes
  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelCountOutputType
     */
    select?: LevelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeCountWarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: warehouseWhereInput
  }


  /**
   * Count Type MekanikCountOutputType
   */

  export type MekanikCountOutputType = {
    transaksi: number
  }

  export type MekanikCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaksi?: boolean | MekanikCountOutputTypeCountTransaksiArgs
  }

  // Custom InputTypes
  /**
   * MekanikCountOutputType without action
   */
  export type MekanikCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MekanikCountOutputType
     */
    select?: MekanikCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MekanikCountOutputType without action
   */
  export type MekanikCountOutputTypeCountTransaksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaksiWhereInput
  }


  /**
   * Count Type MemberCountOutputType
   */

  export type MemberCountOutputType = {
    users: number
  }

  export type MemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | MemberCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCountOutputType
     */
    select?: MemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type Order_barangCountOutputType
   */

  export type Order_barangCountOutputType = {
    order_barang_detail: number
  }

  export type Order_barangCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order_barang_detail?: boolean | Order_barangCountOutputTypeCountOrder_barang_detailArgs
  }

  // Custom InputTypes
  /**
   * Order_barangCountOutputType without action
   */
  export type Order_barangCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order_barangCountOutputType
     */
    select?: Order_barangCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Order_barangCountOutputType without action
   */
  export type Order_barangCountOutputTypeCountOrder_barang_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_barang_detailWhereInput
  }


  /**
   * Count Type StatusCountOutputType
   */

  export type StatusCountOutputType = {
    employee: number
    users: number
  }

  export type StatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | StatusCountOutputTypeCountEmployeeArgs
    users?: boolean | StatusCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * StatusCountOutputType without action
   */
  export type StatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusCountOutputType
     */
    select?: StatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StatusCountOutputType without action
   */
  export type StatusCountOutputTypeCountEmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeWhereInput
  }

  /**
   * StatusCountOutputType without action
   */
  export type StatusCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type TransaksiCountOutputType
   */

  export type TransaksiCountOutputType = {
    transaksi_detail: number
  }

  export type TransaksiCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaksi_detail?: boolean | TransaksiCountOutputTypeCountTransaksi_detailArgs
  }

  // Custom InputTypes
  /**
   * TransaksiCountOutputType without action
   */
  export type TransaksiCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransaksiCountOutputType
     */
    select?: TransaksiCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransaksiCountOutputType without action
   */
  export type TransaksiCountOutputTypeCountTransaksi_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaksi_detailWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    transaksi: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaksi?: boolean | UsersCountOutputTypeCountTransaksiArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTransaksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaksiWhereInput
  }


  /**
   * Count Type Vehicle_categoryCountOutputType
   */

  export type Vehicle_categoryCountOutputType = {
    barang: number
    vehicle_type: number
  }

  export type Vehicle_categoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barang?: boolean | Vehicle_categoryCountOutputTypeCountBarangArgs
    vehicle_type?: boolean | Vehicle_categoryCountOutputTypeCountVehicle_typeArgs
  }

  // Custom InputTypes
  /**
   * Vehicle_categoryCountOutputType without action
   */
  export type Vehicle_categoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle_categoryCountOutputType
     */
    select?: Vehicle_categoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Vehicle_categoryCountOutputType without action
   */
  export type Vehicle_categoryCountOutputTypeCountBarangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: barangWhereInput
  }

  /**
   * Vehicle_categoryCountOutputType without action
   */
  export type Vehicle_categoryCountOutputTypeCountVehicle_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_typeWhereInput
  }


  /**
   * Count Type Vehicle_merkCountOutputType
   */

  export type Vehicle_merkCountOutputType = {
    users: number
  }

  export type Vehicle_merkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Vehicle_merkCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * Vehicle_merkCountOutputType without action
   */
  export type Vehicle_merkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle_merkCountOutputType
     */
    select?: Vehicle_merkCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Vehicle_merkCountOutputType without action
   */
  export type Vehicle_merkCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type Vehicle_typeCountOutputType
   */

  export type Vehicle_typeCountOutputType = {
    users: number
  }

  export type Vehicle_typeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Vehicle_typeCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * Vehicle_typeCountOutputType without action
   */
  export type Vehicle_typeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle_typeCountOutputType
     */
    select?: Vehicle_typeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Vehicle_typeCountOutputType without action
   */
  export type Vehicle_typeCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type Vehicle_yearCountOutputType
   */

  export type Vehicle_yearCountOutputType = {
    users: number
  }

  export type Vehicle_yearCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Vehicle_yearCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * Vehicle_yearCountOutputType without action
   */
  export type Vehicle_yearCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle_yearCountOutputType
     */
    select?: Vehicle_yearCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Vehicle_yearCountOutputType without action
   */
  export type Vehicle_yearCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type WarehouseCountOutputType
   */

  export type WarehouseCountOutputType = {
    mekanik: number
    order_barang_order_barang_from_warehouse_idTowarehouse: number
    order_barang_order_barang_to_warehouse_idTowarehouse: number
    transaksi: number
    warehouse_inventory: number
  }

  export type WarehouseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mekanik?: boolean | WarehouseCountOutputTypeCountMekanikArgs
    order_barang_order_barang_from_warehouse_idTowarehouse?: boolean | WarehouseCountOutputTypeCountOrder_barang_order_barang_from_warehouse_idTowarehouseArgs
    order_barang_order_barang_to_warehouse_idTowarehouse?: boolean | WarehouseCountOutputTypeCountOrder_barang_order_barang_to_warehouse_idTowarehouseArgs
    transaksi?: boolean | WarehouseCountOutputTypeCountTransaksiArgs
    warehouse_inventory?: boolean | WarehouseCountOutputTypeCountWarehouse_inventoryArgs
  }

  // Custom InputTypes
  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseCountOutputType
     */
    select?: WarehouseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountMekanikArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mekanikWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountOrder_barang_order_barang_from_warehouse_idTowarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_barangWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountOrder_barang_order_barang_to_warehouse_idTowarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_barangWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountTransaksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaksiWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountWarehouse_inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: warehouse_inventoryWhereInput
  }


  /**
   * Count Type Warehouse_inventoryCountOutputType
   */

  export type Warehouse_inventoryCountOutputType = {
    inventory: number
  }

  export type Warehouse_inventoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | Warehouse_inventoryCountOutputTypeCountInventoryArgs
  }

  // Custom InputTypes
  /**
   * Warehouse_inventoryCountOutputType without action
   */
  export type Warehouse_inventoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse_inventoryCountOutputType
     */
    select?: Warehouse_inventoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Warehouse_inventoryCountOutputType without action
   */
  export type Warehouse_inventoryCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inventoryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model barang
   */

  export type AggregateBarang = {
    _count: BarangCountAggregateOutputType | null
    _avg: BarangAvgAggregateOutputType | null
    _sum: BarangSumAggregateOutputType | null
    _min: BarangMinAggregateOutputType | null
    _max: BarangMaxAggregateOutputType | null
  }

  export type BarangAvgAggregateOutputType = {
    price: Decimal | null
    point: number | null
  }

  export type BarangSumAggregateOutputType = {
    price: Decimal | null
    point: number | null
  }

  export type BarangMinAggregateOutputType = {
    id: string | null
    category_vehicle_id: string | null
    name_barang: string | null
    description_barang: string | null
    price: Decimal | null
    point: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BarangMaxAggregateOutputType = {
    id: string | null
    category_vehicle_id: string | null
    name_barang: string | null
    description_barang: string | null
    price: Decimal | null
    point: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BarangCountAggregateOutputType = {
    id: number
    category_vehicle_id: number
    name_barang: number
    description_barang: number
    price: number
    point: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BarangAvgAggregateInputType = {
    price?: true
    point?: true
  }

  export type BarangSumAggregateInputType = {
    price?: true
    point?: true
  }

  export type BarangMinAggregateInputType = {
    id?: true
    category_vehicle_id?: true
    name_barang?: true
    description_barang?: true
    price?: true
    point?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BarangMaxAggregateInputType = {
    id?: true
    category_vehicle_id?: true
    name_barang?: true
    description_barang?: true
    price?: true
    point?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BarangCountAggregateInputType = {
    id?: true
    category_vehicle_id?: true
    name_barang?: true
    description_barang?: true
    price?: true
    point?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BarangAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which barang to aggregate.
     */
    where?: barangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of barangs to fetch.
     */
    orderBy?: barangOrderByWithRelationInput | barangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: barangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` barangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` barangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned barangs
    **/
    _count?: true | BarangCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BarangAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BarangSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BarangMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BarangMaxAggregateInputType
  }

  export type GetBarangAggregateType<T extends BarangAggregateArgs> = {
        [P in keyof T & keyof AggregateBarang]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarang[P]>
      : GetScalarType<T[P], AggregateBarang[P]>
  }




  export type barangGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: barangWhereInput
    orderBy?: barangOrderByWithAggregationInput | barangOrderByWithAggregationInput[]
    by: BarangScalarFieldEnum[] | BarangScalarFieldEnum
    having?: barangScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BarangCountAggregateInputType | true
    _avg?: BarangAvgAggregateInputType
    _sum?: BarangSumAggregateInputType
    _min?: BarangMinAggregateInputType
    _max?: BarangMaxAggregateInputType
  }

  export type BarangGroupByOutputType = {
    id: string
    category_vehicle_id: string
    name_barang: string
    description_barang: string | null
    price: Decimal
    point: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: BarangCountAggregateOutputType | null
    _avg: BarangAvgAggregateOutputType | null
    _sum: BarangSumAggregateOutputType | null
    _min: BarangMinAggregateOutputType | null
    _max: BarangMaxAggregateOutputType | null
  }

  type GetBarangGroupByPayload<T extends barangGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BarangGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BarangGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarangGroupByOutputType[P]>
            : GetScalarType<T[P], BarangGroupByOutputType[P]>
        }
      >
    >


  export type barangSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_vehicle_id?: boolean
    name_barang?: boolean
    description_barang?: boolean
    price?: boolean
    point?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicle_category?: boolean | vehicle_categoryDefaultArgs<ExtArgs>
    inventory?: boolean | barang$inventoryArgs<ExtArgs>
    order_barang_detail?: boolean | barang$order_barang_detailArgs<ExtArgs>
    transaksi_detail?: boolean | barang$transaksi_detailArgs<ExtArgs>
    _count?: boolean | BarangCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barang"]>

  export type barangSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_vehicle_id?: boolean
    name_barang?: boolean
    description_barang?: boolean
    price?: boolean
    point?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicle_category?: boolean | vehicle_categoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barang"]>

  export type barangSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_vehicle_id?: boolean
    name_barang?: boolean
    description_barang?: boolean
    price?: boolean
    point?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicle_category?: boolean | vehicle_categoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barang"]>

  export type barangSelectScalar = {
    id?: boolean
    category_vehicle_id?: boolean
    name_barang?: boolean
    description_barang?: boolean
    price?: boolean
    point?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type barangOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category_vehicle_id" | "name_barang" | "description_barang" | "price" | "point" | "createdAt" | "updatedAt", ExtArgs["result"]["barang"]>
  export type barangInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle_category?: boolean | vehicle_categoryDefaultArgs<ExtArgs>
    inventory?: boolean | barang$inventoryArgs<ExtArgs>
    order_barang_detail?: boolean | barang$order_barang_detailArgs<ExtArgs>
    transaksi_detail?: boolean | barang$transaksi_detailArgs<ExtArgs>
    _count?: boolean | BarangCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type barangIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle_category?: boolean | vehicle_categoryDefaultArgs<ExtArgs>
  }
  export type barangIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle_category?: boolean | vehicle_categoryDefaultArgs<ExtArgs>
  }

  export type $barangPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "barang"
    objects: {
      vehicle_category: Prisma.$vehicle_categoryPayload<ExtArgs>
      inventory: Prisma.$inventoryPayload<ExtArgs>[]
      order_barang_detail: Prisma.$order_barang_detailPayload<ExtArgs>[]
      transaksi_detail: Prisma.$transaksi_detailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category_vehicle_id: string
      name_barang: string
      description_barang: string | null
      price: Prisma.Decimal
      point: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["barang"]>
    composites: {}
  }

  type barangGetPayload<S extends boolean | null | undefined | barangDefaultArgs> = $Result.GetResult<Prisma.$barangPayload, S>

  type barangCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<barangFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BarangCountAggregateInputType | true
    }

  export interface barangDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['barang'], meta: { name: 'barang' } }
    /**
     * Find zero or one Barang that matches the filter.
     * @param {barangFindUniqueArgs} args - Arguments to find a Barang
     * @example
     * // Get one Barang
     * const barang = await prisma.barang.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends barangFindUniqueArgs>(args: SelectSubset<T, barangFindUniqueArgs<ExtArgs>>): Prisma__barangClient<$Result.GetResult<Prisma.$barangPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Barang that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {barangFindUniqueOrThrowArgs} args - Arguments to find a Barang
     * @example
     * // Get one Barang
     * const barang = await prisma.barang.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends barangFindUniqueOrThrowArgs>(args: SelectSubset<T, barangFindUniqueOrThrowArgs<ExtArgs>>): Prisma__barangClient<$Result.GetResult<Prisma.$barangPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Barang that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {barangFindFirstArgs} args - Arguments to find a Barang
     * @example
     * // Get one Barang
     * const barang = await prisma.barang.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends barangFindFirstArgs>(args?: SelectSubset<T, barangFindFirstArgs<ExtArgs>>): Prisma__barangClient<$Result.GetResult<Prisma.$barangPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Barang that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {barangFindFirstOrThrowArgs} args - Arguments to find a Barang
     * @example
     * // Get one Barang
     * const barang = await prisma.barang.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends barangFindFirstOrThrowArgs>(args?: SelectSubset<T, barangFindFirstOrThrowArgs<ExtArgs>>): Prisma__barangClient<$Result.GetResult<Prisma.$barangPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Barangs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {barangFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Barangs
     * const barangs = await prisma.barang.findMany()
     * 
     * // Get first 10 Barangs
     * const barangs = await prisma.barang.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const barangWithIdOnly = await prisma.barang.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends barangFindManyArgs>(args?: SelectSubset<T, barangFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$barangPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Barang.
     * @param {barangCreateArgs} args - Arguments to create a Barang.
     * @example
     * // Create one Barang
     * const Barang = await prisma.barang.create({
     *   data: {
     *     // ... data to create a Barang
     *   }
     * })
     * 
     */
    create<T extends barangCreateArgs>(args: SelectSubset<T, barangCreateArgs<ExtArgs>>): Prisma__barangClient<$Result.GetResult<Prisma.$barangPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Barangs.
     * @param {barangCreateManyArgs} args - Arguments to create many Barangs.
     * @example
     * // Create many Barangs
     * const barang = await prisma.barang.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends barangCreateManyArgs>(args?: SelectSubset<T, barangCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Barangs and returns the data saved in the database.
     * @param {barangCreateManyAndReturnArgs} args - Arguments to create many Barangs.
     * @example
     * // Create many Barangs
     * const barang = await prisma.barang.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Barangs and only return the `id`
     * const barangWithIdOnly = await prisma.barang.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends barangCreateManyAndReturnArgs>(args?: SelectSubset<T, barangCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$barangPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Barang.
     * @param {barangDeleteArgs} args - Arguments to delete one Barang.
     * @example
     * // Delete one Barang
     * const Barang = await prisma.barang.delete({
     *   where: {
     *     // ... filter to delete one Barang
     *   }
     * })
     * 
     */
    delete<T extends barangDeleteArgs>(args: SelectSubset<T, barangDeleteArgs<ExtArgs>>): Prisma__barangClient<$Result.GetResult<Prisma.$barangPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Barang.
     * @param {barangUpdateArgs} args - Arguments to update one Barang.
     * @example
     * // Update one Barang
     * const barang = await prisma.barang.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends barangUpdateArgs>(args: SelectSubset<T, barangUpdateArgs<ExtArgs>>): Prisma__barangClient<$Result.GetResult<Prisma.$barangPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Barangs.
     * @param {barangDeleteManyArgs} args - Arguments to filter Barangs to delete.
     * @example
     * // Delete a few Barangs
     * const { count } = await prisma.barang.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends barangDeleteManyArgs>(args?: SelectSubset<T, barangDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Barangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {barangUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Barangs
     * const barang = await prisma.barang.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends barangUpdateManyArgs>(args: SelectSubset<T, barangUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Barangs and returns the data updated in the database.
     * @param {barangUpdateManyAndReturnArgs} args - Arguments to update many Barangs.
     * @example
     * // Update many Barangs
     * const barang = await prisma.barang.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Barangs and only return the `id`
     * const barangWithIdOnly = await prisma.barang.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends barangUpdateManyAndReturnArgs>(args: SelectSubset<T, barangUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$barangPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Barang.
     * @param {barangUpsertArgs} args - Arguments to update or create a Barang.
     * @example
     * // Update or create a Barang
     * const barang = await prisma.barang.upsert({
     *   create: {
     *     // ... data to create a Barang
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Barang we want to update
     *   }
     * })
     */
    upsert<T extends barangUpsertArgs>(args: SelectSubset<T, barangUpsertArgs<ExtArgs>>): Prisma__barangClient<$Result.GetResult<Prisma.$barangPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Barangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {barangCountArgs} args - Arguments to filter Barangs to count.
     * @example
     * // Count the number of Barangs
     * const count = await prisma.barang.count({
     *   where: {
     *     // ... the filter for the Barangs we want to count
     *   }
     * })
    **/
    count<T extends barangCountArgs>(
      args?: Subset<T, barangCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarangCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Barang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarangAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BarangAggregateArgs>(args: Subset<T, BarangAggregateArgs>): Prisma.PrismaPromise<GetBarangAggregateType<T>>

    /**
     * Group by Barang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {barangGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends barangGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: barangGroupByArgs['orderBy'] }
        : { orderBy?: barangGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, barangGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBarangGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the barang model
   */
  readonly fields: barangFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for barang.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__barangClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicle_category<T extends vehicle_categoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_categoryDefaultArgs<ExtArgs>>): Prisma__vehicle_categoryClient<$Result.GetResult<Prisma.$vehicle_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inventory<T extends barang$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, barang$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    order_barang_detail<T extends barang$order_barang_detailArgs<ExtArgs> = {}>(args?: Subset<T, barang$order_barang_detailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_barang_detailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transaksi_detail<T extends barang$transaksi_detailArgs<ExtArgs> = {}>(args?: Subset<T, barang$transaksi_detailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaksi_detailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the barang model
   */
  interface barangFieldRefs {
    readonly id: FieldRef<"barang", 'String'>
    readonly category_vehicle_id: FieldRef<"barang", 'String'>
    readonly name_barang: FieldRef<"barang", 'String'>
    readonly description_barang: FieldRef<"barang", 'String'>
    readonly price: FieldRef<"barang", 'Decimal'>
    readonly point: FieldRef<"barang", 'Int'>
    readonly createdAt: FieldRef<"barang", 'DateTime'>
    readonly updatedAt: FieldRef<"barang", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * barang findUnique
   */
  export type barangFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barang
     */
    select?: barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barang
     */
    omit?: barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: barangInclude<ExtArgs> | null
    /**
     * Filter, which barang to fetch.
     */
    where: barangWhereUniqueInput
  }

  /**
   * barang findUniqueOrThrow
   */
  export type barangFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barang
     */
    select?: barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barang
     */
    omit?: barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: barangInclude<ExtArgs> | null
    /**
     * Filter, which barang to fetch.
     */
    where: barangWhereUniqueInput
  }

  /**
   * barang findFirst
   */
  export type barangFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barang
     */
    select?: barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barang
     */
    omit?: barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: barangInclude<ExtArgs> | null
    /**
     * Filter, which barang to fetch.
     */
    where?: barangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of barangs to fetch.
     */
    orderBy?: barangOrderByWithRelationInput | barangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for barangs.
     */
    cursor?: barangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` barangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` barangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of barangs.
     */
    distinct?: BarangScalarFieldEnum | BarangScalarFieldEnum[]
  }

  /**
   * barang findFirstOrThrow
   */
  export type barangFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barang
     */
    select?: barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barang
     */
    omit?: barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: barangInclude<ExtArgs> | null
    /**
     * Filter, which barang to fetch.
     */
    where?: barangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of barangs to fetch.
     */
    orderBy?: barangOrderByWithRelationInput | barangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for barangs.
     */
    cursor?: barangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` barangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` barangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of barangs.
     */
    distinct?: BarangScalarFieldEnum | BarangScalarFieldEnum[]
  }

  /**
   * barang findMany
   */
  export type barangFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barang
     */
    select?: barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barang
     */
    omit?: barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: barangInclude<ExtArgs> | null
    /**
     * Filter, which barangs to fetch.
     */
    where?: barangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of barangs to fetch.
     */
    orderBy?: barangOrderByWithRelationInput | barangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing barangs.
     */
    cursor?: barangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` barangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` barangs.
     */
    skip?: number
    distinct?: BarangScalarFieldEnum | BarangScalarFieldEnum[]
  }

  /**
   * barang create
   */
  export type barangCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barang
     */
    select?: barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barang
     */
    omit?: barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: barangInclude<ExtArgs> | null
    /**
     * The data needed to create a barang.
     */
    data: XOR<barangCreateInput, barangUncheckedCreateInput>
  }

  /**
   * barang createMany
   */
  export type barangCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many barangs.
     */
    data: barangCreateManyInput | barangCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * barang createManyAndReturn
   */
  export type barangCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barang
     */
    select?: barangSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the barang
     */
    omit?: barangOmit<ExtArgs> | null
    /**
     * The data used to create many barangs.
     */
    data: barangCreateManyInput | barangCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: barangIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * barang update
   */
  export type barangUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barang
     */
    select?: barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barang
     */
    omit?: barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: barangInclude<ExtArgs> | null
    /**
     * The data needed to update a barang.
     */
    data: XOR<barangUpdateInput, barangUncheckedUpdateInput>
    /**
     * Choose, which barang to update.
     */
    where: barangWhereUniqueInput
  }

  /**
   * barang updateMany
   */
  export type barangUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update barangs.
     */
    data: XOR<barangUpdateManyMutationInput, barangUncheckedUpdateManyInput>
    /**
     * Filter which barangs to update
     */
    where?: barangWhereInput
    /**
     * Limit how many barangs to update.
     */
    limit?: number
  }

  /**
   * barang updateManyAndReturn
   */
  export type barangUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barang
     */
    select?: barangSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the barang
     */
    omit?: barangOmit<ExtArgs> | null
    /**
     * The data used to update barangs.
     */
    data: XOR<barangUpdateManyMutationInput, barangUncheckedUpdateManyInput>
    /**
     * Filter which barangs to update
     */
    where?: barangWhereInput
    /**
     * Limit how many barangs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: barangIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * barang upsert
   */
  export type barangUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barang
     */
    select?: barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barang
     */
    omit?: barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: barangInclude<ExtArgs> | null
    /**
     * The filter to search for the barang to update in case it exists.
     */
    where: barangWhereUniqueInput
    /**
     * In case the barang found by the `where` argument doesn't exist, create a new barang with this data.
     */
    create: XOR<barangCreateInput, barangUncheckedCreateInput>
    /**
     * In case the barang was found with the provided `where` argument, update it with this data.
     */
    update: XOR<barangUpdateInput, barangUncheckedUpdateInput>
  }

  /**
   * barang delete
   */
  export type barangDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barang
     */
    select?: barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barang
     */
    omit?: barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: barangInclude<ExtArgs> | null
    /**
     * Filter which barang to delete.
     */
    where: barangWhereUniqueInput
  }

  /**
   * barang deleteMany
   */
  export type barangDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which barangs to delete
     */
    where?: barangWhereInput
    /**
     * Limit how many barangs to delete.
     */
    limit?: number
  }

  /**
   * barang.inventory
   */
  export type barang$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    where?: inventoryWhereInput
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    cursor?: inventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * barang.order_barang_detail
   */
  export type barang$order_barang_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang_detail
     */
    select?: order_barang_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang_detail
     */
    omit?: order_barang_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barang_detailInclude<ExtArgs> | null
    where?: order_barang_detailWhereInput
    orderBy?: order_barang_detailOrderByWithRelationInput | order_barang_detailOrderByWithRelationInput[]
    cursor?: order_barang_detailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_barang_detailScalarFieldEnum | Order_barang_detailScalarFieldEnum[]
  }

  /**
   * barang.transaksi_detail
   */
  export type barang$transaksi_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_detail
     */
    select?: transaksi_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi_detail
     */
    omit?: transaksi_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksi_detailInclude<ExtArgs> | null
    where?: transaksi_detailWhereInput
    orderBy?: transaksi_detailOrderByWithRelationInput | transaksi_detailOrderByWithRelationInput[]
    cursor?: transaksi_detailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Transaksi_detailScalarFieldEnum | Transaksi_detailScalarFieldEnum[]
  }

  /**
   * barang without action
   */
  export type barangDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barang
     */
    select?: barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barang
     */
    omit?: barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: barangInclude<ExtArgs> | null
  }


  /**
   * Model employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    point: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    point: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    status_id: string | null
    name: string | null
    point: number | null
    address: string | null
    phone_number: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    status_id: string | null
    name: string | null
    point: number | null
    address: string | null
    phone_number: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    status_id: number
    name: number
    point: number
    address: number
    phone_number: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    point?: true
  }

  export type EmployeeSumAggregateInputType = {
    point?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    status_id?: true
    name?: true
    point?: true
    address?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    status_id?: true
    name?: true
    point?: true
    address?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    status_id?: true
    name?: true
    point?: true
    address?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employee to aggregate.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type employeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeWhereInput
    orderBy?: employeeOrderByWithAggregationInput | employeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: employeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    status_id: string
    name: string
    point: number | null
    address: string | null
    phone_number: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends employeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type employeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status_id?: boolean
    name?: boolean
    point?: boolean
    address?: boolean
    phone_number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean | statusDefaultArgs<ExtArgs>
    mekanik?: boolean | employee$mekanikArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type employeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status_id?: boolean
    name?: boolean
    point?: boolean
    address?: boolean
    phone_number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean | statusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type employeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status_id?: boolean
    name?: boolean
    point?: boolean
    address?: boolean
    phone_number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean | statusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type employeeSelectScalar = {
    id?: boolean
    status_id?: boolean
    name?: boolean
    point?: boolean
    address?: boolean
    phone_number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type employeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status_id" | "name" | "point" | "address" | "phone_number" | "createdAt" | "updatedAt", ExtArgs["result"]["employee"]>
  export type employeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    status?: boolean | statusDefaultArgs<ExtArgs>
    mekanik?: boolean | employee$mekanikArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type employeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    status?: boolean | statusDefaultArgs<ExtArgs>
  }
  export type employeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    status?: boolean | statusDefaultArgs<ExtArgs>
  }

  export type $employeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "employee"
    objects: {
      status: Prisma.$statusPayload<ExtArgs>
      mekanik: Prisma.$mekanikPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status_id: string
      name: string
      point: number | null
      address: string | null
      phone_number: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type employeeGetPayload<S extends boolean | null | undefined | employeeDefaultArgs> = $Result.GetResult<Prisma.$employeePayload, S>

  type employeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<employeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface employeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['employee'], meta: { name: 'employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {employeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends employeeFindUniqueArgs>(args: SelectSubset<T, employeeFindUniqueArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {employeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends employeeFindUniqueOrThrowArgs>(args: SelectSubset<T, employeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends employeeFindFirstArgs>(args?: SelectSubset<T, employeeFindFirstArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends employeeFindFirstOrThrowArgs>(args?: SelectSubset<T, employeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends employeeFindManyArgs>(args?: SelectSubset<T, employeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {employeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends employeeCreateArgs>(args: SelectSubset<T, employeeCreateArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {employeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends employeeCreateManyArgs>(args?: SelectSubset<T, employeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {employeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends employeeCreateManyAndReturnArgs>(args?: SelectSubset<T, employeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {employeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends employeeDeleteArgs>(args: SelectSubset<T, employeeDeleteArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {employeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends employeeUpdateArgs>(args: SelectSubset<T, employeeUpdateArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {employeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends employeeDeleteManyArgs>(args?: SelectSubset<T, employeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends employeeUpdateManyArgs>(args: SelectSubset<T, employeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {employeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends employeeUpdateManyAndReturnArgs>(args: SelectSubset<T, employeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {employeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends employeeUpsertArgs>(args: SelectSubset<T, employeeUpsertArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends employeeCountArgs>(
      args?: Subset<T, employeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends employeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: employeeGroupByArgs['orderBy'] }
        : { orderBy?: employeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, employeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the employee model
   */
  readonly fields: employeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__employeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    status<T extends statusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, statusDefaultArgs<ExtArgs>>): Prisma__statusClient<$Result.GetResult<Prisma.$statusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mekanik<T extends employee$mekanikArgs<ExtArgs> = {}>(args?: Subset<T, employee$mekanikArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mekanikPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the employee model
   */
  interface employeeFieldRefs {
    readonly id: FieldRef<"employee", 'String'>
    readonly status_id: FieldRef<"employee", 'String'>
    readonly name: FieldRef<"employee", 'String'>
    readonly point: FieldRef<"employee", 'Int'>
    readonly address: FieldRef<"employee", 'String'>
    readonly phone_number: FieldRef<"employee", 'String'>
    readonly createdAt: FieldRef<"employee", 'DateTime'>
    readonly updatedAt: FieldRef<"employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * employee findUnique
   */
  export type employeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee findUniqueOrThrow
   */
  export type employeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee findFirst
   */
  export type employeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employees.
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * employee findFirstOrThrow
   */
  export type employeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employees.
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * employee findMany
   */
  export type employeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employees.
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * employee create
   */
  export type employeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * The data needed to create a employee.
     */
    data: XOR<employeeCreateInput, employeeUncheckedCreateInput>
  }

  /**
   * employee createMany
   */
  export type employeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many employees.
     */
    data: employeeCreateManyInput | employeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * employee createManyAndReturn
   */
  export type employeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * The data used to create many employees.
     */
    data: employeeCreateManyInput | employeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * employee update
   */
  export type employeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * The data needed to update a employee.
     */
    data: XOR<employeeUpdateInput, employeeUncheckedUpdateInput>
    /**
     * Choose, which employee to update.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee updateMany
   */
  export type employeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update employees.
     */
    data: XOR<employeeUpdateManyMutationInput, employeeUncheckedUpdateManyInput>
    /**
     * Filter which employees to update
     */
    where?: employeeWhereInput
    /**
     * Limit how many employees to update.
     */
    limit?: number
  }

  /**
   * employee updateManyAndReturn
   */
  export type employeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * The data used to update employees.
     */
    data: XOR<employeeUpdateManyMutationInput, employeeUncheckedUpdateManyInput>
    /**
     * Filter which employees to update
     */
    where?: employeeWhereInput
    /**
     * Limit how many employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * employee upsert
   */
  export type employeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * The filter to search for the employee to update in case it exists.
     */
    where: employeeWhereUniqueInput
    /**
     * In case the employee found by the `where` argument doesn't exist, create a new employee with this data.
     */
    create: XOR<employeeCreateInput, employeeUncheckedCreateInput>
    /**
     * In case the employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<employeeUpdateInput, employeeUncheckedUpdateInput>
  }

  /**
   * employee delete
   */
  export type employeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter which employee to delete.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee deleteMany
   */
  export type employeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employees to delete
     */
    where?: employeeWhereInput
    /**
     * Limit how many employees to delete.
     */
    limit?: number
  }

  /**
   * employee.mekanik
   */
  export type employee$mekanikArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mekanik
     */
    select?: mekanikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mekanik
     */
    omit?: mekanikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mekanikInclude<ExtArgs> | null
    where?: mekanikWhereInput
    orderBy?: mekanikOrderByWithRelationInput | mekanikOrderByWithRelationInput[]
    cursor?: mekanikWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MekanikScalarFieldEnum | MekanikScalarFieldEnum[]
  }

  /**
   * employee without action
   */
  export type employeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
  }


  /**
   * Model inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    qty: number | null
  }

  export type InventorySumAggregateOutputType = {
    qty: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: string | null
    warehouse_inventory_id: string | null
    barang_id: string | null
    qty: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: string | null
    warehouse_inventory_id: string | null
    barang_id: string | null
    qty: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    warehouse_inventory_id: number
    barang_id: number
    qty: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    qty?: true
  }

  export type InventorySumAggregateInputType = {
    qty?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    warehouse_inventory_id?: true
    barang_id?: true
    qty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    warehouse_inventory_id?: true
    barang_id?: true
    qty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    warehouse_inventory_id?: true
    barang_id?: true
    qty?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventory to aggregate.
     */
    where?: inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type inventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inventoryWhereInput
    orderBy?: inventoryOrderByWithAggregationInput | inventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: inventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: string
    warehouse_inventory_id: string
    barang_id: string
    qty: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends inventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type inventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    warehouse_inventory_id?: boolean
    barang_id?: boolean
    qty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    barang?: boolean | barangDefaultArgs<ExtArgs>
    warehouse_inventory?: boolean | warehouse_inventoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type inventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    warehouse_inventory_id?: boolean
    barang_id?: boolean
    qty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    barang?: boolean | barangDefaultArgs<ExtArgs>
    warehouse_inventory?: boolean | warehouse_inventoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type inventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    warehouse_inventory_id?: boolean
    barang_id?: boolean
    qty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    barang?: boolean | barangDefaultArgs<ExtArgs>
    warehouse_inventory?: boolean | warehouse_inventoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type inventorySelectScalar = {
    id?: boolean
    warehouse_inventory_id?: boolean
    barang_id?: boolean
    qty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type inventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "warehouse_inventory_id" | "barang_id" | "qty" | "createdAt" | "updatedAt", ExtArgs["result"]["inventory"]>
  export type inventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barang?: boolean | barangDefaultArgs<ExtArgs>
    warehouse_inventory?: boolean | warehouse_inventoryDefaultArgs<ExtArgs>
  }
  export type inventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barang?: boolean | barangDefaultArgs<ExtArgs>
    warehouse_inventory?: boolean | warehouse_inventoryDefaultArgs<ExtArgs>
  }
  export type inventoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barang?: boolean | barangDefaultArgs<ExtArgs>
    warehouse_inventory?: boolean | warehouse_inventoryDefaultArgs<ExtArgs>
  }

  export type $inventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "inventory"
    objects: {
      barang: Prisma.$barangPayload<ExtArgs>
      warehouse_inventory: Prisma.$warehouse_inventoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      warehouse_inventory_id: string
      barang_id: string
      qty: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type inventoryGetPayload<S extends boolean | null | undefined | inventoryDefaultArgs> = $Result.GetResult<Prisma.$inventoryPayload, S>

  type inventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<inventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface inventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inventory'], meta: { name: 'inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {inventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends inventoryFindUniqueArgs>(args: SelectSubset<T, inventoryFindUniqueArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {inventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends inventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, inventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends inventoryFindFirstArgs>(args?: SelectSubset<T, inventoryFindFirstArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends inventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, inventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends inventoryFindManyArgs>(args?: SelectSubset<T, inventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventory.
     * @param {inventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends inventoryCreateArgs>(args: SelectSubset<T, inventoryCreateArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventories.
     * @param {inventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends inventoryCreateManyArgs>(args?: SelectSubset<T, inventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inventories and returns the data saved in the database.
     * @param {inventoryCreateManyAndReturnArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends inventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, inventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inventory.
     * @param {inventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends inventoryDeleteArgs>(args: SelectSubset<T, inventoryDeleteArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventory.
     * @param {inventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends inventoryUpdateArgs>(args: SelectSubset<T, inventoryUpdateArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventories.
     * @param {inventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends inventoryDeleteManyArgs>(args?: SelectSubset<T, inventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends inventoryUpdateManyArgs>(args: SelectSubset<T, inventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories and returns the data updated in the database.
     * @param {inventoryUpdateManyAndReturnArgs} args - Arguments to update many Inventories.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends inventoryUpdateManyAndReturnArgs>(args: SelectSubset<T, inventoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inventory.
     * @param {inventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends inventoryUpsertArgs>(args: SelectSubset<T, inventoryUpsertArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends inventoryCountArgs>(
      args?: Subset<T, inventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inventoryGroupByArgs['orderBy'] }
        : { orderBy?: inventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inventory model
   */
  readonly fields: inventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    barang<T extends barangDefaultArgs<ExtArgs> = {}>(args?: Subset<T, barangDefaultArgs<ExtArgs>>): Prisma__barangClient<$Result.GetResult<Prisma.$barangPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    warehouse_inventory<T extends warehouse_inventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, warehouse_inventoryDefaultArgs<ExtArgs>>): Prisma__warehouse_inventoryClient<$Result.GetResult<Prisma.$warehouse_inventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the inventory model
   */
  interface inventoryFieldRefs {
    readonly id: FieldRef<"inventory", 'String'>
    readonly warehouse_inventory_id: FieldRef<"inventory", 'String'>
    readonly barang_id: FieldRef<"inventory", 'String'>
    readonly qty: FieldRef<"inventory", 'Int'>
    readonly createdAt: FieldRef<"inventory", 'DateTime'>
    readonly updatedAt: FieldRef<"inventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * inventory findUnique
   */
  export type inventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * Filter, which inventory to fetch.
     */
    where: inventoryWhereUniqueInput
  }

  /**
   * inventory findUniqueOrThrow
   */
  export type inventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * Filter, which inventory to fetch.
     */
    where: inventoryWhereUniqueInput
  }

  /**
   * inventory findFirst
   */
  export type inventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * Filter, which inventory to fetch.
     */
    where?: inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventories.
     */
    cursor?: inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * inventory findFirstOrThrow
   */
  export type inventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * Filter, which inventory to fetch.
     */
    where?: inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventories.
     */
    cursor?: inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * inventory findMany
   */
  export type inventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * Filter, which inventories to fetch.
     */
    where?: inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inventories.
     */
    cursor?: inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * inventory create
   */
  export type inventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a inventory.
     */
    data: XOR<inventoryCreateInput, inventoryUncheckedCreateInput>
  }

  /**
   * inventory createMany
   */
  export type inventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inventories.
     */
    data: inventoryCreateManyInput | inventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * inventory createManyAndReturn
   */
  export type inventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * The data used to create many inventories.
     */
    data: inventoryCreateManyInput | inventoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * inventory update
   */
  export type inventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a inventory.
     */
    data: XOR<inventoryUpdateInput, inventoryUncheckedUpdateInput>
    /**
     * Choose, which inventory to update.
     */
    where: inventoryWhereUniqueInput
  }

  /**
   * inventory updateMany
   */
  export type inventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inventories.
     */
    data: XOR<inventoryUpdateManyMutationInput, inventoryUncheckedUpdateManyInput>
    /**
     * Filter which inventories to update
     */
    where?: inventoryWhereInput
    /**
     * Limit how many inventories to update.
     */
    limit?: number
  }

  /**
   * inventory updateManyAndReturn
   */
  export type inventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * The data used to update inventories.
     */
    data: XOR<inventoryUpdateManyMutationInput, inventoryUncheckedUpdateManyInput>
    /**
     * Filter which inventories to update
     */
    where?: inventoryWhereInput
    /**
     * Limit how many inventories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * inventory upsert
   */
  export type inventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the inventory to update in case it exists.
     */
    where: inventoryWhereUniqueInput
    /**
     * In case the inventory found by the `where` argument doesn't exist, create a new inventory with this data.
     */
    create: XOR<inventoryCreateInput, inventoryUncheckedCreateInput>
    /**
     * In case the inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inventoryUpdateInput, inventoryUncheckedUpdateInput>
  }

  /**
   * inventory delete
   */
  export type inventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * Filter which inventory to delete.
     */
    where: inventoryWhereUniqueInput
  }

  /**
   * inventory deleteMany
   */
  export type inventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventories to delete
     */
    where?: inventoryWhereInput
    /**
     * Limit how many inventories to delete.
     */
    limit?: number
  }

  /**
   * inventory without action
   */
  export type inventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
  }


  /**
   * Model level
   */

  export type AggregateLevel = {
    _count: LevelCountAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  export type LevelMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LevelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LevelCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LevelMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LevelMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LevelCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which level to aggregate.
     */
    where?: levelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of levels to fetch.
     */
    orderBy?: levelOrderByWithRelationInput | levelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: levelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned levels
    **/
    _count?: true | LevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LevelMaxAggregateInputType
  }

  export type GetLevelAggregateType<T extends LevelAggregateArgs> = {
        [P in keyof T & keyof AggregateLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevel[P]>
      : GetScalarType<T[P], AggregateLevel[P]>
  }




  export type levelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: levelWhereInput
    orderBy?: levelOrderByWithAggregationInput | levelOrderByWithAggregationInput[]
    by: LevelScalarFieldEnum[] | LevelScalarFieldEnum
    having?: levelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LevelCountAggregateInputType | true
    _min?: LevelMinAggregateInputType
    _max?: LevelMaxAggregateInputType
  }

  export type LevelGroupByOutputType = {
    id: string
    name: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: LevelCountAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  type GetLevelGroupByPayload<T extends levelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevelGroupByOutputType[P]>
            : GetScalarType<T[P], LevelGroupByOutputType[P]>
        }
      >
    >


  export type levelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | level$warehouseArgs<ExtArgs>
    _count?: boolean | LevelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["level"]>

  export type levelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["level"]>

  export type levelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["level"]>

  export type levelSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type levelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["level"]>
  export type levelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | level$warehouseArgs<ExtArgs>
    _count?: boolean | LevelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type levelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type levelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $levelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "level"
    objects: {
      warehouse: Prisma.$warehousePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["level"]>
    composites: {}
  }

  type levelGetPayload<S extends boolean | null | undefined | levelDefaultArgs> = $Result.GetResult<Prisma.$levelPayload, S>

  type levelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<levelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LevelCountAggregateInputType | true
    }

  export interface levelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['level'], meta: { name: 'level' } }
    /**
     * Find zero or one Level that matches the filter.
     * @param {levelFindUniqueArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends levelFindUniqueArgs>(args: SelectSubset<T, levelFindUniqueArgs<ExtArgs>>): Prisma__levelClient<$Result.GetResult<Prisma.$levelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Level that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {levelFindUniqueOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends levelFindUniqueOrThrowArgs>(args: SelectSubset<T, levelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__levelClient<$Result.GetResult<Prisma.$levelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Level that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelFindFirstArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends levelFindFirstArgs>(args?: SelectSubset<T, levelFindFirstArgs<ExtArgs>>): Prisma__levelClient<$Result.GetResult<Prisma.$levelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Level that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelFindFirstOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends levelFindFirstOrThrowArgs>(args?: SelectSubset<T, levelFindFirstOrThrowArgs<ExtArgs>>): Prisma__levelClient<$Result.GetResult<Prisma.$levelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Levels
     * const levels = await prisma.level.findMany()
     * 
     * // Get first 10 Levels
     * const levels = await prisma.level.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const levelWithIdOnly = await prisma.level.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends levelFindManyArgs>(args?: SelectSubset<T, levelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$levelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Level.
     * @param {levelCreateArgs} args - Arguments to create a Level.
     * @example
     * // Create one Level
     * const Level = await prisma.level.create({
     *   data: {
     *     // ... data to create a Level
     *   }
     * })
     * 
     */
    create<T extends levelCreateArgs>(args: SelectSubset<T, levelCreateArgs<ExtArgs>>): Prisma__levelClient<$Result.GetResult<Prisma.$levelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Levels.
     * @param {levelCreateManyArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const level = await prisma.level.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends levelCreateManyArgs>(args?: SelectSubset<T, levelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Levels and returns the data saved in the database.
     * @param {levelCreateManyAndReturnArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const level = await prisma.level.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Levels and only return the `id`
     * const levelWithIdOnly = await prisma.level.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends levelCreateManyAndReturnArgs>(args?: SelectSubset<T, levelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$levelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Level.
     * @param {levelDeleteArgs} args - Arguments to delete one Level.
     * @example
     * // Delete one Level
     * const Level = await prisma.level.delete({
     *   where: {
     *     // ... filter to delete one Level
     *   }
     * })
     * 
     */
    delete<T extends levelDeleteArgs>(args: SelectSubset<T, levelDeleteArgs<ExtArgs>>): Prisma__levelClient<$Result.GetResult<Prisma.$levelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Level.
     * @param {levelUpdateArgs} args - Arguments to update one Level.
     * @example
     * // Update one Level
     * const level = await prisma.level.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends levelUpdateArgs>(args: SelectSubset<T, levelUpdateArgs<ExtArgs>>): Prisma__levelClient<$Result.GetResult<Prisma.$levelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Levels.
     * @param {levelDeleteManyArgs} args - Arguments to filter Levels to delete.
     * @example
     * // Delete a few Levels
     * const { count } = await prisma.level.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends levelDeleteManyArgs>(args?: SelectSubset<T, levelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Levels
     * const level = await prisma.level.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends levelUpdateManyArgs>(args: SelectSubset<T, levelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels and returns the data updated in the database.
     * @param {levelUpdateManyAndReturnArgs} args - Arguments to update many Levels.
     * @example
     * // Update many Levels
     * const level = await prisma.level.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Levels and only return the `id`
     * const levelWithIdOnly = await prisma.level.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends levelUpdateManyAndReturnArgs>(args: SelectSubset<T, levelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$levelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Level.
     * @param {levelUpsertArgs} args - Arguments to update or create a Level.
     * @example
     * // Update or create a Level
     * const level = await prisma.level.upsert({
     *   create: {
     *     // ... data to create a Level
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Level we want to update
     *   }
     * })
     */
    upsert<T extends levelUpsertArgs>(args: SelectSubset<T, levelUpsertArgs<ExtArgs>>): Prisma__levelClient<$Result.GetResult<Prisma.$levelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelCountArgs} args - Arguments to filter Levels to count.
     * @example
     * // Count the number of Levels
     * const count = await prisma.level.count({
     *   where: {
     *     // ... the filter for the Levels we want to count
     *   }
     * })
    **/
    count<T extends levelCountArgs>(
      args?: Subset<T, levelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LevelAggregateArgs>(args: Subset<T, LevelAggregateArgs>): Prisma.PrismaPromise<GetLevelAggregateType<T>>

    /**
     * Group by Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends levelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: levelGroupByArgs['orderBy'] }
        : { orderBy?: levelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, levelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the level model
   */
  readonly fields: levelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for level.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__levelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    warehouse<T extends level$warehouseArgs<ExtArgs> = {}>(args?: Subset<T, level$warehouseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the level model
   */
  interface levelFieldRefs {
    readonly id: FieldRef<"level", 'String'>
    readonly name: FieldRef<"level", 'String'>
    readonly createdAt: FieldRef<"level", 'DateTime'>
    readonly updatedAt: FieldRef<"level", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * level findUnique
   */
  export type levelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level
     */
    select?: levelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the level
     */
    omit?: levelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelInclude<ExtArgs> | null
    /**
     * Filter, which level to fetch.
     */
    where: levelWhereUniqueInput
  }

  /**
   * level findUniqueOrThrow
   */
  export type levelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level
     */
    select?: levelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the level
     */
    omit?: levelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelInclude<ExtArgs> | null
    /**
     * Filter, which level to fetch.
     */
    where: levelWhereUniqueInput
  }

  /**
   * level findFirst
   */
  export type levelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level
     */
    select?: levelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the level
     */
    omit?: levelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelInclude<ExtArgs> | null
    /**
     * Filter, which level to fetch.
     */
    where?: levelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of levels to fetch.
     */
    orderBy?: levelOrderByWithRelationInput | levelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for levels.
     */
    cursor?: levelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * level findFirstOrThrow
   */
  export type levelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level
     */
    select?: levelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the level
     */
    omit?: levelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelInclude<ExtArgs> | null
    /**
     * Filter, which level to fetch.
     */
    where?: levelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of levels to fetch.
     */
    orderBy?: levelOrderByWithRelationInput | levelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for levels.
     */
    cursor?: levelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * level findMany
   */
  export type levelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level
     */
    select?: levelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the level
     */
    omit?: levelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelInclude<ExtArgs> | null
    /**
     * Filter, which levels to fetch.
     */
    where?: levelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of levels to fetch.
     */
    orderBy?: levelOrderByWithRelationInput | levelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing levels.
     */
    cursor?: levelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` levels.
     */
    skip?: number
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * level create
   */
  export type levelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level
     */
    select?: levelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the level
     */
    omit?: levelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelInclude<ExtArgs> | null
    /**
     * The data needed to create a level.
     */
    data: XOR<levelCreateInput, levelUncheckedCreateInput>
  }

  /**
   * level createMany
   */
  export type levelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many levels.
     */
    data: levelCreateManyInput | levelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * level createManyAndReturn
   */
  export type levelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level
     */
    select?: levelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the level
     */
    omit?: levelOmit<ExtArgs> | null
    /**
     * The data used to create many levels.
     */
    data: levelCreateManyInput | levelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * level update
   */
  export type levelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level
     */
    select?: levelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the level
     */
    omit?: levelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelInclude<ExtArgs> | null
    /**
     * The data needed to update a level.
     */
    data: XOR<levelUpdateInput, levelUncheckedUpdateInput>
    /**
     * Choose, which level to update.
     */
    where: levelWhereUniqueInput
  }

  /**
   * level updateMany
   */
  export type levelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update levels.
     */
    data: XOR<levelUpdateManyMutationInput, levelUncheckedUpdateManyInput>
    /**
     * Filter which levels to update
     */
    where?: levelWhereInput
    /**
     * Limit how many levels to update.
     */
    limit?: number
  }

  /**
   * level updateManyAndReturn
   */
  export type levelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level
     */
    select?: levelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the level
     */
    omit?: levelOmit<ExtArgs> | null
    /**
     * The data used to update levels.
     */
    data: XOR<levelUpdateManyMutationInput, levelUncheckedUpdateManyInput>
    /**
     * Filter which levels to update
     */
    where?: levelWhereInput
    /**
     * Limit how many levels to update.
     */
    limit?: number
  }

  /**
   * level upsert
   */
  export type levelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level
     */
    select?: levelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the level
     */
    omit?: levelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelInclude<ExtArgs> | null
    /**
     * The filter to search for the level to update in case it exists.
     */
    where: levelWhereUniqueInput
    /**
     * In case the level found by the `where` argument doesn't exist, create a new level with this data.
     */
    create: XOR<levelCreateInput, levelUncheckedCreateInput>
    /**
     * In case the level was found with the provided `where` argument, update it with this data.
     */
    update: XOR<levelUpdateInput, levelUncheckedUpdateInput>
  }

  /**
   * level delete
   */
  export type levelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level
     */
    select?: levelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the level
     */
    omit?: levelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelInclude<ExtArgs> | null
    /**
     * Filter which level to delete.
     */
    where: levelWhereUniqueInput
  }

  /**
   * level deleteMany
   */
  export type levelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which levels to delete
     */
    where?: levelWhereInput
    /**
     * Limit how many levels to delete.
     */
    limit?: number
  }

  /**
   * level.warehouse
   */
  export type level$warehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse
     */
    omit?: warehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouseInclude<ExtArgs> | null
    where?: warehouseWhereInput
    orderBy?: warehouseOrderByWithRelationInput | warehouseOrderByWithRelationInput[]
    cursor?: warehouseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * level without action
   */
  export type levelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the level
     */
    select?: levelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the level
     */
    omit?: levelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelInclude<ExtArgs> | null
  }


  /**
   * Model mekanik
   */

  export type AggregateMekanik = {
    _count: MekanikCountAggregateOutputType | null
    _min: MekanikMinAggregateOutputType | null
    _max: MekanikMaxAggregateOutputType | null
  }

  export type MekanikMinAggregateOutputType = {
    id: string | null
    employee_id: string | null
    warehouse_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MekanikMaxAggregateOutputType = {
    id: string | null
    employee_id: string | null
    warehouse_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MekanikCountAggregateOutputType = {
    id: number
    employee_id: number
    warehouse_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MekanikMinAggregateInputType = {
    id?: true
    employee_id?: true
    warehouse_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MekanikMaxAggregateInputType = {
    id?: true
    employee_id?: true
    warehouse_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MekanikCountAggregateInputType = {
    id?: true
    employee_id?: true
    warehouse_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MekanikAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mekanik to aggregate.
     */
    where?: mekanikWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mekaniks to fetch.
     */
    orderBy?: mekanikOrderByWithRelationInput | mekanikOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mekanikWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mekaniks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mekaniks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mekaniks
    **/
    _count?: true | MekanikCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MekanikMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MekanikMaxAggregateInputType
  }

  export type GetMekanikAggregateType<T extends MekanikAggregateArgs> = {
        [P in keyof T & keyof AggregateMekanik]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMekanik[P]>
      : GetScalarType<T[P], AggregateMekanik[P]>
  }




  export type mekanikGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mekanikWhereInput
    orderBy?: mekanikOrderByWithAggregationInput | mekanikOrderByWithAggregationInput[]
    by: MekanikScalarFieldEnum[] | MekanikScalarFieldEnum
    having?: mekanikScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MekanikCountAggregateInputType | true
    _min?: MekanikMinAggregateInputType
    _max?: MekanikMaxAggregateInputType
  }

  export type MekanikGroupByOutputType = {
    id: string
    employee_id: string
    warehouse_id: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: MekanikCountAggregateOutputType | null
    _min: MekanikMinAggregateOutputType | null
    _max: MekanikMaxAggregateOutputType | null
  }

  type GetMekanikGroupByPayload<T extends mekanikGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MekanikGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MekanikGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MekanikGroupByOutputType[P]>
            : GetScalarType<T[P], MekanikGroupByOutputType[P]>
        }
      >
    >


  export type mekanikSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    warehouse_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    warehouse?: boolean | warehouseDefaultArgs<ExtArgs>
    transaksi?: boolean | mekanik$transaksiArgs<ExtArgs>
    _count?: boolean | MekanikCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mekanik"]>

  export type mekanikSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    warehouse_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    warehouse?: boolean | warehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mekanik"]>

  export type mekanikSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    warehouse_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    warehouse?: boolean | warehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mekanik"]>

  export type mekanikSelectScalar = {
    id?: boolean
    employee_id?: boolean
    warehouse_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type mekanikOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employee_id" | "warehouse_id" | "createdAt" | "updatedAt", ExtArgs["result"]["mekanik"]>
  export type mekanikInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    warehouse?: boolean | warehouseDefaultArgs<ExtArgs>
    transaksi?: boolean | mekanik$transaksiArgs<ExtArgs>
    _count?: boolean | MekanikCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type mekanikIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    warehouse?: boolean | warehouseDefaultArgs<ExtArgs>
  }
  export type mekanikIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    warehouse?: boolean | warehouseDefaultArgs<ExtArgs>
  }

  export type $mekanikPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mekanik"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs>
      warehouse: Prisma.$warehousePayload<ExtArgs>
      transaksi: Prisma.$transaksiPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employee_id: string
      warehouse_id: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["mekanik"]>
    composites: {}
  }

  type mekanikGetPayload<S extends boolean | null | undefined | mekanikDefaultArgs> = $Result.GetResult<Prisma.$mekanikPayload, S>

  type mekanikCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mekanikFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MekanikCountAggregateInputType | true
    }

  export interface mekanikDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mekanik'], meta: { name: 'mekanik' } }
    /**
     * Find zero or one Mekanik that matches the filter.
     * @param {mekanikFindUniqueArgs} args - Arguments to find a Mekanik
     * @example
     * // Get one Mekanik
     * const mekanik = await prisma.mekanik.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mekanikFindUniqueArgs>(args: SelectSubset<T, mekanikFindUniqueArgs<ExtArgs>>): Prisma__mekanikClient<$Result.GetResult<Prisma.$mekanikPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mekanik that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mekanikFindUniqueOrThrowArgs} args - Arguments to find a Mekanik
     * @example
     * // Get one Mekanik
     * const mekanik = await prisma.mekanik.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mekanikFindUniqueOrThrowArgs>(args: SelectSubset<T, mekanikFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mekanikClient<$Result.GetResult<Prisma.$mekanikPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mekanik that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mekanikFindFirstArgs} args - Arguments to find a Mekanik
     * @example
     * // Get one Mekanik
     * const mekanik = await prisma.mekanik.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mekanikFindFirstArgs>(args?: SelectSubset<T, mekanikFindFirstArgs<ExtArgs>>): Prisma__mekanikClient<$Result.GetResult<Prisma.$mekanikPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mekanik that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mekanikFindFirstOrThrowArgs} args - Arguments to find a Mekanik
     * @example
     * // Get one Mekanik
     * const mekanik = await prisma.mekanik.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mekanikFindFirstOrThrowArgs>(args?: SelectSubset<T, mekanikFindFirstOrThrowArgs<ExtArgs>>): Prisma__mekanikClient<$Result.GetResult<Prisma.$mekanikPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mekaniks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mekanikFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mekaniks
     * const mekaniks = await prisma.mekanik.findMany()
     * 
     * // Get first 10 Mekaniks
     * const mekaniks = await prisma.mekanik.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mekanikWithIdOnly = await prisma.mekanik.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mekanikFindManyArgs>(args?: SelectSubset<T, mekanikFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mekanikPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mekanik.
     * @param {mekanikCreateArgs} args - Arguments to create a Mekanik.
     * @example
     * // Create one Mekanik
     * const Mekanik = await prisma.mekanik.create({
     *   data: {
     *     // ... data to create a Mekanik
     *   }
     * })
     * 
     */
    create<T extends mekanikCreateArgs>(args: SelectSubset<T, mekanikCreateArgs<ExtArgs>>): Prisma__mekanikClient<$Result.GetResult<Prisma.$mekanikPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mekaniks.
     * @param {mekanikCreateManyArgs} args - Arguments to create many Mekaniks.
     * @example
     * // Create many Mekaniks
     * const mekanik = await prisma.mekanik.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mekanikCreateManyArgs>(args?: SelectSubset<T, mekanikCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mekaniks and returns the data saved in the database.
     * @param {mekanikCreateManyAndReturnArgs} args - Arguments to create many Mekaniks.
     * @example
     * // Create many Mekaniks
     * const mekanik = await prisma.mekanik.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mekaniks and only return the `id`
     * const mekanikWithIdOnly = await prisma.mekanik.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mekanikCreateManyAndReturnArgs>(args?: SelectSubset<T, mekanikCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mekanikPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mekanik.
     * @param {mekanikDeleteArgs} args - Arguments to delete one Mekanik.
     * @example
     * // Delete one Mekanik
     * const Mekanik = await prisma.mekanik.delete({
     *   where: {
     *     // ... filter to delete one Mekanik
     *   }
     * })
     * 
     */
    delete<T extends mekanikDeleteArgs>(args: SelectSubset<T, mekanikDeleteArgs<ExtArgs>>): Prisma__mekanikClient<$Result.GetResult<Prisma.$mekanikPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mekanik.
     * @param {mekanikUpdateArgs} args - Arguments to update one Mekanik.
     * @example
     * // Update one Mekanik
     * const mekanik = await prisma.mekanik.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mekanikUpdateArgs>(args: SelectSubset<T, mekanikUpdateArgs<ExtArgs>>): Prisma__mekanikClient<$Result.GetResult<Prisma.$mekanikPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mekaniks.
     * @param {mekanikDeleteManyArgs} args - Arguments to filter Mekaniks to delete.
     * @example
     * // Delete a few Mekaniks
     * const { count } = await prisma.mekanik.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mekanikDeleteManyArgs>(args?: SelectSubset<T, mekanikDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mekaniks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mekanikUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mekaniks
     * const mekanik = await prisma.mekanik.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mekanikUpdateManyArgs>(args: SelectSubset<T, mekanikUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mekaniks and returns the data updated in the database.
     * @param {mekanikUpdateManyAndReturnArgs} args - Arguments to update many Mekaniks.
     * @example
     * // Update many Mekaniks
     * const mekanik = await prisma.mekanik.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mekaniks and only return the `id`
     * const mekanikWithIdOnly = await prisma.mekanik.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends mekanikUpdateManyAndReturnArgs>(args: SelectSubset<T, mekanikUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mekanikPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mekanik.
     * @param {mekanikUpsertArgs} args - Arguments to update or create a Mekanik.
     * @example
     * // Update or create a Mekanik
     * const mekanik = await prisma.mekanik.upsert({
     *   create: {
     *     // ... data to create a Mekanik
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mekanik we want to update
     *   }
     * })
     */
    upsert<T extends mekanikUpsertArgs>(args: SelectSubset<T, mekanikUpsertArgs<ExtArgs>>): Prisma__mekanikClient<$Result.GetResult<Prisma.$mekanikPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mekaniks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mekanikCountArgs} args - Arguments to filter Mekaniks to count.
     * @example
     * // Count the number of Mekaniks
     * const count = await prisma.mekanik.count({
     *   where: {
     *     // ... the filter for the Mekaniks we want to count
     *   }
     * })
    **/
    count<T extends mekanikCountArgs>(
      args?: Subset<T, mekanikCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MekanikCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mekanik.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MekanikAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MekanikAggregateArgs>(args: Subset<T, MekanikAggregateArgs>): Prisma.PrismaPromise<GetMekanikAggregateType<T>>

    /**
     * Group by Mekanik.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mekanikGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mekanikGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mekanikGroupByArgs['orderBy'] }
        : { orderBy?: mekanikGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mekanikGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMekanikGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mekanik model
   */
  readonly fields: mekanikFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mekanik.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mekanikClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends warehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, warehouseDefaultArgs<ExtArgs>>): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaksi<T extends mekanik$transaksiArgs<ExtArgs> = {}>(args?: Subset<T, mekanik$transaksiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mekanik model
   */
  interface mekanikFieldRefs {
    readonly id: FieldRef<"mekanik", 'String'>
    readonly employee_id: FieldRef<"mekanik", 'String'>
    readonly warehouse_id: FieldRef<"mekanik", 'String'>
    readonly createdAt: FieldRef<"mekanik", 'DateTime'>
    readonly updatedAt: FieldRef<"mekanik", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * mekanik findUnique
   */
  export type mekanikFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mekanik
     */
    select?: mekanikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mekanik
     */
    omit?: mekanikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mekanikInclude<ExtArgs> | null
    /**
     * Filter, which mekanik to fetch.
     */
    where: mekanikWhereUniqueInput
  }

  /**
   * mekanik findUniqueOrThrow
   */
  export type mekanikFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mekanik
     */
    select?: mekanikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mekanik
     */
    omit?: mekanikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mekanikInclude<ExtArgs> | null
    /**
     * Filter, which mekanik to fetch.
     */
    where: mekanikWhereUniqueInput
  }

  /**
   * mekanik findFirst
   */
  export type mekanikFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mekanik
     */
    select?: mekanikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mekanik
     */
    omit?: mekanikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mekanikInclude<ExtArgs> | null
    /**
     * Filter, which mekanik to fetch.
     */
    where?: mekanikWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mekaniks to fetch.
     */
    orderBy?: mekanikOrderByWithRelationInput | mekanikOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mekaniks.
     */
    cursor?: mekanikWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mekaniks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mekaniks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mekaniks.
     */
    distinct?: MekanikScalarFieldEnum | MekanikScalarFieldEnum[]
  }

  /**
   * mekanik findFirstOrThrow
   */
  export type mekanikFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mekanik
     */
    select?: mekanikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mekanik
     */
    omit?: mekanikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mekanikInclude<ExtArgs> | null
    /**
     * Filter, which mekanik to fetch.
     */
    where?: mekanikWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mekaniks to fetch.
     */
    orderBy?: mekanikOrderByWithRelationInput | mekanikOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mekaniks.
     */
    cursor?: mekanikWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mekaniks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mekaniks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mekaniks.
     */
    distinct?: MekanikScalarFieldEnum | MekanikScalarFieldEnum[]
  }

  /**
   * mekanik findMany
   */
  export type mekanikFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mekanik
     */
    select?: mekanikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mekanik
     */
    omit?: mekanikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mekanikInclude<ExtArgs> | null
    /**
     * Filter, which mekaniks to fetch.
     */
    where?: mekanikWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mekaniks to fetch.
     */
    orderBy?: mekanikOrderByWithRelationInput | mekanikOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mekaniks.
     */
    cursor?: mekanikWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mekaniks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mekaniks.
     */
    skip?: number
    distinct?: MekanikScalarFieldEnum | MekanikScalarFieldEnum[]
  }

  /**
   * mekanik create
   */
  export type mekanikCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mekanik
     */
    select?: mekanikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mekanik
     */
    omit?: mekanikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mekanikInclude<ExtArgs> | null
    /**
     * The data needed to create a mekanik.
     */
    data: XOR<mekanikCreateInput, mekanikUncheckedCreateInput>
  }

  /**
   * mekanik createMany
   */
  export type mekanikCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mekaniks.
     */
    data: mekanikCreateManyInput | mekanikCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mekanik createManyAndReturn
   */
  export type mekanikCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mekanik
     */
    select?: mekanikSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mekanik
     */
    omit?: mekanikOmit<ExtArgs> | null
    /**
     * The data used to create many mekaniks.
     */
    data: mekanikCreateManyInput | mekanikCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mekanikIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * mekanik update
   */
  export type mekanikUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mekanik
     */
    select?: mekanikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mekanik
     */
    omit?: mekanikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mekanikInclude<ExtArgs> | null
    /**
     * The data needed to update a mekanik.
     */
    data: XOR<mekanikUpdateInput, mekanikUncheckedUpdateInput>
    /**
     * Choose, which mekanik to update.
     */
    where: mekanikWhereUniqueInput
  }

  /**
   * mekanik updateMany
   */
  export type mekanikUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mekaniks.
     */
    data: XOR<mekanikUpdateManyMutationInput, mekanikUncheckedUpdateManyInput>
    /**
     * Filter which mekaniks to update
     */
    where?: mekanikWhereInput
    /**
     * Limit how many mekaniks to update.
     */
    limit?: number
  }

  /**
   * mekanik updateManyAndReturn
   */
  export type mekanikUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mekanik
     */
    select?: mekanikSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mekanik
     */
    omit?: mekanikOmit<ExtArgs> | null
    /**
     * The data used to update mekaniks.
     */
    data: XOR<mekanikUpdateManyMutationInput, mekanikUncheckedUpdateManyInput>
    /**
     * Filter which mekaniks to update
     */
    where?: mekanikWhereInput
    /**
     * Limit how many mekaniks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mekanikIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * mekanik upsert
   */
  export type mekanikUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mekanik
     */
    select?: mekanikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mekanik
     */
    omit?: mekanikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mekanikInclude<ExtArgs> | null
    /**
     * The filter to search for the mekanik to update in case it exists.
     */
    where: mekanikWhereUniqueInput
    /**
     * In case the mekanik found by the `where` argument doesn't exist, create a new mekanik with this data.
     */
    create: XOR<mekanikCreateInput, mekanikUncheckedCreateInput>
    /**
     * In case the mekanik was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mekanikUpdateInput, mekanikUncheckedUpdateInput>
  }

  /**
   * mekanik delete
   */
  export type mekanikDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mekanik
     */
    select?: mekanikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mekanik
     */
    omit?: mekanikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mekanikInclude<ExtArgs> | null
    /**
     * Filter which mekanik to delete.
     */
    where: mekanikWhereUniqueInput
  }

  /**
   * mekanik deleteMany
   */
  export type mekanikDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mekaniks to delete
     */
    where?: mekanikWhereInput
    /**
     * Limit how many mekaniks to delete.
     */
    limit?: number
  }

  /**
   * mekanik.transaksi
   */
  export type mekanik$transaksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi
     */
    omit?: transaksiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    where?: transaksiWhereInput
    orderBy?: transaksiOrderByWithRelationInput | transaksiOrderByWithRelationInput[]
    cursor?: transaksiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransaksiScalarFieldEnum | TransaksiScalarFieldEnum[]
  }

  /**
   * mekanik without action
   */
  export type mekanikDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mekanik
     */
    select?: mekanikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mekanik
     */
    omit?: mekanikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mekanikInclude<ExtArgs> | null
  }


  /**
   * Model member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which member to aggregate.
     */
    where?: memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of members to fetch.
     */
    orderBy?: memberOrderByWithRelationInput | memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type memberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: memberWhereInput
    orderBy?: memberOrderByWithAggregationInput | memberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: memberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    id: string
    name: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends memberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type memberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | member$usersArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type memberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["member"]>

  export type memberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["member"]>

  export type memberSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type memberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["member"]>
  export type memberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | member$usersArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type memberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type memberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $memberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "member"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type memberGetPayload<S extends boolean | null | undefined | memberDefaultArgs> = $Result.GetResult<Prisma.$memberPayload, S>

  type memberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<memberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface memberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['member'], meta: { name: 'member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {memberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends memberFindUniqueArgs>(args: SelectSubset<T, memberFindUniqueArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {memberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends memberFindUniqueOrThrowArgs>(args: SelectSubset<T, memberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends memberFindFirstArgs>(args?: SelectSubset<T, memberFindFirstArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends memberFindFirstOrThrowArgs>(args?: SelectSubset<T, memberFindFirstOrThrowArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends memberFindManyArgs>(args?: SelectSubset<T, memberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Member.
     * @param {memberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends memberCreateArgs>(args: SelectSubset<T, memberCreateArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Members.
     * @param {memberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends memberCreateManyArgs>(args?: SelectSubset<T, memberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Members and returns the data saved in the database.
     * @param {memberCreateManyAndReturnArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends memberCreateManyAndReturnArgs>(args?: SelectSubset<T, memberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Member.
     * @param {memberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends memberDeleteArgs>(args: SelectSubset<T, memberDeleteArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Member.
     * @param {memberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends memberUpdateArgs>(args: SelectSubset<T, memberUpdateArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Members.
     * @param {memberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends memberDeleteManyArgs>(args?: SelectSubset<T, memberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends memberUpdateManyArgs>(args: SelectSubset<T, memberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members and returns the data updated in the database.
     * @param {memberUpdateManyAndReturnArgs} args - Arguments to update many Members.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends memberUpdateManyAndReturnArgs>(args: SelectSubset<T, memberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Member.
     * @param {memberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends memberUpsertArgs>(args: SelectSubset<T, memberUpsertArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends memberCountArgs>(
      args?: Subset<T, memberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends memberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: memberGroupByArgs['orderBy'] }
        : { orderBy?: memberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, memberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the member model
   */
  readonly fields: memberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__memberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends member$usersArgs<ExtArgs> = {}>(args?: Subset<T, member$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the member model
   */
  interface memberFieldRefs {
    readonly id: FieldRef<"member", 'String'>
    readonly name: FieldRef<"member", 'String'>
    readonly createdAt: FieldRef<"member", 'DateTime'>
    readonly updatedAt: FieldRef<"member", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * member findUnique
   */
  export type memberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: memberInclude<ExtArgs> | null
    /**
     * Filter, which member to fetch.
     */
    where: memberWhereUniqueInput
  }

  /**
   * member findUniqueOrThrow
   */
  export type memberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: memberInclude<ExtArgs> | null
    /**
     * Filter, which member to fetch.
     */
    where: memberWhereUniqueInput
  }

  /**
   * member findFirst
   */
  export type memberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: memberInclude<ExtArgs> | null
    /**
     * Filter, which member to fetch.
     */
    where?: memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of members to fetch.
     */
    orderBy?: memberOrderByWithRelationInput | memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for members.
     */
    cursor?: memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * member findFirstOrThrow
   */
  export type memberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: memberInclude<ExtArgs> | null
    /**
     * Filter, which member to fetch.
     */
    where?: memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of members to fetch.
     */
    orderBy?: memberOrderByWithRelationInput | memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for members.
     */
    cursor?: memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * member findMany
   */
  export type memberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: memberInclude<ExtArgs> | null
    /**
     * Filter, which members to fetch.
     */
    where?: memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of members to fetch.
     */
    orderBy?: memberOrderByWithRelationInput | memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing members.
     */
    cursor?: memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * member create
   */
  export type memberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: memberInclude<ExtArgs> | null
    /**
     * The data needed to create a member.
     */
    data: XOR<memberCreateInput, memberUncheckedCreateInput>
  }

  /**
   * member createMany
   */
  export type memberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many members.
     */
    data: memberCreateManyInput | memberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * member createManyAndReturn
   */
  export type memberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * The data used to create many members.
     */
    data: memberCreateManyInput | memberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * member update
   */
  export type memberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: memberInclude<ExtArgs> | null
    /**
     * The data needed to update a member.
     */
    data: XOR<memberUpdateInput, memberUncheckedUpdateInput>
    /**
     * Choose, which member to update.
     */
    where: memberWhereUniqueInput
  }

  /**
   * member updateMany
   */
  export type memberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update members.
     */
    data: XOR<memberUpdateManyMutationInput, memberUncheckedUpdateManyInput>
    /**
     * Filter which members to update
     */
    where?: memberWhereInput
    /**
     * Limit how many members to update.
     */
    limit?: number
  }

  /**
   * member updateManyAndReturn
   */
  export type memberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * The data used to update members.
     */
    data: XOR<memberUpdateManyMutationInput, memberUncheckedUpdateManyInput>
    /**
     * Filter which members to update
     */
    where?: memberWhereInput
    /**
     * Limit how many members to update.
     */
    limit?: number
  }

  /**
   * member upsert
   */
  export type memberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: memberInclude<ExtArgs> | null
    /**
     * The filter to search for the member to update in case it exists.
     */
    where: memberWhereUniqueInput
    /**
     * In case the member found by the `where` argument doesn't exist, create a new member with this data.
     */
    create: XOR<memberCreateInput, memberUncheckedCreateInput>
    /**
     * In case the member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<memberUpdateInput, memberUncheckedUpdateInput>
  }

  /**
   * member delete
   */
  export type memberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: memberInclude<ExtArgs> | null
    /**
     * Filter which member to delete.
     */
    where: memberWhereUniqueInput
  }

  /**
   * member deleteMany
   */
  export type memberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which members to delete
     */
    where?: memberWhereInput
    /**
     * Limit how many members to delete.
     */
    limit?: number
  }

  /**
   * member.users
   */
  export type member$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * member without action
   */
  export type memberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: memberInclude<ExtArgs> | null
  }


  /**
   * Model order_barang
   */

  export type AggregateOrder_barang = {
    _count: Order_barangCountAggregateOutputType | null
    _min: Order_barangMinAggregateOutputType | null
    _max: Order_barangMaxAggregateOutputType | null
  }

  export type Order_barangMinAggregateOutputType = {
    id: string | null
    from_warehouse_id: string | null
    to_warehouse_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Order_barangMaxAggregateOutputType = {
    id: string | null
    from_warehouse_id: string | null
    to_warehouse_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Order_barangCountAggregateOutputType = {
    id: number
    from_warehouse_id: number
    to_warehouse_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Order_barangMinAggregateInputType = {
    id?: true
    from_warehouse_id?: true
    to_warehouse_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Order_barangMaxAggregateInputType = {
    id?: true
    from_warehouse_id?: true
    to_warehouse_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Order_barangCountAggregateInputType = {
    id?: true
    from_warehouse_id?: true
    to_warehouse_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Order_barangAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_barang to aggregate.
     */
    where?: order_barangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_barangs to fetch.
     */
    orderBy?: order_barangOrderByWithRelationInput | order_barangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: order_barangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_barangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_barangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned order_barangs
    **/
    _count?: true | Order_barangCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Order_barangMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Order_barangMaxAggregateInputType
  }

  export type GetOrder_barangAggregateType<T extends Order_barangAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder_barang]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder_barang[P]>
      : GetScalarType<T[P], AggregateOrder_barang[P]>
  }




  export type order_barangGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_barangWhereInput
    orderBy?: order_barangOrderByWithAggregationInput | order_barangOrderByWithAggregationInput[]
    by: Order_barangScalarFieldEnum[] | Order_barangScalarFieldEnum
    having?: order_barangScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Order_barangCountAggregateInputType | true
    _min?: Order_barangMinAggregateInputType
    _max?: Order_barangMaxAggregateInputType
  }

  export type Order_barangGroupByOutputType = {
    id: string
    from_warehouse_id: string
    to_warehouse_id: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: Order_barangCountAggregateOutputType | null
    _min: Order_barangMinAggregateOutputType | null
    _max: Order_barangMaxAggregateOutputType | null
  }

  type GetOrder_barangGroupByPayload<T extends order_barangGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Order_barangGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Order_barangGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Order_barangGroupByOutputType[P]>
            : GetScalarType<T[P], Order_barangGroupByOutputType[P]>
        }
      >
    >


  export type order_barangSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    from_warehouse_id?: boolean
    to_warehouse_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse_order_barang_from_warehouse_idTowarehouse?: boolean | warehouseDefaultArgs<ExtArgs>
    warehouse_order_barang_to_warehouse_idTowarehouse?: boolean | warehouseDefaultArgs<ExtArgs>
    order_barang_detail?: boolean | order_barang$order_barang_detailArgs<ExtArgs>
    _count?: boolean | Order_barangCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_barang"]>

  export type order_barangSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    from_warehouse_id?: boolean
    to_warehouse_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse_order_barang_from_warehouse_idTowarehouse?: boolean | warehouseDefaultArgs<ExtArgs>
    warehouse_order_barang_to_warehouse_idTowarehouse?: boolean | warehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_barang"]>

  export type order_barangSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    from_warehouse_id?: boolean
    to_warehouse_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse_order_barang_from_warehouse_idTowarehouse?: boolean | warehouseDefaultArgs<ExtArgs>
    warehouse_order_barang_to_warehouse_idTowarehouse?: boolean | warehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_barang"]>

  export type order_barangSelectScalar = {
    id?: boolean
    from_warehouse_id?: boolean
    to_warehouse_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type order_barangOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "from_warehouse_id" | "to_warehouse_id" | "createdAt" | "updatedAt", ExtArgs["result"]["order_barang"]>
  export type order_barangInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse_order_barang_from_warehouse_idTowarehouse?: boolean | warehouseDefaultArgs<ExtArgs>
    warehouse_order_barang_to_warehouse_idTowarehouse?: boolean | warehouseDefaultArgs<ExtArgs>
    order_barang_detail?: boolean | order_barang$order_barang_detailArgs<ExtArgs>
    _count?: boolean | Order_barangCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type order_barangIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse_order_barang_from_warehouse_idTowarehouse?: boolean | warehouseDefaultArgs<ExtArgs>
    warehouse_order_barang_to_warehouse_idTowarehouse?: boolean | warehouseDefaultArgs<ExtArgs>
  }
  export type order_barangIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse_order_barang_from_warehouse_idTowarehouse?: boolean | warehouseDefaultArgs<ExtArgs>
    warehouse_order_barang_to_warehouse_idTowarehouse?: boolean | warehouseDefaultArgs<ExtArgs>
  }

  export type $order_barangPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "order_barang"
    objects: {
      warehouse_order_barang_from_warehouse_idTowarehouse: Prisma.$warehousePayload<ExtArgs>
      warehouse_order_barang_to_warehouse_idTowarehouse: Prisma.$warehousePayload<ExtArgs>
      order_barang_detail: Prisma.$order_barang_detailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      from_warehouse_id: string
      to_warehouse_id: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["order_barang"]>
    composites: {}
  }

  type order_barangGetPayload<S extends boolean | null | undefined | order_barangDefaultArgs> = $Result.GetResult<Prisma.$order_barangPayload, S>

  type order_barangCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<order_barangFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Order_barangCountAggregateInputType | true
    }

  export interface order_barangDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['order_barang'], meta: { name: 'order_barang' } }
    /**
     * Find zero or one Order_barang that matches the filter.
     * @param {order_barangFindUniqueArgs} args - Arguments to find a Order_barang
     * @example
     * // Get one Order_barang
     * const order_barang = await prisma.order_barang.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends order_barangFindUniqueArgs>(args: SelectSubset<T, order_barangFindUniqueArgs<ExtArgs>>): Prisma__order_barangClient<$Result.GetResult<Prisma.$order_barangPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order_barang that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {order_barangFindUniqueOrThrowArgs} args - Arguments to find a Order_barang
     * @example
     * // Get one Order_barang
     * const order_barang = await prisma.order_barang.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends order_barangFindUniqueOrThrowArgs>(args: SelectSubset<T, order_barangFindUniqueOrThrowArgs<ExtArgs>>): Prisma__order_barangClient<$Result.GetResult<Prisma.$order_barangPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order_barang that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_barangFindFirstArgs} args - Arguments to find a Order_barang
     * @example
     * // Get one Order_barang
     * const order_barang = await prisma.order_barang.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends order_barangFindFirstArgs>(args?: SelectSubset<T, order_barangFindFirstArgs<ExtArgs>>): Prisma__order_barangClient<$Result.GetResult<Prisma.$order_barangPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order_barang that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_barangFindFirstOrThrowArgs} args - Arguments to find a Order_barang
     * @example
     * // Get one Order_barang
     * const order_barang = await prisma.order_barang.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends order_barangFindFirstOrThrowArgs>(args?: SelectSubset<T, order_barangFindFirstOrThrowArgs<ExtArgs>>): Prisma__order_barangClient<$Result.GetResult<Prisma.$order_barangPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Order_barangs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_barangFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Order_barangs
     * const order_barangs = await prisma.order_barang.findMany()
     * 
     * // Get first 10 Order_barangs
     * const order_barangs = await prisma.order_barang.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const order_barangWithIdOnly = await prisma.order_barang.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends order_barangFindManyArgs>(args?: SelectSubset<T, order_barangFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_barangPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order_barang.
     * @param {order_barangCreateArgs} args - Arguments to create a Order_barang.
     * @example
     * // Create one Order_barang
     * const Order_barang = await prisma.order_barang.create({
     *   data: {
     *     // ... data to create a Order_barang
     *   }
     * })
     * 
     */
    create<T extends order_barangCreateArgs>(args: SelectSubset<T, order_barangCreateArgs<ExtArgs>>): Prisma__order_barangClient<$Result.GetResult<Prisma.$order_barangPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Order_barangs.
     * @param {order_barangCreateManyArgs} args - Arguments to create many Order_barangs.
     * @example
     * // Create many Order_barangs
     * const order_barang = await prisma.order_barang.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends order_barangCreateManyArgs>(args?: SelectSubset<T, order_barangCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Order_barangs and returns the data saved in the database.
     * @param {order_barangCreateManyAndReturnArgs} args - Arguments to create many Order_barangs.
     * @example
     * // Create many Order_barangs
     * const order_barang = await prisma.order_barang.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Order_barangs and only return the `id`
     * const order_barangWithIdOnly = await prisma.order_barang.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends order_barangCreateManyAndReturnArgs>(args?: SelectSubset<T, order_barangCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_barangPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order_barang.
     * @param {order_barangDeleteArgs} args - Arguments to delete one Order_barang.
     * @example
     * // Delete one Order_barang
     * const Order_barang = await prisma.order_barang.delete({
     *   where: {
     *     // ... filter to delete one Order_barang
     *   }
     * })
     * 
     */
    delete<T extends order_barangDeleteArgs>(args: SelectSubset<T, order_barangDeleteArgs<ExtArgs>>): Prisma__order_barangClient<$Result.GetResult<Prisma.$order_barangPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order_barang.
     * @param {order_barangUpdateArgs} args - Arguments to update one Order_barang.
     * @example
     * // Update one Order_barang
     * const order_barang = await prisma.order_barang.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends order_barangUpdateArgs>(args: SelectSubset<T, order_barangUpdateArgs<ExtArgs>>): Prisma__order_barangClient<$Result.GetResult<Prisma.$order_barangPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Order_barangs.
     * @param {order_barangDeleteManyArgs} args - Arguments to filter Order_barangs to delete.
     * @example
     * // Delete a few Order_barangs
     * const { count } = await prisma.order_barang.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends order_barangDeleteManyArgs>(args?: SelectSubset<T, order_barangDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_barangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_barangUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Order_barangs
     * const order_barang = await prisma.order_barang.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends order_barangUpdateManyArgs>(args: SelectSubset<T, order_barangUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_barangs and returns the data updated in the database.
     * @param {order_barangUpdateManyAndReturnArgs} args - Arguments to update many Order_barangs.
     * @example
     * // Update many Order_barangs
     * const order_barang = await prisma.order_barang.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Order_barangs and only return the `id`
     * const order_barangWithIdOnly = await prisma.order_barang.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends order_barangUpdateManyAndReturnArgs>(args: SelectSubset<T, order_barangUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_barangPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order_barang.
     * @param {order_barangUpsertArgs} args - Arguments to update or create a Order_barang.
     * @example
     * // Update or create a Order_barang
     * const order_barang = await prisma.order_barang.upsert({
     *   create: {
     *     // ... data to create a Order_barang
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order_barang we want to update
     *   }
     * })
     */
    upsert<T extends order_barangUpsertArgs>(args: SelectSubset<T, order_barangUpsertArgs<ExtArgs>>): Prisma__order_barangClient<$Result.GetResult<Prisma.$order_barangPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Order_barangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_barangCountArgs} args - Arguments to filter Order_barangs to count.
     * @example
     * // Count the number of Order_barangs
     * const count = await prisma.order_barang.count({
     *   where: {
     *     // ... the filter for the Order_barangs we want to count
     *   }
     * })
    **/
    count<T extends order_barangCountArgs>(
      args?: Subset<T, order_barangCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Order_barangCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order_barang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Order_barangAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Order_barangAggregateArgs>(args: Subset<T, Order_barangAggregateArgs>): Prisma.PrismaPromise<GetOrder_barangAggregateType<T>>

    /**
     * Group by Order_barang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_barangGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends order_barangGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: order_barangGroupByArgs['orderBy'] }
        : { orderBy?: order_barangGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, order_barangGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrder_barangGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the order_barang model
   */
  readonly fields: order_barangFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for order_barang.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__order_barangClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    warehouse_order_barang_from_warehouse_idTowarehouse<T extends warehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, warehouseDefaultArgs<ExtArgs>>): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    warehouse_order_barang_to_warehouse_idTowarehouse<T extends warehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, warehouseDefaultArgs<ExtArgs>>): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order_barang_detail<T extends order_barang$order_barang_detailArgs<ExtArgs> = {}>(args?: Subset<T, order_barang$order_barang_detailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_barang_detailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the order_barang model
   */
  interface order_barangFieldRefs {
    readonly id: FieldRef<"order_barang", 'String'>
    readonly from_warehouse_id: FieldRef<"order_barang", 'String'>
    readonly to_warehouse_id: FieldRef<"order_barang", 'String'>
    readonly createdAt: FieldRef<"order_barang", 'DateTime'>
    readonly updatedAt: FieldRef<"order_barang", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * order_barang findUnique
   */
  export type order_barangFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang
     */
    select?: order_barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang
     */
    omit?: order_barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barangInclude<ExtArgs> | null
    /**
     * Filter, which order_barang to fetch.
     */
    where: order_barangWhereUniqueInput
  }

  /**
   * order_barang findUniqueOrThrow
   */
  export type order_barangFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang
     */
    select?: order_barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang
     */
    omit?: order_barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barangInclude<ExtArgs> | null
    /**
     * Filter, which order_barang to fetch.
     */
    where: order_barangWhereUniqueInput
  }

  /**
   * order_barang findFirst
   */
  export type order_barangFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang
     */
    select?: order_barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang
     */
    omit?: order_barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barangInclude<ExtArgs> | null
    /**
     * Filter, which order_barang to fetch.
     */
    where?: order_barangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_barangs to fetch.
     */
    orderBy?: order_barangOrderByWithRelationInput | order_barangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_barangs.
     */
    cursor?: order_barangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_barangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_barangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_barangs.
     */
    distinct?: Order_barangScalarFieldEnum | Order_barangScalarFieldEnum[]
  }

  /**
   * order_barang findFirstOrThrow
   */
  export type order_barangFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang
     */
    select?: order_barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang
     */
    omit?: order_barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barangInclude<ExtArgs> | null
    /**
     * Filter, which order_barang to fetch.
     */
    where?: order_barangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_barangs to fetch.
     */
    orderBy?: order_barangOrderByWithRelationInput | order_barangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_barangs.
     */
    cursor?: order_barangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_barangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_barangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_barangs.
     */
    distinct?: Order_barangScalarFieldEnum | Order_barangScalarFieldEnum[]
  }

  /**
   * order_barang findMany
   */
  export type order_barangFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang
     */
    select?: order_barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang
     */
    omit?: order_barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barangInclude<ExtArgs> | null
    /**
     * Filter, which order_barangs to fetch.
     */
    where?: order_barangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_barangs to fetch.
     */
    orderBy?: order_barangOrderByWithRelationInput | order_barangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing order_barangs.
     */
    cursor?: order_barangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_barangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_barangs.
     */
    skip?: number
    distinct?: Order_barangScalarFieldEnum | Order_barangScalarFieldEnum[]
  }

  /**
   * order_barang create
   */
  export type order_barangCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang
     */
    select?: order_barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang
     */
    omit?: order_barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barangInclude<ExtArgs> | null
    /**
     * The data needed to create a order_barang.
     */
    data: XOR<order_barangCreateInput, order_barangUncheckedCreateInput>
  }

  /**
   * order_barang createMany
   */
  export type order_barangCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many order_barangs.
     */
    data: order_barangCreateManyInput | order_barangCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * order_barang createManyAndReturn
   */
  export type order_barangCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang
     */
    select?: order_barangSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang
     */
    omit?: order_barangOmit<ExtArgs> | null
    /**
     * The data used to create many order_barangs.
     */
    data: order_barangCreateManyInput | order_barangCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barangIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * order_barang update
   */
  export type order_barangUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang
     */
    select?: order_barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang
     */
    omit?: order_barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barangInclude<ExtArgs> | null
    /**
     * The data needed to update a order_barang.
     */
    data: XOR<order_barangUpdateInput, order_barangUncheckedUpdateInput>
    /**
     * Choose, which order_barang to update.
     */
    where: order_barangWhereUniqueInput
  }

  /**
   * order_barang updateMany
   */
  export type order_barangUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update order_barangs.
     */
    data: XOR<order_barangUpdateManyMutationInput, order_barangUncheckedUpdateManyInput>
    /**
     * Filter which order_barangs to update
     */
    where?: order_barangWhereInput
    /**
     * Limit how many order_barangs to update.
     */
    limit?: number
  }

  /**
   * order_barang updateManyAndReturn
   */
  export type order_barangUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang
     */
    select?: order_barangSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang
     */
    omit?: order_barangOmit<ExtArgs> | null
    /**
     * The data used to update order_barangs.
     */
    data: XOR<order_barangUpdateManyMutationInput, order_barangUncheckedUpdateManyInput>
    /**
     * Filter which order_barangs to update
     */
    where?: order_barangWhereInput
    /**
     * Limit how many order_barangs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barangIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * order_barang upsert
   */
  export type order_barangUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang
     */
    select?: order_barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang
     */
    omit?: order_barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barangInclude<ExtArgs> | null
    /**
     * The filter to search for the order_barang to update in case it exists.
     */
    where: order_barangWhereUniqueInput
    /**
     * In case the order_barang found by the `where` argument doesn't exist, create a new order_barang with this data.
     */
    create: XOR<order_barangCreateInput, order_barangUncheckedCreateInput>
    /**
     * In case the order_barang was found with the provided `where` argument, update it with this data.
     */
    update: XOR<order_barangUpdateInput, order_barangUncheckedUpdateInput>
  }

  /**
   * order_barang delete
   */
  export type order_barangDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang
     */
    select?: order_barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang
     */
    omit?: order_barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barangInclude<ExtArgs> | null
    /**
     * Filter which order_barang to delete.
     */
    where: order_barangWhereUniqueInput
  }

  /**
   * order_barang deleteMany
   */
  export type order_barangDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_barangs to delete
     */
    where?: order_barangWhereInput
    /**
     * Limit how many order_barangs to delete.
     */
    limit?: number
  }

  /**
   * order_barang.order_barang_detail
   */
  export type order_barang$order_barang_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang_detail
     */
    select?: order_barang_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang_detail
     */
    omit?: order_barang_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barang_detailInclude<ExtArgs> | null
    where?: order_barang_detailWhereInput
    orderBy?: order_barang_detailOrderByWithRelationInput | order_barang_detailOrderByWithRelationInput[]
    cursor?: order_barang_detailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_barang_detailScalarFieldEnum | Order_barang_detailScalarFieldEnum[]
  }

  /**
   * order_barang without action
   */
  export type order_barangDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang
     */
    select?: order_barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang
     */
    omit?: order_barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barangInclude<ExtArgs> | null
  }


  /**
   * Model order_barang_detail
   */

  export type AggregateOrder_barang_detail = {
    _count: Order_barang_detailCountAggregateOutputType | null
    _avg: Order_barang_detailAvgAggregateOutputType | null
    _sum: Order_barang_detailSumAggregateOutputType | null
    _min: Order_barang_detailMinAggregateOutputType | null
    _max: Order_barang_detailMaxAggregateOutputType | null
  }

  export type Order_barang_detailAvgAggregateOutputType = {
    qty: number | null
  }

  export type Order_barang_detailSumAggregateOutputType = {
    qty: number | null
  }

  export type Order_barang_detailMinAggregateOutputType = {
    id: string | null
    order_barang_id: string | null
    barang_id: string | null
    qty: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Order_barang_detailMaxAggregateOutputType = {
    id: string | null
    order_barang_id: string | null
    barang_id: string | null
    qty: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Order_barang_detailCountAggregateOutputType = {
    id: number
    order_barang_id: number
    barang_id: number
    qty: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Order_barang_detailAvgAggregateInputType = {
    qty?: true
  }

  export type Order_barang_detailSumAggregateInputType = {
    qty?: true
  }

  export type Order_barang_detailMinAggregateInputType = {
    id?: true
    order_barang_id?: true
    barang_id?: true
    qty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Order_barang_detailMaxAggregateInputType = {
    id?: true
    order_barang_id?: true
    barang_id?: true
    qty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Order_barang_detailCountAggregateInputType = {
    id?: true
    order_barang_id?: true
    barang_id?: true
    qty?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Order_barang_detailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_barang_detail to aggregate.
     */
    where?: order_barang_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_barang_details to fetch.
     */
    orderBy?: order_barang_detailOrderByWithRelationInput | order_barang_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: order_barang_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_barang_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_barang_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned order_barang_details
    **/
    _count?: true | Order_barang_detailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Order_barang_detailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Order_barang_detailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Order_barang_detailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Order_barang_detailMaxAggregateInputType
  }

  export type GetOrder_barang_detailAggregateType<T extends Order_barang_detailAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder_barang_detail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder_barang_detail[P]>
      : GetScalarType<T[P], AggregateOrder_barang_detail[P]>
  }




  export type order_barang_detailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_barang_detailWhereInput
    orderBy?: order_barang_detailOrderByWithAggregationInput | order_barang_detailOrderByWithAggregationInput[]
    by: Order_barang_detailScalarFieldEnum[] | Order_barang_detailScalarFieldEnum
    having?: order_barang_detailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Order_barang_detailCountAggregateInputType | true
    _avg?: Order_barang_detailAvgAggregateInputType
    _sum?: Order_barang_detailSumAggregateInputType
    _min?: Order_barang_detailMinAggregateInputType
    _max?: Order_barang_detailMaxAggregateInputType
  }

  export type Order_barang_detailGroupByOutputType = {
    id: string
    order_barang_id: string
    barang_id: string
    qty: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: Order_barang_detailCountAggregateOutputType | null
    _avg: Order_barang_detailAvgAggregateOutputType | null
    _sum: Order_barang_detailSumAggregateOutputType | null
    _min: Order_barang_detailMinAggregateOutputType | null
    _max: Order_barang_detailMaxAggregateOutputType | null
  }

  type GetOrder_barang_detailGroupByPayload<T extends order_barang_detailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Order_barang_detailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Order_barang_detailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Order_barang_detailGroupByOutputType[P]>
            : GetScalarType<T[P], Order_barang_detailGroupByOutputType[P]>
        }
      >
    >


  export type order_barang_detailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_barang_id?: boolean
    barang_id?: boolean
    qty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    barang?: boolean | barangDefaultArgs<ExtArgs>
    order_barang?: boolean | order_barangDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_barang_detail"]>

  export type order_barang_detailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_barang_id?: boolean
    barang_id?: boolean
    qty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    barang?: boolean | barangDefaultArgs<ExtArgs>
    order_barang?: boolean | order_barangDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_barang_detail"]>

  export type order_barang_detailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_barang_id?: boolean
    barang_id?: boolean
    qty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    barang?: boolean | barangDefaultArgs<ExtArgs>
    order_barang?: boolean | order_barangDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_barang_detail"]>

  export type order_barang_detailSelectScalar = {
    id?: boolean
    order_barang_id?: boolean
    barang_id?: boolean
    qty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type order_barang_detailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "order_barang_id" | "barang_id" | "qty" | "createdAt" | "updatedAt", ExtArgs["result"]["order_barang_detail"]>
  export type order_barang_detailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barang?: boolean | barangDefaultArgs<ExtArgs>
    order_barang?: boolean | order_barangDefaultArgs<ExtArgs>
  }
  export type order_barang_detailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barang?: boolean | barangDefaultArgs<ExtArgs>
    order_barang?: boolean | order_barangDefaultArgs<ExtArgs>
  }
  export type order_barang_detailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barang?: boolean | barangDefaultArgs<ExtArgs>
    order_barang?: boolean | order_barangDefaultArgs<ExtArgs>
  }

  export type $order_barang_detailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "order_barang_detail"
    objects: {
      barang: Prisma.$barangPayload<ExtArgs>
      order_barang: Prisma.$order_barangPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      order_barang_id: string
      barang_id: string
      qty: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["order_barang_detail"]>
    composites: {}
  }

  type order_barang_detailGetPayload<S extends boolean | null | undefined | order_barang_detailDefaultArgs> = $Result.GetResult<Prisma.$order_barang_detailPayload, S>

  type order_barang_detailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<order_barang_detailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Order_barang_detailCountAggregateInputType | true
    }

  export interface order_barang_detailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['order_barang_detail'], meta: { name: 'order_barang_detail' } }
    /**
     * Find zero or one Order_barang_detail that matches the filter.
     * @param {order_barang_detailFindUniqueArgs} args - Arguments to find a Order_barang_detail
     * @example
     * // Get one Order_barang_detail
     * const order_barang_detail = await prisma.order_barang_detail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends order_barang_detailFindUniqueArgs>(args: SelectSubset<T, order_barang_detailFindUniqueArgs<ExtArgs>>): Prisma__order_barang_detailClient<$Result.GetResult<Prisma.$order_barang_detailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order_barang_detail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {order_barang_detailFindUniqueOrThrowArgs} args - Arguments to find a Order_barang_detail
     * @example
     * // Get one Order_barang_detail
     * const order_barang_detail = await prisma.order_barang_detail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends order_barang_detailFindUniqueOrThrowArgs>(args: SelectSubset<T, order_barang_detailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__order_barang_detailClient<$Result.GetResult<Prisma.$order_barang_detailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order_barang_detail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_barang_detailFindFirstArgs} args - Arguments to find a Order_barang_detail
     * @example
     * // Get one Order_barang_detail
     * const order_barang_detail = await prisma.order_barang_detail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends order_barang_detailFindFirstArgs>(args?: SelectSubset<T, order_barang_detailFindFirstArgs<ExtArgs>>): Prisma__order_barang_detailClient<$Result.GetResult<Prisma.$order_barang_detailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order_barang_detail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_barang_detailFindFirstOrThrowArgs} args - Arguments to find a Order_barang_detail
     * @example
     * // Get one Order_barang_detail
     * const order_barang_detail = await prisma.order_barang_detail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends order_barang_detailFindFirstOrThrowArgs>(args?: SelectSubset<T, order_barang_detailFindFirstOrThrowArgs<ExtArgs>>): Prisma__order_barang_detailClient<$Result.GetResult<Prisma.$order_barang_detailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Order_barang_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_barang_detailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Order_barang_details
     * const order_barang_details = await prisma.order_barang_detail.findMany()
     * 
     * // Get first 10 Order_barang_details
     * const order_barang_details = await prisma.order_barang_detail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const order_barang_detailWithIdOnly = await prisma.order_barang_detail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends order_barang_detailFindManyArgs>(args?: SelectSubset<T, order_barang_detailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_barang_detailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order_barang_detail.
     * @param {order_barang_detailCreateArgs} args - Arguments to create a Order_barang_detail.
     * @example
     * // Create one Order_barang_detail
     * const Order_barang_detail = await prisma.order_barang_detail.create({
     *   data: {
     *     // ... data to create a Order_barang_detail
     *   }
     * })
     * 
     */
    create<T extends order_barang_detailCreateArgs>(args: SelectSubset<T, order_barang_detailCreateArgs<ExtArgs>>): Prisma__order_barang_detailClient<$Result.GetResult<Prisma.$order_barang_detailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Order_barang_details.
     * @param {order_barang_detailCreateManyArgs} args - Arguments to create many Order_barang_details.
     * @example
     * // Create many Order_barang_details
     * const order_barang_detail = await prisma.order_barang_detail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends order_barang_detailCreateManyArgs>(args?: SelectSubset<T, order_barang_detailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Order_barang_details and returns the data saved in the database.
     * @param {order_barang_detailCreateManyAndReturnArgs} args - Arguments to create many Order_barang_details.
     * @example
     * // Create many Order_barang_details
     * const order_barang_detail = await prisma.order_barang_detail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Order_barang_details and only return the `id`
     * const order_barang_detailWithIdOnly = await prisma.order_barang_detail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends order_barang_detailCreateManyAndReturnArgs>(args?: SelectSubset<T, order_barang_detailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_barang_detailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order_barang_detail.
     * @param {order_barang_detailDeleteArgs} args - Arguments to delete one Order_barang_detail.
     * @example
     * // Delete one Order_barang_detail
     * const Order_barang_detail = await prisma.order_barang_detail.delete({
     *   where: {
     *     // ... filter to delete one Order_barang_detail
     *   }
     * })
     * 
     */
    delete<T extends order_barang_detailDeleteArgs>(args: SelectSubset<T, order_barang_detailDeleteArgs<ExtArgs>>): Prisma__order_barang_detailClient<$Result.GetResult<Prisma.$order_barang_detailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order_barang_detail.
     * @param {order_barang_detailUpdateArgs} args - Arguments to update one Order_barang_detail.
     * @example
     * // Update one Order_barang_detail
     * const order_barang_detail = await prisma.order_barang_detail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends order_barang_detailUpdateArgs>(args: SelectSubset<T, order_barang_detailUpdateArgs<ExtArgs>>): Prisma__order_barang_detailClient<$Result.GetResult<Prisma.$order_barang_detailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Order_barang_details.
     * @param {order_barang_detailDeleteManyArgs} args - Arguments to filter Order_barang_details to delete.
     * @example
     * // Delete a few Order_barang_details
     * const { count } = await prisma.order_barang_detail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends order_barang_detailDeleteManyArgs>(args?: SelectSubset<T, order_barang_detailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_barang_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_barang_detailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Order_barang_details
     * const order_barang_detail = await prisma.order_barang_detail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends order_barang_detailUpdateManyArgs>(args: SelectSubset<T, order_barang_detailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_barang_details and returns the data updated in the database.
     * @param {order_barang_detailUpdateManyAndReturnArgs} args - Arguments to update many Order_barang_details.
     * @example
     * // Update many Order_barang_details
     * const order_barang_detail = await prisma.order_barang_detail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Order_barang_details and only return the `id`
     * const order_barang_detailWithIdOnly = await prisma.order_barang_detail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends order_barang_detailUpdateManyAndReturnArgs>(args: SelectSubset<T, order_barang_detailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_barang_detailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order_barang_detail.
     * @param {order_barang_detailUpsertArgs} args - Arguments to update or create a Order_barang_detail.
     * @example
     * // Update or create a Order_barang_detail
     * const order_barang_detail = await prisma.order_barang_detail.upsert({
     *   create: {
     *     // ... data to create a Order_barang_detail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order_barang_detail we want to update
     *   }
     * })
     */
    upsert<T extends order_barang_detailUpsertArgs>(args: SelectSubset<T, order_barang_detailUpsertArgs<ExtArgs>>): Prisma__order_barang_detailClient<$Result.GetResult<Prisma.$order_barang_detailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Order_barang_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_barang_detailCountArgs} args - Arguments to filter Order_barang_details to count.
     * @example
     * // Count the number of Order_barang_details
     * const count = await prisma.order_barang_detail.count({
     *   where: {
     *     // ... the filter for the Order_barang_details we want to count
     *   }
     * })
    **/
    count<T extends order_barang_detailCountArgs>(
      args?: Subset<T, order_barang_detailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Order_barang_detailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order_barang_detail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Order_barang_detailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Order_barang_detailAggregateArgs>(args: Subset<T, Order_barang_detailAggregateArgs>): Prisma.PrismaPromise<GetOrder_barang_detailAggregateType<T>>

    /**
     * Group by Order_barang_detail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_barang_detailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends order_barang_detailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: order_barang_detailGroupByArgs['orderBy'] }
        : { orderBy?: order_barang_detailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, order_barang_detailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrder_barang_detailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the order_barang_detail model
   */
  readonly fields: order_barang_detailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for order_barang_detail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__order_barang_detailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    barang<T extends barangDefaultArgs<ExtArgs> = {}>(args?: Subset<T, barangDefaultArgs<ExtArgs>>): Prisma__barangClient<$Result.GetResult<Prisma.$barangPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order_barang<T extends order_barangDefaultArgs<ExtArgs> = {}>(args?: Subset<T, order_barangDefaultArgs<ExtArgs>>): Prisma__order_barangClient<$Result.GetResult<Prisma.$order_barangPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the order_barang_detail model
   */
  interface order_barang_detailFieldRefs {
    readonly id: FieldRef<"order_barang_detail", 'String'>
    readonly order_barang_id: FieldRef<"order_barang_detail", 'String'>
    readonly barang_id: FieldRef<"order_barang_detail", 'String'>
    readonly qty: FieldRef<"order_barang_detail", 'Int'>
    readonly createdAt: FieldRef<"order_barang_detail", 'DateTime'>
    readonly updatedAt: FieldRef<"order_barang_detail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * order_barang_detail findUnique
   */
  export type order_barang_detailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang_detail
     */
    select?: order_barang_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang_detail
     */
    omit?: order_barang_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barang_detailInclude<ExtArgs> | null
    /**
     * Filter, which order_barang_detail to fetch.
     */
    where: order_barang_detailWhereUniqueInput
  }

  /**
   * order_barang_detail findUniqueOrThrow
   */
  export type order_barang_detailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang_detail
     */
    select?: order_barang_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang_detail
     */
    omit?: order_barang_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barang_detailInclude<ExtArgs> | null
    /**
     * Filter, which order_barang_detail to fetch.
     */
    where: order_barang_detailWhereUniqueInput
  }

  /**
   * order_barang_detail findFirst
   */
  export type order_barang_detailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang_detail
     */
    select?: order_barang_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang_detail
     */
    omit?: order_barang_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barang_detailInclude<ExtArgs> | null
    /**
     * Filter, which order_barang_detail to fetch.
     */
    where?: order_barang_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_barang_details to fetch.
     */
    orderBy?: order_barang_detailOrderByWithRelationInput | order_barang_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_barang_details.
     */
    cursor?: order_barang_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_barang_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_barang_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_barang_details.
     */
    distinct?: Order_barang_detailScalarFieldEnum | Order_barang_detailScalarFieldEnum[]
  }

  /**
   * order_barang_detail findFirstOrThrow
   */
  export type order_barang_detailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang_detail
     */
    select?: order_barang_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang_detail
     */
    omit?: order_barang_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barang_detailInclude<ExtArgs> | null
    /**
     * Filter, which order_barang_detail to fetch.
     */
    where?: order_barang_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_barang_details to fetch.
     */
    orderBy?: order_barang_detailOrderByWithRelationInput | order_barang_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_barang_details.
     */
    cursor?: order_barang_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_barang_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_barang_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_barang_details.
     */
    distinct?: Order_barang_detailScalarFieldEnum | Order_barang_detailScalarFieldEnum[]
  }

  /**
   * order_barang_detail findMany
   */
  export type order_barang_detailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang_detail
     */
    select?: order_barang_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang_detail
     */
    omit?: order_barang_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barang_detailInclude<ExtArgs> | null
    /**
     * Filter, which order_barang_details to fetch.
     */
    where?: order_barang_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_barang_details to fetch.
     */
    orderBy?: order_barang_detailOrderByWithRelationInput | order_barang_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing order_barang_details.
     */
    cursor?: order_barang_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_barang_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_barang_details.
     */
    skip?: number
    distinct?: Order_barang_detailScalarFieldEnum | Order_barang_detailScalarFieldEnum[]
  }

  /**
   * order_barang_detail create
   */
  export type order_barang_detailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang_detail
     */
    select?: order_barang_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang_detail
     */
    omit?: order_barang_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barang_detailInclude<ExtArgs> | null
    /**
     * The data needed to create a order_barang_detail.
     */
    data: XOR<order_barang_detailCreateInput, order_barang_detailUncheckedCreateInput>
  }

  /**
   * order_barang_detail createMany
   */
  export type order_barang_detailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many order_barang_details.
     */
    data: order_barang_detailCreateManyInput | order_barang_detailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * order_barang_detail createManyAndReturn
   */
  export type order_barang_detailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang_detail
     */
    select?: order_barang_detailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang_detail
     */
    omit?: order_barang_detailOmit<ExtArgs> | null
    /**
     * The data used to create many order_barang_details.
     */
    data: order_barang_detailCreateManyInput | order_barang_detailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barang_detailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * order_barang_detail update
   */
  export type order_barang_detailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang_detail
     */
    select?: order_barang_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang_detail
     */
    omit?: order_barang_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barang_detailInclude<ExtArgs> | null
    /**
     * The data needed to update a order_barang_detail.
     */
    data: XOR<order_barang_detailUpdateInput, order_barang_detailUncheckedUpdateInput>
    /**
     * Choose, which order_barang_detail to update.
     */
    where: order_barang_detailWhereUniqueInput
  }

  /**
   * order_barang_detail updateMany
   */
  export type order_barang_detailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update order_barang_details.
     */
    data: XOR<order_barang_detailUpdateManyMutationInput, order_barang_detailUncheckedUpdateManyInput>
    /**
     * Filter which order_barang_details to update
     */
    where?: order_barang_detailWhereInput
    /**
     * Limit how many order_barang_details to update.
     */
    limit?: number
  }

  /**
   * order_barang_detail updateManyAndReturn
   */
  export type order_barang_detailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang_detail
     */
    select?: order_barang_detailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang_detail
     */
    omit?: order_barang_detailOmit<ExtArgs> | null
    /**
     * The data used to update order_barang_details.
     */
    data: XOR<order_barang_detailUpdateManyMutationInput, order_barang_detailUncheckedUpdateManyInput>
    /**
     * Filter which order_barang_details to update
     */
    where?: order_barang_detailWhereInput
    /**
     * Limit how many order_barang_details to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barang_detailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * order_barang_detail upsert
   */
  export type order_barang_detailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang_detail
     */
    select?: order_barang_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang_detail
     */
    omit?: order_barang_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barang_detailInclude<ExtArgs> | null
    /**
     * The filter to search for the order_barang_detail to update in case it exists.
     */
    where: order_barang_detailWhereUniqueInput
    /**
     * In case the order_barang_detail found by the `where` argument doesn't exist, create a new order_barang_detail with this data.
     */
    create: XOR<order_barang_detailCreateInput, order_barang_detailUncheckedCreateInput>
    /**
     * In case the order_barang_detail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<order_barang_detailUpdateInput, order_barang_detailUncheckedUpdateInput>
  }

  /**
   * order_barang_detail delete
   */
  export type order_barang_detailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang_detail
     */
    select?: order_barang_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang_detail
     */
    omit?: order_barang_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barang_detailInclude<ExtArgs> | null
    /**
     * Filter which order_barang_detail to delete.
     */
    where: order_barang_detailWhereUniqueInput
  }

  /**
   * order_barang_detail deleteMany
   */
  export type order_barang_detailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_barang_details to delete
     */
    where?: order_barang_detailWhereInput
    /**
     * Limit how many order_barang_details to delete.
     */
    limit?: number
  }

  /**
   * order_barang_detail without action
   */
  export type order_barang_detailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang_detail
     */
    select?: order_barang_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang_detail
     */
    omit?: order_barang_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barang_detailInclude<ExtArgs> | null
  }


  /**
   * Model status
   */

  export type AggregateStatus = {
    _count: StatusCountAggregateOutputType | null
    _min: StatusMinAggregateOutputType | null
    _max: StatusMaxAggregateOutputType | null
  }

  export type StatusMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatusMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatusCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StatusMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatusMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatusCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which status to aggregate.
     */
    where?: statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statuses to fetch.
     */
    orderBy?: statusOrderByWithRelationInput | statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned statuses
    **/
    _count?: true | StatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusMaxAggregateInputType
  }

  export type GetStatusAggregateType<T extends StatusAggregateArgs> = {
        [P in keyof T & keyof AggregateStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatus[P]>
      : GetScalarType<T[P], AggregateStatus[P]>
  }




  export type statusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: statusWhereInput
    orderBy?: statusOrderByWithAggregationInput | statusOrderByWithAggregationInput[]
    by: StatusScalarFieldEnum[] | StatusScalarFieldEnum
    having?: statusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusCountAggregateInputType | true
    _min?: StatusMinAggregateInputType
    _max?: StatusMaxAggregateInputType
  }

  export type StatusGroupByOutputType = {
    id: string
    name: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: StatusCountAggregateOutputType | null
    _min: StatusMinAggregateOutputType | null
    _max: StatusMaxAggregateOutputType | null
  }

  type GetStatusGroupByPayload<T extends statusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusGroupByOutputType[P]>
            : GetScalarType<T[P], StatusGroupByOutputType[P]>
        }
      >
    >


  export type statusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | status$employeeArgs<ExtArgs>
    users?: boolean | status$usersArgs<ExtArgs>
    _count?: boolean | StatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["status"]>

  export type statusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["status"]>

  export type statusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["status"]>

  export type statusSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type statusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["status"]>
  export type statusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | status$employeeArgs<ExtArgs>
    users?: boolean | status$usersArgs<ExtArgs>
    _count?: boolean | StatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type statusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type statusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $statusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "status"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["status"]>
    composites: {}
  }

  type statusGetPayload<S extends boolean | null | undefined | statusDefaultArgs> = $Result.GetResult<Prisma.$statusPayload, S>

  type statusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<statusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StatusCountAggregateInputType | true
    }

  export interface statusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['status'], meta: { name: 'status' } }
    /**
     * Find zero or one Status that matches the filter.
     * @param {statusFindUniqueArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends statusFindUniqueArgs>(args: SelectSubset<T, statusFindUniqueArgs<ExtArgs>>): Prisma__statusClient<$Result.GetResult<Prisma.$statusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Status that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {statusFindUniqueOrThrowArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends statusFindUniqueOrThrowArgs>(args: SelectSubset<T, statusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__statusClient<$Result.GetResult<Prisma.$statusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Status that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusFindFirstArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends statusFindFirstArgs>(args?: SelectSubset<T, statusFindFirstArgs<ExtArgs>>): Prisma__statusClient<$Result.GetResult<Prisma.$statusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Status that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusFindFirstOrThrowArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends statusFindFirstOrThrowArgs>(args?: SelectSubset<T, statusFindFirstOrThrowArgs<ExtArgs>>): Prisma__statusClient<$Result.GetResult<Prisma.$statusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Statuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Statuses
     * const statuses = await prisma.status.findMany()
     * 
     * // Get first 10 Statuses
     * const statuses = await prisma.status.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statusWithIdOnly = await prisma.status.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends statusFindManyArgs>(args?: SelectSubset<T, statusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Status.
     * @param {statusCreateArgs} args - Arguments to create a Status.
     * @example
     * // Create one Status
     * const Status = await prisma.status.create({
     *   data: {
     *     // ... data to create a Status
     *   }
     * })
     * 
     */
    create<T extends statusCreateArgs>(args: SelectSubset<T, statusCreateArgs<ExtArgs>>): Prisma__statusClient<$Result.GetResult<Prisma.$statusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Statuses.
     * @param {statusCreateManyArgs} args - Arguments to create many Statuses.
     * @example
     * // Create many Statuses
     * const status = await prisma.status.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends statusCreateManyArgs>(args?: SelectSubset<T, statusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Statuses and returns the data saved in the database.
     * @param {statusCreateManyAndReturnArgs} args - Arguments to create many Statuses.
     * @example
     * // Create many Statuses
     * const status = await prisma.status.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Statuses and only return the `id`
     * const statusWithIdOnly = await prisma.status.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends statusCreateManyAndReturnArgs>(args?: SelectSubset<T, statusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Status.
     * @param {statusDeleteArgs} args - Arguments to delete one Status.
     * @example
     * // Delete one Status
     * const Status = await prisma.status.delete({
     *   where: {
     *     // ... filter to delete one Status
     *   }
     * })
     * 
     */
    delete<T extends statusDeleteArgs>(args: SelectSubset<T, statusDeleteArgs<ExtArgs>>): Prisma__statusClient<$Result.GetResult<Prisma.$statusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Status.
     * @param {statusUpdateArgs} args - Arguments to update one Status.
     * @example
     * // Update one Status
     * const status = await prisma.status.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends statusUpdateArgs>(args: SelectSubset<T, statusUpdateArgs<ExtArgs>>): Prisma__statusClient<$Result.GetResult<Prisma.$statusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Statuses.
     * @param {statusDeleteManyArgs} args - Arguments to filter Statuses to delete.
     * @example
     * // Delete a few Statuses
     * const { count } = await prisma.status.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends statusDeleteManyArgs>(args?: SelectSubset<T, statusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Statuses
     * const status = await prisma.status.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends statusUpdateManyArgs>(args: SelectSubset<T, statusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Statuses and returns the data updated in the database.
     * @param {statusUpdateManyAndReturnArgs} args - Arguments to update many Statuses.
     * @example
     * // Update many Statuses
     * const status = await prisma.status.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Statuses and only return the `id`
     * const statusWithIdOnly = await prisma.status.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends statusUpdateManyAndReturnArgs>(args: SelectSubset<T, statusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Status.
     * @param {statusUpsertArgs} args - Arguments to update or create a Status.
     * @example
     * // Update or create a Status
     * const status = await prisma.status.upsert({
     *   create: {
     *     // ... data to create a Status
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Status we want to update
     *   }
     * })
     */
    upsert<T extends statusUpsertArgs>(args: SelectSubset<T, statusUpsertArgs<ExtArgs>>): Prisma__statusClient<$Result.GetResult<Prisma.$statusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusCountArgs} args - Arguments to filter Statuses to count.
     * @example
     * // Count the number of Statuses
     * const count = await prisma.status.count({
     *   where: {
     *     // ... the filter for the Statuses we want to count
     *   }
     * })
    **/
    count<T extends statusCountArgs>(
      args?: Subset<T, statusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusAggregateArgs>(args: Subset<T, StatusAggregateArgs>): Prisma.PrismaPromise<GetStatusAggregateType<T>>

    /**
     * Group by Status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends statusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: statusGroupByArgs['orderBy'] }
        : { orderBy?: statusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, statusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the status model
   */
  readonly fields: statusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for status.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__statusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends status$employeeArgs<ExtArgs> = {}>(args?: Subset<T, status$employeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends status$usersArgs<ExtArgs> = {}>(args?: Subset<T, status$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the status model
   */
  interface statusFieldRefs {
    readonly id: FieldRef<"status", 'String'>
    readonly name: FieldRef<"status", 'String'>
    readonly createdAt: FieldRef<"status", 'DateTime'>
    readonly updatedAt: FieldRef<"status", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * status findUnique
   */
  export type statusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null
    /**
     * Filter, which status to fetch.
     */
    where: statusWhereUniqueInput
  }

  /**
   * status findUniqueOrThrow
   */
  export type statusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null
    /**
     * Filter, which status to fetch.
     */
    where: statusWhereUniqueInput
  }

  /**
   * status findFirst
   */
  export type statusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null
    /**
     * Filter, which status to fetch.
     */
    where?: statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statuses to fetch.
     */
    orderBy?: statusOrderByWithRelationInput | statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statuses.
     */
    cursor?: statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statuses.
     */
    distinct?: StatusScalarFieldEnum | StatusScalarFieldEnum[]
  }

  /**
   * status findFirstOrThrow
   */
  export type statusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null
    /**
     * Filter, which status to fetch.
     */
    where?: statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statuses to fetch.
     */
    orderBy?: statusOrderByWithRelationInput | statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statuses.
     */
    cursor?: statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statuses.
     */
    distinct?: StatusScalarFieldEnum | StatusScalarFieldEnum[]
  }

  /**
   * status findMany
   */
  export type statusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null
    /**
     * Filter, which statuses to fetch.
     */
    where?: statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statuses to fetch.
     */
    orderBy?: statusOrderByWithRelationInput | statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing statuses.
     */
    cursor?: statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statuses.
     */
    skip?: number
    distinct?: StatusScalarFieldEnum | StatusScalarFieldEnum[]
  }

  /**
   * status create
   */
  export type statusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null
    /**
     * The data needed to create a status.
     */
    data: XOR<statusCreateInput, statusUncheckedCreateInput>
  }

  /**
   * status createMany
   */
  export type statusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many statuses.
     */
    data: statusCreateManyInput | statusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * status createManyAndReturn
   */
  export type statusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null
    /**
     * The data used to create many statuses.
     */
    data: statusCreateManyInput | statusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * status update
   */
  export type statusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null
    /**
     * The data needed to update a status.
     */
    data: XOR<statusUpdateInput, statusUncheckedUpdateInput>
    /**
     * Choose, which status to update.
     */
    where: statusWhereUniqueInput
  }

  /**
   * status updateMany
   */
  export type statusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update statuses.
     */
    data: XOR<statusUpdateManyMutationInput, statusUncheckedUpdateManyInput>
    /**
     * Filter which statuses to update
     */
    where?: statusWhereInput
    /**
     * Limit how many statuses to update.
     */
    limit?: number
  }

  /**
   * status updateManyAndReturn
   */
  export type statusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null
    /**
     * The data used to update statuses.
     */
    data: XOR<statusUpdateManyMutationInput, statusUncheckedUpdateManyInput>
    /**
     * Filter which statuses to update
     */
    where?: statusWhereInput
    /**
     * Limit how many statuses to update.
     */
    limit?: number
  }

  /**
   * status upsert
   */
  export type statusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null
    /**
     * The filter to search for the status to update in case it exists.
     */
    where: statusWhereUniqueInput
    /**
     * In case the status found by the `where` argument doesn't exist, create a new status with this data.
     */
    create: XOR<statusCreateInput, statusUncheckedCreateInput>
    /**
     * In case the status was found with the provided `where` argument, update it with this data.
     */
    update: XOR<statusUpdateInput, statusUncheckedUpdateInput>
  }

  /**
   * status delete
   */
  export type statusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null
    /**
     * Filter which status to delete.
     */
    where: statusWhereUniqueInput
  }

  /**
   * status deleteMany
   */
  export type statusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which statuses to delete
     */
    where?: statusWhereInput
    /**
     * Limit how many statuses to delete.
     */
    limit?: number
  }

  /**
   * status.employee
   */
  export type status$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    where?: employeeWhereInput
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    cursor?: employeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * status.users
   */
  export type status$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * status without action
   */
  export type statusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null
  }


  /**
   * Model transaksi
   */

  export type AggregateTransaksi = {
    _count: TransaksiCountAggregateOutputType | null
    _avg: TransaksiAvgAggregateOutputType | null
    _sum: TransaksiSumAggregateOutputType | null
    _min: TransaksiMinAggregateOutputType | null
    _max: TransaksiMaxAggregateOutputType | null
  }

  export type TransaksiAvgAggregateOutputType = {
    point: number | null
    total: Decimal | null
  }

  export type TransaksiSumAggregateOutputType = {
    point: number | null
    total: Decimal | null
  }

  export type TransaksiMinAggregateOutputType = {
    id: string | null
    users_id: string | null
    mekanik_id: string | null
    warehouse_id: string | null
    point: number | null
    total: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransaksiMaxAggregateOutputType = {
    id: string | null
    users_id: string | null
    mekanik_id: string | null
    warehouse_id: string | null
    point: number | null
    total: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransaksiCountAggregateOutputType = {
    id: number
    users_id: number
    mekanik_id: number
    warehouse_id: number
    point: number
    total: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransaksiAvgAggregateInputType = {
    point?: true
    total?: true
  }

  export type TransaksiSumAggregateInputType = {
    point?: true
    total?: true
  }

  export type TransaksiMinAggregateInputType = {
    id?: true
    users_id?: true
    mekanik_id?: true
    warehouse_id?: true
    point?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransaksiMaxAggregateInputType = {
    id?: true
    users_id?: true
    mekanik_id?: true
    warehouse_id?: true
    point?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransaksiCountAggregateInputType = {
    id?: true
    users_id?: true
    mekanik_id?: true
    warehouse_id?: true
    point?: true
    total?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransaksiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaksi to aggregate.
     */
    where?: transaksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksis to fetch.
     */
    orderBy?: transaksiOrderByWithRelationInput | transaksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transaksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transaksis
    **/
    _count?: true | TransaksiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransaksiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransaksiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransaksiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransaksiMaxAggregateInputType
  }

  export type GetTransaksiAggregateType<T extends TransaksiAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaksi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaksi[P]>
      : GetScalarType<T[P], AggregateTransaksi[P]>
  }




  export type transaksiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaksiWhereInput
    orderBy?: transaksiOrderByWithAggregationInput | transaksiOrderByWithAggregationInput[]
    by: TransaksiScalarFieldEnum[] | TransaksiScalarFieldEnum
    having?: transaksiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransaksiCountAggregateInputType | true
    _avg?: TransaksiAvgAggregateInputType
    _sum?: TransaksiSumAggregateInputType
    _min?: TransaksiMinAggregateInputType
    _max?: TransaksiMaxAggregateInputType
  }

  export type TransaksiGroupByOutputType = {
    id: string
    users_id: string
    mekanik_id: string
    warehouse_id: string
    point: number
    total: Decimal
    createdAt: Date | null
    updatedAt: Date | null
    _count: TransaksiCountAggregateOutputType | null
    _avg: TransaksiAvgAggregateOutputType | null
    _sum: TransaksiSumAggregateOutputType | null
    _min: TransaksiMinAggregateOutputType | null
    _max: TransaksiMaxAggregateOutputType | null
  }

  type GetTransaksiGroupByPayload<T extends transaksiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransaksiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransaksiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransaksiGroupByOutputType[P]>
            : GetScalarType<T[P], TransaksiGroupByOutputType[P]>
        }
      >
    >


  export type transaksiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    users_id?: boolean
    mekanik_id?: boolean
    warehouse_id?: boolean
    point?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mekanik?: boolean | mekanikDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    warehouse?: boolean | warehouseDefaultArgs<ExtArgs>
    transaksi_detail?: boolean | transaksi$transaksi_detailArgs<ExtArgs>
    _count?: boolean | TransaksiCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaksi"]>

  export type transaksiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    users_id?: boolean
    mekanik_id?: boolean
    warehouse_id?: boolean
    point?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mekanik?: boolean | mekanikDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    warehouse?: boolean | warehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaksi"]>

  export type transaksiSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    users_id?: boolean
    mekanik_id?: boolean
    warehouse_id?: boolean
    point?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mekanik?: boolean | mekanikDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    warehouse?: boolean | warehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaksi"]>

  export type transaksiSelectScalar = {
    id?: boolean
    users_id?: boolean
    mekanik_id?: boolean
    warehouse_id?: boolean
    point?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type transaksiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "users_id" | "mekanik_id" | "warehouse_id" | "point" | "total" | "createdAt" | "updatedAt", ExtArgs["result"]["transaksi"]>
  export type transaksiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mekanik?: boolean | mekanikDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    warehouse?: boolean | warehouseDefaultArgs<ExtArgs>
    transaksi_detail?: boolean | transaksi$transaksi_detailArgs<ExtArgs>
    _count?: boolean | TransaksiCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type transaksiIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mekanik?: boolean | mekanikDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    warehouse?: boolean | warehouseDefaultArgs<ExtArgs>
  }
  export type transaksiIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mekanik?: boolean | mekanikDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    warehouse?: boolean | warehouseDefaultArgs<ExtArgs>
  }

  export type $transaksiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transaksi"
    objects: {
      mekanik: Prisma.$mekanikPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
      warehouse: Prisma.$warehousePayload<ExtArgs>
      transaksi_detail: Prisma.$transaksi_detailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      users_id: string
      mekanik_id: string
      warehouse_id: string
      point: number
      total: Prisma.Decimal
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["transaksi"]>
    composites: {}
  }

  type transaksiGetPayload<S extends boolean | null | undefined | transaksiDefaultArgs> = $Result.GetResult<Prisma.$transaksiPayload, S>

  type transaksiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transaksiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransaksiCountAggregateInputType | true
    }

  export interface transaksiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transaksi'], meta: { name: 'transaksi' } }
    /**
     * Find zero or one Transaksi that matches the filter.
     * @param {transaksiFindUniqueArgs} args - Arguments to find a Transaksi
     * @example
     * // Get one Transaksi
     * const transaksi = await prisma.transaksi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transaksiFindUniqueArgs>(args: SelectSubset<T, transaksiFindUniqueArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaksi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transaksiFindUniqueOrThrowArgs} args - Arguments to find a Transaksi
     * @example
     * // Get one Transaksi
     * const transaksi = await prisma.transaksi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transaksiFindUniqueOrThrowArgs>(args: SelectSubset<T, transaksiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaksi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksiFindFirstArgs} args - Arguments to find a Transaksi
     * @example
     * // Get one Transaksi
     * const transaksi = await prisma.transaksi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transaksiFindFirstArgs>(args?: SelectSubset<T, transaksiFindFirstArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaksi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksiFindFirstOrThrowArgs} args - Arguments to find a Transaksi
     * @example
     * // Get one Transaksi
     * const transaksi = await prisma.transaksi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transaksiFindFirstOrThrowArgs>(args?: SelectSubset<T, transaksiFindFirstOrThrowArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transaksis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transaksis
     * const transaksis = await prisma.transaksi.findMany()
     * 
     * // Get first 10 Transaksis
     * const transaksis = await prisma.transaksi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transaksiWithIdOnly = await prisma.transaksi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transaksiFindManyArgs>(args?: SelectSubset<T, transaksiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaksi.
     * @param {transaksiCreateArgs} args - Arguments to create a Transaksi.
     * @example
     * // Create one Transaksi
     * const Transaksi = await prisma.transaksi.create({
     *   data: {
     *     // ... data to create a Transaksi
     *   }
     * })
     * 
     */
    create<T extends transaksiCreateArgs>(args: SelectSubset<T, transaksiCreateArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transaksis.
     * @param {transaksiCreateManyArgs} args - Arguments to create many Transaksis.
     * @example
     * // Create many Transaksis
     * const transaksi = await prisma.transaksi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transaksiCreateManyArgs>(args?: SelectSubset<T, transaksiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transaksis and returns the data saved in the database.
     * @param {transaksiCreateManyAndReturnArgs} args - Arguments to create many Transaksis.
     * @example
     * // Create many Transaksis
     * const transaksi = await prisma.transaksi.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transaksis and only return the `id`
     * const transaksiWithIdOnly = await prisma.transaksi.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends transaksiCreateManyAndReturnArgs>(args?: SelectSubset<T, transaksiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaksi.
     * @param {transaksiDeleteArgs} args - Arguments to delete one Transaksi.
     * @example
     * // Delete one Transaksi
     * const Transaksi = await prisma.transaksi.delete({
     *   where: {
     *     // ... filter to delete one Transaksi
     *   }
     * })
     * 
     */
    delete<T extends transaksiDeleteArgs>(args: SelectSubset<T, transaksiDeleteArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaksi.
     * @param {transaksiUpdateArgs} args - Arguments to update one Transaksi.
     * @example
     * // Update one Transaksi
     * const transaksi = await prisma.transaksi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transaksiUpdateArgs>(args: SelectSubset<T, transaksiUpdateArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transaksis.
     * @param {transaksiDeleteManyArgs} args - Arguments to filter Transaksis to delete.
     * @example
     * // Delete a few Transaksis
     * const { count } = await prisma.transaksi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transaksiDeleteManyArgs>(args?: SelectSubset<T, transaksiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transaksis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transaksis
     * const transaksi = await prisma.transaksi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transaksiUpdateManyArgs>(args: SelectSubset<T, transaksiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transaksis and returns the data updated in the database.
     * @param {transaksiUpdateManyAndReturnArgs} args - Arguments to update many Transaksis.
     * @example
     * // Update many Transaksis
     * const transaksi = await prisma.transaksi.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transaksis and only return the `id`
     * const transaksiWithIdOnly = await prisma.transaksi.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends transaksiUpdateManyAndReturnArgs>(args: SelectSubset<T, transaksiUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaksi.
     * @param {transaksiUpsertArgs} args - Arguments to update or create a Transaksi.
     * @example
     * // Update or create a Transaksi
     * const transaksi = await prisma.transaksi.upsert({
     *   create: {
     *     // ... data to create a Transaksi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaksi we want to update
     *   }
     * })
     */
    upsert<T extends transaksiUpsertArgs>(args: SelectSubset<T, transaksiUpsertArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transaksis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksiCountArgs} args - Arguments to filter Transaksis to count.
     * @example
     * // Count the number of Transaksis
     * const count = await prisma.transaksi.count({
     *   where: {
     *     // ... the filter for the Transaksis we want to count
     *   }
     * })
    **/
    count<T extends transaksiCountArgs>(
      args?: Subset<T, transaksiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransaksiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaksi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransaksiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransaksiAggregateArgs>(args: Subset<T, TransaksiAggregateArgs>): Prisma.PrismaPromise<GetTransaksiAggregateType<T>>

    /**
     * Group by Transaksi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transaksiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transaksiGroupByArgs['orderBy'] }
        : { orderBy?: transaksiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transaksiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransaksiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transaksi model
   */
  readonly fields: transaksiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transaksi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transaksiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mekanik<T extends mekanikDefaultArgs<ExtArgs> = {}>(args?: Subset<T, mekanikDefaultArgs<ExtArgs>>): Prisma__mekanikClient<$Result.GetResult<Prisma.$mekanikPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends warehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, warehouseDefaultArgs<ExtArgs>>): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaksi_detail<T extends transaksi$transaksi_detailArgs<ExtArgs> = {}>(args?: Subset<T, transaksi$transaksi_detailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaksi_detailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transaksi model
   */
  interface transaksiFieldRefs {
    readonly id: FieldRef<"transaksi", 'String'>
    readonly users_id: FieldRef<"transaksi", 'String'>
    readonly mekanik_id: FieldRef<"transaksi", 'String'>
    readonly warehouse_id: FieldRef<"transaksi", 'String'>
    readonly point: FieldRef<"transaksi", 'Int'>
    readonly total: FieldRef<"transaksi", 'Decimal'>
    readonly createdAt: FieldRef<"transaksi", 'DateTime'>
    readonly updatedAt: FieldRef<"transaksi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * transaksi findUnique
   */
  export type transaksiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi
     */
    omit?: transaksiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    /**
     * Filter, which transaksi to fetch.
     */
    where: transaksiWhereUniqueInput
  }

  /**
   * transaksi findUniqueOrThrow
   */
  export type transaksiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi
     */
    omit?: transaksiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    /**
     * Filter, which transaksi to fetch.
     */
    where: transaksiWhereUniqueInput
  }

  /**
   * transaksi findFirst
   */
  export type transaksiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi
     */
    omit?: transaksiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    /**
     * Filter, which transaksi to fetch.
     */
    where?: transaksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksis to fetch.
     */
    orderBy?: transaksiOrderByWithRelationInput | transaksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaksis.
     */
    cursor?: transaksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaksis.
     */
    distinct?: TransaksiScalarFieldEnum | TransaksiScalarFieldEnum[]
  }

  /**
   * transaksi findFirstOrThrow
   */
  export type transaksiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi
     */
    omit?: transaksiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    /**
     * Filter, which transaksi to fetch.
     */
    where?: transaksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksis to fetch.
     */
    orderBy?: transaksiOrderByWithRelationInput | transaksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaksis.
     */
    cursor?: transaksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaksis.
     */
    distinct?: TransaksiScalarFieldEnum | TransaksiScalarFieldEnum[]
  }

  /**
   * transaksi findMany
   */
  export type transaksiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi
     */
    omit?: transaksiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    /**
     * Filter, which transaksis to fetch.
     */
    where?: transaksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksis to fetch.
     */
    orderBy?: transaksiOrderByWithRelationInput | transaksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transaksis.
     */
    cursor?: transaksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksis.
     */
    skip?: number
    distinct?: TransaksiScalarFieldEnum | TransaksiScalarFieldEnum[]
  }

  /**
   * transaksi create
   */
  export type transaksiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi
     */
    omit?: transaksiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    /**
     * The data needed to create a transaksi.
     */
    data: XOR<transaksiCreateInput, transaksiUncheckedCreateInput>
  }

  /**
   * transaksi createMany
   */
  export type transaksiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transaksis.
     */
    data: transaksiCreateManyInput | transaksiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transaksi createManyAndReturn
   */
  export type transaksiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi
     */
    omit?: transaksiOmit<ExtArgs> | null
    /**
     * The data used to create many transaksis.
     */
    data: transaksiCreateManyInput | transaksiCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * transaksi update
   */
  export type transaksiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi
     */
    omit?: transaksiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    /**
     * The data needed to update a transaksi.
     */
    data: XOR<transaksiUpdateInput, transaksiUncheckedUpdateInput>
    /**
     * Choose, which transaksi to update.
     */
    where: transaksiWhereUniqueInput
  }

  /**
   * transaksi updateMany
   */
  export type transaksiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transaksis.
     */
    data: XOR<transaksiUpdateManyMutationInput, transaksiUncheckedUpdateManyInput>
    /**
     * Filter which transaksis to update
     */
    where?: transaksiWhereInput
    /**
     * Limit how many transaksis to update.
     */
    limit?: number
  }

  /**
   * transaksi updateManyAndReturn
   */
  export type transaksiUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi
     */
    omit?: transaksiOmit<ExtArgs> | null
    /**
     * The data used to update transaksis.
     */
    data: XOR<transaksiUpdateManyMutationInput, transaksiUncheckedUpdateManyInput>
    /**
     * Filter which transaksis to update
     */
    where?: transaksiWhereInput
    /**
     * Limit how many transaksis to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * transaksi upsert
   */
  export type transaksiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi
     */
    omit?: transaksiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    /**
     * The filter to search for the transaksi to update in case it exists.
     */
    where: transaksiWhereUniqueInput
    /**
     * In case the transaksi found by the `where` argument doesn't exist, create a new transaksi with this data.
     */
    create: XOR<transaksiCreateInput, transaksiUncheckedCreateInput>
    /**
     * In case the transaksi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transaksiUpdateInput, transaksiUncheckedUpdateInput>
  }

  /**
   * transaksi delete
   */
  export type transaksiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi
     */
    omit?: transaksiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    /**
     * Filter which transaksi to delete.
     */
    where: transaksiWhereUniqueInput
  }

  /**
   * transaksi deleteMany
   */
  export type transaksiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaksis to delete
     */
    where?: transaksiWhereInput
    /**
     * Limit how many transaksis to delete.
     */
    limit?: number
  }

  /**
   * transaksi.transaksi_detail
   */
  export type transaksi$transaksi_detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_detail
     */
    select?: transaksi_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi_detail
     */
    omit?: transaksi_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksi_detailInclude<ExtArgs> | null
    where?: transaksi_detailWhereInput
    orderBy?: transaksi_detailOrderByWithRelationInput | transaksi_detailOrderByWithRelationInput[]
    cursor?: transaksi_detailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Transaksi_detailScalarFieldEnum | Transaksi_detailScalarFieldEnum[]
  }

  /**
   * transaksi without action
   */
  export type transaksiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi
     */
    omit?: transaksiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
  }


  /**
   * Model transaksi_detail
   */

  export type AggregateTransaksi_detail = {
    _count: Transaksi_detailCountAggregateOutputType | null
    _avg: Transaksi_detailAvgAggregateOutputType | null
    _sum: Transaksi_detailSumAggregateOutputType | null
    _min: Transaksi_detailMinAggregateOutputType | null
    _max: Transaksi_detailMaxAggregateOutputType | null
  }

  export type Transaksi_detailAvgAggregateOutputType = {
    qty: number | null
    sub_total: Decimal | null
  }

  export type Transaksi_detailSumAggregateOutputType = {
    qty: number | null
    sub_total: Decimal | null
  }

  export type Transaksi_detailMinAggregateOutputType = {
    id: string | null
    transaksi_id: string | null
    barang_id: string | null
    qty: number | null
    sub_total: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Transaksi_detailMaxAggregateOutputType = {
    id: string | null
    transaksi_id: string | null
    barang_id: string | null
    qty: number | null
    sub_total: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Transaksi_detailCountAggregateOutputType = {
    id: number
    transaksi_id: number
    barang_id: number
    qty: number
    sub_total: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Transaksi_detailAvgAggregateInputType = {
    qty?: true
    sub_total?: true
  }

  export type Transaksi_detailSumAggregateInputType = {
    qty?: true
    sub_total?: true
  }

  export type Transaksi_detailMinAggregateInputType = {
    id?: true
    transaksi_id?: true
    barang_id?: true
    qty?: true
    sub_total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Transaksi_detailMaxAggregateInputType = {
    id?: true
    transaksi_id?: true
    barang_id?: true
    qty?: true
    sub_total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Transaksi_detailCountAggregateInputType = {
    id?: true
    transaksi_id?: true
    barang_id?: true
    qty?: true
    sub_total?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Transaksi_detailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaksi_detail to aggregate.
     */
    where?: transaksi_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksi_details to fetch.
     */
    orderBy?: transaksi_detailOrderByWithRelationInput | transaksi_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transaksi_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksi_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksi_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transaksi_details
    **/
    _count?: true | Transaksi_detailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Transaksi_detailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Transaksi_detailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Transaksi_detailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Transaksi_detailMaxAggregateInputType
  }

  export type GetTransaksi_detailAggregateType<T extends Transaksi_detailAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaksi_detail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaksi_detail[P]>
      : GetScalarType<T[P], AggregateTransaksi_detail[P]>
  }




  export type transaksi_detailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaksi_detailWhereInput
    orderBy?: transaksi_detailOrderByWithAggregationInput | transaksi_detailOrderByWithAggregationInput[]
    by: Transaksi_detailScalarFieldEnum[] | Transaksi_detailScalarFieldEnum
    having?: transaksi_detailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Transaksi_detailCountAggregateInputType | true
    _avg?: Transaksi_detailAvgAggregateInputType
    _sum?: Transaksi_detailSumAggregateInputType
    _min?: Transaksi_detailMinAggregateInputType
    _max?: Transaksi_detailMaxAggregateInputType
  }

  export type Transaksi_detailGroupByOutputType = {
    id: string
    transaksi_id: string
    barang_id: string
    qty: number
    sub_total: Decimal
    createdAt: Date | null
    updatedAt: Date | null
    _count: Transaksi_detailCountAggregateOutputType | null
    _avg: Transaksi_detailAvgAggregateOutputType | null
    _sum: Transaksi_detailSumAggregateOutputType | null
    _min: Transaksi_detailMinAggregateOutputType | null
    _max: Transaksi_detailMaxAggregateOutputType | null
  }

  type GetTransaksi_detailGroupByPayload<T extends transaksi_detailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Transaksi_detailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Transaksi_detailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Transaksi_detailGroupByOutputType[P]>
            : GetScalarType<T[P], Transaksi_detailGroupByOutputType[P]>
        }
      >
    >


  export type transaksi_detailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transaksi_id?: boolean
    barang_id?: boolean
    qty?: boolean
    sub_total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    barang?: boolean | barangDefaultArgs<ExtArgs>
    transaksi?: boolean | transaksiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaksi_detail"]>

  export type transaksi_detailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transaksi_id?: boolean
    barang_id?: boolean
    qty?: boolean
    sub_total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    barang?: boolean | barangDefaultArgs<ExtArgs>
    transaksi?: boolean | transaksiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaksi_detail"]>

  export type transaksi_detailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transaksi_id?: boolean
    barang_id?: boolean
    qty?: boolean
    sub_total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    barang?: boolean | barangDefaultArgs<ExtArgs>
    transaksi?: boolean | transaksiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaksi_detail"]>

  export type transaksi_detailSelectScalar = {
    id?: boolean
    transaksi_id?: boolean
    barang_id?: boolean
    qty?: boolean
    sub_total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type transaksi_detailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transaksi_id" | "barang_id" | "qty" | "sub_total" | "createdAt" | "updatedAt", ExtArgs["result"]["transaksi_detail"]>
  export type transaksi_detailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barang?: boolean | barangDefaultArgs<ExtArgs>
    transaksi?: boolean | transaksiDefaultArgs<ExtArgs>
  }
  export type transaksi_detailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barang?: boolean | barangDefaultArgs<ExtArgs>
    transaksi?: boolean | transaksiDefaultArgs<ExtArgs>
  }
  export type transaksi_detailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barang?: boolean | barangDefaultArgs<ExtArgs>
    transaksi?: boolean | transaksiDefaultArgs<ExtArgs>
  }

  export type $transaksi_detailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transaksi_detail"
    objects: {
      barang: Prisma.$barangPayload<ExtArgs>
      transaksi: Prisma.$transaksiPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transaksi_id: string
      barang_id: string
      qty: number
      sub_total: Prisma.Decimal
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["transaksi_detail"]>
    composites: {}
  }

  type transaksi_detailGetPayload<S extends boolean | null | undefined | transaksi_detailDefaultArgs> = $Result.GetResult<Prisma.$transaksi_detailPayload, S>

  type transaksi_detailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transaksi_detailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Transaksi_detailCountAggregateInputType | true
    }

  export interface transaksi_detailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transaksi_detail'], meta: { name: 'transaksi_detail' } }
    /**
     * Find zero or one Transaksi_detail that matches the filter.
     * @param {transaksi_detailFindUniqueArgs} args - Arguments to find a Transaksi_detail
     * @example
     * // Get one Transaksi_detail
     * const transaksi_detail = await prisma.transaksi_detail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transaksi_detailFindUniqueArgs>(args: SelectSubset<T, transaksi_detailFindUniqueArgs<ExtArgs>>): Prisma__transaksi_detailClient<$Result.GetResult<Prisma.$transaksi_detailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaksi_detail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transaksi_detailFindUniqueOrThrowArgs} args - Arguments to find a Transaksi_detail
     * @example
     * // Get one Transaksi_detail
     * const transaksi_detail = await prisma.transaksi_detail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transaksi_detailFindUniqueOrThrowArgs>(args: SelectSubset<T, transaksi_detailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transaksi_detailClient<$Result.GetResult<Prisma.$transaksi_detailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaksi_detail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksi_detailFindFirstArgs} args - Arguments to find a Transaksi_detail
     * @example
     * // Get one Transaksi_detail
     * const transaksi_detail = await prisma.transaksi_detail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transaksi_detailFindFirstArgs>(args?: SelectSubset<T, transaksi_detailFindFirstArgs<ExtArgs>>): Prisma__transaksi_detailClient<$Result.GetResult<Prisma.$transaksi_detailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaksi_detail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksi_detailFindFirstOrThrowArgs} args - Arguments to find a Transaksi_detail
     * @example
     * // Get one Transaksi_detail
     * const transaksi_detail = await prisma.transaksi_detail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transaksi_detailFindFirstOrThrowArgs>(args?: SelectSubset<T, transaksi_detailFindFirstOrThrowArgs<ExtArgs>>): Prisma__transaksi_detailClient<$Result.GetResult<Prisma.$transaksi_detailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transaksi_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksi_detailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transaksi_details
     * const transaksi_details = await prisma.transaksi_detail.findMany()
     * 
     * // Get first 10 Transaksi_details
     * const transaksi_details = await prisma.transaksi_detail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transaksi_detailWithIdOnly = await prisma.transaksi_detail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transaksi_detailFindManyArgs>(args?: SelectSubset<T, transaksi_detailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaksi_detailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaksi_detail.
     * @param {transaksi_detailCreateArgs} args - Arguments to create a Transaksi_detail.
     * @example
     * // Create one Transaksi_detail
     * const Transaksi_detail = await prisma.transaksi_detail.create({
     *   data: {
     *     // ... data to create a Transaksi_detail
     *   }
     * })
     * 
     */
    create<T extends transaksi_detailCreateArgs>(args: SelectSubset<T, transaksi_detailCreateArgs<ExtArgs>>): Prisma__transaksi_detailClient<$Result.GetResult<Prisma.$transaksi_detailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transaksi_details.
     * @param {transaksi_detailCreateManyArgs} args - Arguments to create many Transaksi_details.
     * @example
     * // Create many Transaksi_details
     * const transaksi_detail = await prisma.transaksi_detail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transaksi_detailCreateManyArgs>(args?: SelectSubset<T, transaksi_detailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transaksi_details and returns the data saved in the database.
     * @param {transaksi_detailCreateManyAndReturnArgs} args - Arguments to create many Transaksi_details.
     * @example
     * // Create many Transaksi_details
     * const transaksi_detail = await prisma.transaksi_detail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transaksi_details and only return the `id`
     * const transaksi_detailWithIdOnly = await prisma.transaksi_detail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends transaksi_detailCreateManyAndReturnArgs>(args?: SelectSubset<T, transaksi_detailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaksi_detailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaksi_detail.
     * @param {transaksi_detailDeleteArgs} args - Arguments to delete one Transaksi_detail.
     * @example
     * // Delete one Transaksi_detail
     * const Transaksi_detail = await prisma.transaksi_detail.delete({
     *   where: {
     *     // ... filter to delete one Transaksi_detail
     *   }
     * })
     * 
     */
    delete<T extends transaksi_detailDeleteArgs>(args: SelectSubset<T, transaksi_detailDeleteArgs<ExtArgs>>): Prisma__transaksi_detailClient<$Result.GetResult<Prisma.$transaksi_detailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaksi_detail.
     * @param {transaksi_detailUpdateArgs} args - Arguments to update one Transaksi_detail.
     * @example
     * // Update one Transaksi_detail
     * const transaksi_detail = await prisma.transaksi_detail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transaksi_detailUpdateArgs>(args: SelectSubset<T, transaksi_detailUpdateArgs<ExtArgs>>): Prisma__transaksi_detailClient<$Result.GetResult<Prisma.$transaksi_detailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transaksi_details.
     * @param {transaksi_detailDeleteManyArgs} args - Arguments to filter Transaksi_details to delete.
     * @example
     * // Delete a few Transaksi_details
     * const { count } = await prisma.transaksi_detail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transaksi_detailDeleteManyArgs>(args?: SelectSubset<T, transaksi_detailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transaksi_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksi_detailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transaksi_details
     * const transaksi_detail = await prisma.transaksi_detail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transaksi_detailUpdateManyArgs>(args: SelectSubset<T, transaksi_detailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transaksi_details and returns the data updated in the database.
     * @param {transaksi_detailUpdateManyAndReturnArgs} args - Arguments to update many Transaksi_details.
     * @example
     * // Update many Transaksi_details
     * const transaksi_detail = await prisma.transaksi_detail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transaksi_details and only return the `id`
     * const transaksi_detailWithIdOnly = await prisma.transaksi_detail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends transaksi_detailUpdateManyAndReturnArgs>(args: SelectSubset<T, transaksi_detailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaksi_detailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaksi_detail.
     * @param {transaksi_detailUpsertArgs} args - Arguments to update or create a Transaksi_detail.
     * @example
     * // Update or create a Transaksi_detail
     * const transaksi_detail = await prisma.transaksi_detail.upsert({
     *   create: {
     *     // ... data to create a Transaksi_detail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaksi_detail we want to update
     *   }
     * })
     */
    upsert<T extends transaksi_detailUpsertArgs>(args: SelectSubset<T, transaksi_detailUpsertArgs<ExtArgs>>): Prisma__transaksi_detailClient<$Result.GetResult<Prisma.$transaksi_detailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transaksi_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksi_detailCountArgs} args - Arguments to filter Transaksi_details to count.
     * @example
     * // Count the number of Transaksi_details
     * const count = await prisma.transaksi_detail.count({
     *   where: {
     *     // ... the filter for the Transaksi_details we want to count
     *   }
     * })
    **/
    count<T extends transaksi_detailCountArgs>(
      args?: Subset<T, transaksi_detailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Transaksi_detailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaksi_detail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Transaksi_detailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Transaksi_detailAggregateArgs>(args: Subset<T, Transaksi_detailAggregateArgs>): Prisma.PrismaPromise<GetTransaksi_detailAggregateType<T>>

    /**
     * Group by Transaksi_detail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksi_detailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transaksi_detailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transaksi_detailGroupByArgs['orderBy'] }
        : { orderBy?: transaksi_detailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transaksi_detailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransaksi_detailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transaksi_detail model
   */
  readonly fields: transaksi_detailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transaksi_detail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transaksi_detailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    barang<T extends barangDefaultArgs<ExtArgs> = {}>(args?: Subset<T, barangDefaultArgs<ExtArgs>>): Prisma__barangClient<$Result.GetResult<Prisma.$barangPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaksi<T extends transaksiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, transaksiDefaultArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transaksi_detail model
   */
  interface transaksi_detailFieldRefs {
    readonly id: FieldRef<"transaksi_detail", 'String'>
    readonly transaksi_id: FieldRef<"transaksi_detail", 'String'>
    readonly barang_id: FieldRef<"transaksi_detail", 'String'>
    readonly qty: FieldRef<"transaksi_detail", 'Int'>
    readonly sub_total: FieldRef<"transaksi_detail", 'Decimal'>
    readonly createdAt: FieldRef<"transaksi_detail", 'DateTime'>
    readonly updatedAt: FieldRef<"transaksi_detail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * transaksi_detail findUnique
   */
  export type transaksi_detailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_detail
     */
    select?: transaksi_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi_detail
     */
    omit?: transaksi_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksi_detailInclude<ExtArgs> | null
    /**
     * Filter, which transaksi_detail to fetch.
     */
    where: transaksi_detailWhereUniqueInput
  }

  /**
   * transaksi_detail findUniqueOrThrow
   */
  export type transaksi_detailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_detail
     */
    select?: transaksi_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi_detail
     */
    omit?: transaksi_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksi_detailInclude<ExtArgs> | null
    /**
     * Filter, which transaksi_detail to fetch.
     */
    where: transaksi_detailWhereUniqueInput
  }

  /**
   * transaksi_detail findFirst
   */
  export type transaksi_detailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_detail
     */
    select?: transaksi_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi_detail
     */
    omit?: transaksi_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksi_detailInclude<ExtArgs> | null
    /**
     * Filter, which transaksi_detail to fetch.
     */
    where?: transaksi_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksi_details to fetch.
     */
    orderBy?: transaksi_detailOrderByWithRelationInput | transaksi_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaksi_details.
     */
    cursor?: transaksi_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksi_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksi_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaksi_details.
     */
    distinct?: Transaksi_detailScalarFieldEnum | Transaksi_detailScalarFieldEnum[]
  }

  /**
   * transaksi_detail findFirstOrThrow
   */
  export type transaksi_detailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_detail
     */
    select?: transaksi_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi_detail
     */
    omit?: transaksi_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksi_detailInclude<ExtArgs> | null
    /**
     * Filter, which transaksi_detail to fetch.
     */
    where?: transaksi_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksi_details to fetch.
     */
    orderBy?: transaksi_detailOrderByWithRelationInput | transaksi_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaksi_details.
     */
    cursor?: transaksi_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksi_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksi_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaksi_details.
     */
    distinct?: Transaksi_detailScalarFieldEnum | Transaksi_detailScalarFieldEnum[]
  }

  /**
   * transaksi_detail findMany
   */
  export type transaksi_detailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_detail
     */
    select?: transaksi_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi_detail
     */
    omit?: transaksi_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksi_detailInclude<ExtArgs> | null
    /**
     * Filter, which transaksi_details to fetch.
     */
    where?: transaksi_detailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksi_details to fetch.
     */
    orderBy?: transaksi_detailOrderByWithRelationInput | transaksi_detailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transaksi_details.
     */
    cursor?: transaksi_detailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksi_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksi_details.
     */
    skip?: number
    distinct?: Transaksi_detailScalarFieldEnum | Transaksi_detailScalarFieldEnum[]
  }

  /**
   * transaksi_detail create
   */
  export type transaksi_detailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_detail
     */
    select?: transaksi_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi_detail
     */
    omit?: transaksi_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksi_detailInclude<ExtArgs> | null
    /**
     * The data needed to create a transaksi_detail.
     */
    data: XOR<transaksi_detailCreateInput, transaksi_detailUncheckedCreateInput>
  }

  /**
   * transaksi_detail createMany
   */
  export type transaksi_detailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transaksi_details.
     */
    data: transaksi_detailCreateManyInput | transaksi_detailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transaksi_detail createManyAndReturn
   */
  export type transaksi_detailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_detail
     */
    select?: transaksi_detailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi_detail
     */
    omit?: transaksi_detailOmit<ExtArgs> | null
    /**
     * The data used to create many transaksi_details.
     */
    data: transaksi_detailCreateManyInput | transaksi_detailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksi_detailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * transaksi_detail update
   */
  export type transaksi_detailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_detail
     */
    select?: transaksi_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi_detail
     */
    omit?: transaksi_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksi_detailInclude<ExtArgs> | null
    /**
     * The data needed to update a transaksi_detail.
     */
    data: XOR<transaksi_detailUpdateInput, transaksi_detailUncheckedUpdateInput>
    /**
     * Choose, which transaksi_detail to update.
     */
    where: transaksi_detailWhereUniqueInput
  }

  /**
   * transaksi_detail updateMany
   */
  export type transaksi_detailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transaksi_details.
     */
    data: XOR<transaksi_detailUpdateManyMutationInput, transaksi_detailUncheckedUpdateManyInput>
    /**
     * Filter which transaksi_details to update
     */
    where?: transaksi_detailWhereInput
    /**
     * Limit how many transaksi_details to update.
     */
    limit?: number
  }

  /**
   * transaksi_detail updateManyAndReturn
   */
  export type transaksi_detailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_detail
     */
    select?: transaksi_detailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi_detail
     */
    omit?: transaksi_detailOmit<ExtArgs> | null
    /**
     * The data used to update transaksi_details.
     */
    data: XOR<transaksi_detailUpdateManyMutationInput, transaksi_detailUncheckedUpdateManyInput>
    /**
     * Filter which transaksi_details to update
     */
    where?: transaksi_detailWhereInput
    /**
     * Limit how many transaksi_details to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksi_detailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * transaksi_detail upsert
   */
  export type transaksi_detailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_detail
     */
    select?: transaksi_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi_detail
     */
    omit?: transaksi_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksi_detailInclude<ExtArgs> | null
    /**
     * The filter to search for the transaksi_detail to update in case it exists.
     */
    where: transaksi_detailWhereUniqueInput
    /**
     * In case the transaksi_detail found by the `where` argument doesn't exist, create a new transaksi_detail with this data.
     */
    create: XOR<transaksi_detailCreateInput, transaksi_detailUncheckedCreateInput>
    /**
     * In case the transaksi_detail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transaksi_detailUpdateInput, transaksi_detailUncheckedUpdateInput>
  }

  /**
   * transaksi_detail delete
   */
  export type transaksi_detailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_detail
     */
    select?: transaksi_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi_detail
     */
    omit?: transaksi_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksi_detailInclude<ExtArgs> | null
    /**
     * Filter which transaksi_detail to delete.
     */
    where: transaksi_detailWhereUniqueInput
  }

  /**
   * transaksi_detail deleteMany
   */
  export type transaksi_detailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaksi_details to delete
     */
    where?: transaksi_detailWhereInput
    /**
     * Limit how many transaksi_details to delete.
     */
    limit?: number
  }

  /**
   * transaksi_detail without action
   */
  export type transaksi_detailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_detail
     */
    select?: transaksi_detailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi_detail
     */
    omit?: transaksi_detailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksi_detailInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    point: number | null
  }

  export type UsersSumAggregateOutputType = {
    point: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    status_id: string | null
    member_id: string | null
    vehicle_year_id: string | null
    vehicle_merk_id: string | null
    vehicle_type_id: string | null
    no_police: string | null
    name: string | null
    point: number | null
    address: string | null
    phone_number: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    status_id: string | null
    member_id: string | null
    vehicle_year_id: string | null
    vehicle_merk_id: string | null
    vehicle_type_id: string | null
    no_police: string | null
    name: string | null
    point: number | null
    address: string | null
    phone_number: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    status_id: number
    member_id: number
    vehicle_year_id: number
    vehicle_merk_id: number
    vehicle_type_id: number
    no_police: number
    name: number
    point: number
    address: number
    phone_number: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    point?: true
  }

  export type UsersSumAggregateInputType = {
    point?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    status_id?: true
    member_id?: true
    vehicle_year_id?: true
    vehicle_merk_id?: true
    vehicle_type_id?: true
    no_police?: true
    name?: true
    point?: true
    address?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    status_id?: true
    member_id?: true
    vehicle_year_id?: true
    vehicle_merk_id?: true
    vehicle_type_id?: true
    no_police?: true
    name?: true
    point?: true
    address?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    status_id?: true
    member_id?: true
    vehicle_year_id?: true
    vehicle_merk_id?: true
    vehicle_type_id?: true
    no_police?: true
    name?: true
    point?: true
    address?: true
    phone_number?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    status_id: string
    member_id: string
    vehicle_year_id: string
    vehicle_merk_id: string
    vehicle_type_id: string
    no_police: string
    name: string | null
    point: number | null
    address: string | null
    phone_number: string
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status_id?: boolean
    member_id?: boolean
    vehicle_year_id?: boolean
    vehicle_merk_id?: boolean
    vehicle_type_id?: boolean
    no_police?: boolean
    name?: boolean
    point?: boolean
    address?: boolean
    phone_number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    transaksi?: boolean | users$transaksiArgs<ExtArgs>
    member?: boolean | memberDefaultArgs<ExtArgs>
    status?: boolean | statusDefaultArgs<ExtArgs>
    vehicle_merk?: boolean | vehicle_merkDefaultArgs<ExtArgs>
    vehicle_year?: boolean | vehicle_yearDefaultArgs<ExtArgs>
    vehicle_type?: boolean | vehicle_typeDefaultArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status_id?: boolean
    member_id?: boolean
    vehicle_year_id?: boolean
    vehicle_merk_id?: boolean
    vehicle_type_id?: boolean
    no_police?: boolean
    name?: boolean
    point?: boolean
    address?: boolean
    phone_number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    member?: boolean | memberDefaultArgs<ExtArgs>
    status?: boolean | statusDefaultArgs<ExtArgs>
    vehicle_merk?: boolean | vehicle_merkDefaultArgs<ExtArgs>
    vehicle_year?: boolean | vehicle_yearDefaultArgs<ExtArgs>
    vehicle_type?: boolean | vehicle_typeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status_id?: boolean
    member_id?: boolean
    vehicle_year_id?: boolean
    vehicle_merk_id?: boolean
    vehicle_type_id?: boolean
    no_police?: boolean
    name?: boolean
    point?: boolean
    address?: boolean
    phone_number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    member?: boolean | memberDefaultArgs<ExtArgs>
    status?: boolean | statusDefaultArgs<ExtArgs>
    vehicle_merk?: boolean | vehicle_merkDefaultArgs<ExtArgs>
    vehicle_year?: boolean | vehicle_yearDefaultArgs<ExtArgs>
    vehicle_type?: boolean | vehicle_typeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    status_id?: boolean
    member_id?: boolean
    vehicle_year_id?: boolean
    vehicle_merk_id?: boolean
    vehicle_type_id?: boolean
    no_police?: boolean
    name?: boolean
    point?: boolean
    address?: boolean
    phone_number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status_id" | "member_id" | "vehicle_year_id" | "vehicle_merk_id" | "vehicle_type_id" | "no_police" | "name" | "point" | "address" | "phone_number" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaksi?: boolean | users$transaksiArgs<ExtArgs>
    member?: boolean | memberDefaultArgs<ExtArgs>
    status?: boolean | statusDefaultArgs<ExtArgs>
    vehicle_merk?: boolean | vehicle_merkDefaultArgs<ExtArgs>
    vehicle_year?: boolean | vehicle_yearDefaultArgs<ExtArgs>
    vehicle_type?: boolean | vehicle_typeDefaultArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | memberDefaultArgs<ExtArgs>
    status?: boolean | statusDefaultArgs<ExtArgs>
    vehicle_merk?: boolean | vehicle_merkDefaultArgs<ExtArgs>
    vehicle_year?: boolean | vehicle_yearDefaultArgs<ExtArgs>
    vehicle_type?: boolean | vehicle_typeDefaultArgs<ExtArgs>
  }
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | memberDefaultArgs<ExtArgs>
    status?: boolean | statusDefaultArgs<ExtArgs>
    vehicle_merk?: boolean | vehicle_merkDefaultArgs<ExtArgs>
    vehicle_year?: boolean | vehicle_yearDefaultArgs<ExtArgs>
    vehicle_type?: boolean | vehicle_typeDefaultArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      transaksi: Prisma.$transaksiPayload<ExtArgs>[]
      member: Prisma.$memberPayload<ExtArgs>
      status: Prisma.$statusPayload<ExtArgs>
      vehicle_merk: Prisma.$vehicle_merkPayload<ExtArgs>
      vehicle_year: Prisma.$vehicle_yearPayload<ExtArgs>
      vehicle_type: Prisma.$vehicle_typePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status_id: string
      member_id: string
      vehicle_year_id: string
      vehicle_merk_id: string
      vehicle_type_id: string
      no_police: string
      name: string | null
      point: number | null
      address: string | null
      phone_number: string
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaksi<T extends users$transaksiArgs<ExtArgs> = {}>(args?: Subset<T, users$transaksiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    member<T extends memberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, memberDefaultArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    status<T extends statusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, statusDefaultArgs<ExtArgs>>): Prisma__statusClient<$Result.GetResult<Prisma.$statusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vehicle_merk<T extends vehicle_merkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_merkDefaultArgs<ExtArgs>>): Prisma__vehicle_merkClient<$Result.GetResult<Prisma.$vehicle_merkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vehicle_year<T extends vehicle_yearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_yearDefaultArgs<ExtArgs>>): Prisma__vehicle_yearClient<$Result.GetResult<Prisma.$vehicle_yearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vehicle_type<T extends vehicle_typeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_typeDefaultArgs<ExtArgs>>): Prisma__vehicle_typeClient<$Result.GetResult<Prisma.$vehicle_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly status_id: FieldRef<"users", 'String'>
    readonly member_id: FieldRef<"users", 'String'>
    readonly vehicle_year_id: FieldRef<"users", 'String'>
    readonly vehicle_merk_id: FieldRef<"users", 'String'>
    readonly vehicle_type_id: FieldRef<"users", 'String'>
    readonly no_police: FieldRef<"users", 'String'>
    readonly name: FieldRef<"users", 'String'>
    readonly point: FieldRef<"users", 'Int'>
    readonly address: FieldRef<"users", 'String'>
    readonly phone_number: FieldRef<"users", 'String'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly updatedAt: FieldRef<"users", 'DateTime'>
    readonly deletedAt: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.transaksi
   */
  export type users$transaksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi
     */
    omit?: transaksiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    where?: transaksiWhereInput
    orderBy?: transaksiOrderByWithRelationInput | transaksiOrderByWithRelationInput[]
    cursor?: transaksiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransaksiScalarFieldEnum | TransaksiScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model vehicle_category
   */

  export type AggregateVehicle_category = {
    _count: Vehicle_categoryCountAggregateOutputType | null
    _min: Vehicle_categoryMinAggregateOutputType | null
    _max: Vehicle_categoryMaxAggregateOutputType | null
  }

  export type Vehicle_categoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_categoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_categoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Vehicle_categoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_categoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_categoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Vehicle_categoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_category to aggregate.
     */
    where?: vehicle_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_categories to fetch.
     */
    orderBy?: vehicle_categoryOrderByWithRelationInput | vehicle_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehicle_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicle_categories
    **/
    _count?: true | Vehicle_categoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vehicle_categoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vehicle_categoryMaxAggregateInputType
  }

  export type GetVehicle_categoryAggregateType<T extends Vehicle_categoryAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle_category]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle_category[P]>
      : GetScalarType<T[P], AggregateVehicle_category[P]>
  }




  export type vehicle_categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_categoryWhereInput
    orderBy?: vehicle_categoryOrderByWithAggregationInput | vehicle_categoryOrderByWithAggregationInput[]
    by: Vehicle_categoryScalarFieldEnum[] | Vehicle_categoryScalarFieldEnum
    having?: vehicle_categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vehicle_categoryCountAggregateInputType | true
    _min?: Vehicle_categoryMinAggregateInputType
    _max?: Vehicle_categoryMaxAggregateInputType
  }

  export type Vehicle_categoryGroupByOutputType = {
    id: string
    name: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: Vehicle_categoryCountAggregateOutputType | null
    _min: Vehicle_categoryMinAggregateOutputType | null
    _max: Vehicle_categoryMaxAggregateOutputType | null
  }

  type GetVehicle_categoryGroupByPayload<T extends vehicle_categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Vehicle_categoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Vehicle_categoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Vehicle_categoryGroupByOutputType[P]>
            : GetScalarType<T[P], Vehicle_categoryGroupByOutputType[P]>
        }
      >
    >


  export type vehicle_categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    barang?: boolean | vehicle_category$barangArgs<ExtArgs>
    vehicle_type?: boolean | vehicle_category$vehicle_typeArgs<ExtArgs>
    _count?: boolean | Vehicle_categoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle_category"]>

  export type vehicle_categorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vehicle_category"]>

  export type vehicle_categorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vehicle_category"]>

  export type vehicle_categorySelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type vehicle_categoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle_category"]>
  export type vehicle_categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barang?: boolean | vehicle_category$barangArgs<ExtArgs>
    vehicle_type?: boolean | vehicle_category$vehicle_typeArgs<ExtArgs>
    _count?: boolean | Vehicle_categoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type vehicle_categoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type vehicle_categoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $vehicle_categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicle_category"
    objects: {
      barang: Prisma.$barangPayload<ExtArgs>[]
      vehicle_type: Prisma.$vehicle_typePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["vehicle_category"]>
    composites: {}
  }

  type vehicle_categoryGetPayload<S extends boolean | null | undefined | vehicle_categoryDefaultArgs> = $Result.GetResult<Prisma.$vehicle_categoryPayload, S>

  type vehicle_categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vehicle_categoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Vehicle_categoryCountAggregateInputType | true
    }

  export interface vehicle_categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicle_category'], meta: { name: 'vehicle_category' } }
    /**
     * Find zero or one Vehicle_category that matches the filter.
     * @param {vehicle_categoryFindUniqueArgs} args - Arguments to find a Vehicle_category
     * @example
     * // Get one Vehicle_category
     * const vehicle_category = await prisma.vehicle_category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehicle_categoryFindUniqueArgs>(args: SelectSubset<T, vehicle_categoryFindUniqueArgs<ExtArgs>>): Prisma__vehicle_categoryClient<$Result.GetResult<Prisma.$vehicle_categoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle_category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vehicle_categoryFindUniqueOrThrowArgs} args - Arguments to find a Vehicle_category
     * @example
     * // Get one Vehicle_category
     * const vehicle_category = await prisma.vehicle_category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehicle_categoryFindUniqueOrThrowArgs>(args: SelectSubset<T, vehicle_categoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehicle_categoryClient<$Result.GetResult<Prisma.$vehicle_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_categoryFindFirstArgs} args - Arguments to find a Vehicle_category
     * @example
     * // Get one Vehicle_category
     * const vehicle_category = await prisma.vehicle_category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehicle_categoryFindFirstArgs>(args?: SelectSubset<T, vehicle_categoryFindFirstArgs<ExtArgs>>): Prisma__vehicle_categoryClient<$Result.GetResult<Prisma.$vehicle_categoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_categoryFindFirstOrThrowArgs} args - Arguments to find a Vehicle_category
     * @example
     * // Get one Vehicle_category
     * const vehicle_category = await prisma.vehicle_category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehicle_categoryFindFirstOrThrowArgs>(args?: SelectSubset<T, vehicle_categoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehicle_categoryClient<$Result.GetResult<Prisma.$vehicle_categoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicle_categories
     * const vehicle_categories = await prisma.vehicle_category.findMany()
     * 
     * // Get first 10 Vehicle_categories
     * const vehicle_categories = await prisma.vehicle_category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicle_categoryWithIdOnly = await prisma.vehicle_category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehicle_categoryFindManyArgs>(args?: SelectSubset<T, vehicle_categoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle_category.
     * @param {vehicle_categoryCreateArgs} args - Arguments to create a Vehicle_category.
     * @example
     * // Create one Vehicle_category
     * const Vehicle_category = await prisma.vehicle_category.create({
     *   data: {
     *     // ... data to create a Vehicle_category
     *   }
     * })
     * 
     */
    create<T extends vehicle_categoryCreateArgs>(args: SelectSubset<T, vehicle_categoryCreateArgs<ExtArgs>>): Prisma__vehicle_categoryClient<$Result.GetResult<Prisma.$vehicle_categoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicle_categories.
     * @param {vehicle_categoryCreateManyArgs} args - Arguments to create many Vehicle_categories.
     * @example
     * // Create many Vehicle_categories
     * const vehicle_category = await prisma.vehicle_category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehicle_categoryCreateManyArgs>(args?: SelectSubset<T, vehicle_categoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicle_categories and returns the data saved in the database.
     * @param {vehicle_categoryCreateManyAndReturnArgs} args - Arguments to create many Vehicle_categories.
     * @example
     * // Create many Vehicle_categories
     * const vehicle_category = await prisma.vehicle_category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicle_categories and only return the `id`
     * const vehicle_categoryWithIdOnly = await prisma.vehicle_category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends vehicle_categoryCreateManyAndReturnArgs>(args?: SelectSubset<T, vehicle_categoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_categoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vehicle_category.
     * @param {vehicle_categoryDeleteArgs} args - Arguments to delete one Vehicle_category.
     * @example
     * // Delete one Vehicle_category
     * const Vehicle_category = await prisma.vehicle_category.delete({
     *   where: {
     *     // ... filter to delete one Vehicle_category
     *   }
     * })
     * 
     */
    delete<T extends vehicle_categoryDeleteArgs>(args: SelectSubset<T, vehicle_categoryDeleteArgs<ExtArgs>>): Prisma__vehicle_categoryClient<$Result.GetResult<Prisma.$vehicle_categoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle_category.
     * @param {vehicle_categoryUpdateArgs} args - Arguments to update one Vehicle_category.
     * @example
     * // Update one Vehicle_category
     * const vehicle_category = await prisma.vehicle_category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehicle_categoryUpdateArgs>(args: SelectSubset<T, vehicle_categoryUpdateArgs<ExtArgs>>): Prisma__vehicle_categoryClient<$Result.GetResult<Prisma.$vehicle_categoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicle_categories.
     * @param {vehicle_categoryDeleteManyArgs} args - Arguments to filter Vehicle_categories to delete.
     * @example
     * // Delete a few Vehicle_categories
     * const { count } = await prisma.vehicle_category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehicle_categoryDeleteManyArgs>(args?: SelectSubset<T, vehicle_categoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicle_categories
     * const vehicle_category = await prisma.vehicle_category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehicle_categoryUpdateManyArgs>(args: SelectSubset<T, vehicle_categoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_categories and returns the data updated in the database.
     * @param {vehicle_categoryUpdateManyAndReturnArgs} args - Arguments to update many Vehicle_categories.
     * @example
     * // Update many Vehicle_categories
     * const vehicle_category = await prisma.vehicle_category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vehicle_categories and only return the `id`
     * const vehicle_categoryWithIdOnly = await prisma.vehicle_category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends vehicle_categoryUpdateManyAndReturnArgs>(args: SelectSubset<T, vehicle_categoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_categoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vehicle_category.
     * @param {vehicle_categoryUpsertArgs} args - Arguments to update or create a Vehicle_category.
     * @example
     * // Update or create a Vehicle_category
     * const vehicle_category = await prisma.vehicle_category.upsert({
     *   create: {
     *     // ... data to create a Vehicle_category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle_category we want to update
     *   }
     * })
     */
    upsert<T extends vehicle_categoryUpsertArgs>(args: SelectSubset<T, vehicle_categoryUpsertArgs<ExtArgs>>): Prisma__vehicle_categoryClient<$Result.GetResult<Prisma.$vehicle_categoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vehicle_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_categoryCountArgs} args - Arguments to filter Vehicle_categories to count.
     * @example
     * // Count the number of Vehicle_categories
     * const count = await prisma.vehicle_category.count({
     *   where: {
     *     // ... the filter for the Vehicle_categories we want to count
     *   }
     * })
    **/
    count<T extends vehicle_categoryCountArgs>(
      args?: Subset<T, vehicle_categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vehicle_categoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vehicle_categoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vehicle_categoryAggregateArgs>(args: Subset<T, Vehicle_categoryAggregateArgs>): Prisma.PrismaPromise<GetVehicle_categoryAggregateType<T>>

    /**
     * Group by Vehicle_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehicle_categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehicle_categoryGroupByArgs['orderBy'] }
        : { orderBy?: vehicle_categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehicle_categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicle_categoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicle_category model
   */
  readonly fields: vehicle_categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicle_category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehicle_categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    barang<T extends vehicle_category$barangArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_category$barangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$barangPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicle_type<T extends vehicle_category$vehicle_typeArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_category$vehicle_typeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicle_category model
   */
  interface vehicle_categoryFieldRefs {
    readonly id: FieldRef<"vehicle_category", 'String'>
    readonly name: FieldRef<"vehicle_category", 'String'>
    readonly createdAt: FieldRef<"vehicle_category", 'DateTime'>
    readonly updatedAt: FieldRef<"vehicle_category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * vehicle_category findUnique
   */
  export type vehicle_categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_category
     */
    select?: vehicle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_category
     */
    omit?: vehicle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_categoryInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_category to fetch.
     */
    where: vehicle_categoryWhereUniqueInput
  }

  /**
   * vehicle_category findUniqueOrThrow
   */
  export type vehicle_categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_category
     */
    select?: vehicle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_category
     */
    omit?: vehicle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_categoryInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_category to fetch.
     */
    where: vehicle_categoryWhereUniqueInput
  }

  /**
   * vehicle_category findFirst
   */
  export type vehicle_categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_category
     */
    select?: vehicle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_category
     */
    omit?: vehicle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_categoryInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_category to fetch.
     */
    where?: vehicle_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_categories to fetch.
     */
    orderBy?: vehicle_categoryOrderByWithRelationInput | vehicle_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_categories.
     */
    cursor?: vehicle_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_categories.
     */
    distinct?: Vehicle_categoryScalarFieldEnum | Vehicle_categoryScalarFieldEnum[]
  }

  /**
   * vehicle_category findFirstOrThrow
   */
  export type vehicle_categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_category
     */
    select?: vehicle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_category
     */
    omit?: vehicle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_categoryInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_category to fetch.
     */
    where?: vehicle_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_categories to fetch.
     */
    orderBy?: vehicle_categoryOrderByWithRelationInput | vehicle_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_categories.
     */
    cursor?: vehicle_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_categories.
     */
    distinct?: Vehicle_categoryScalarFieldEnum | Vehicle_categoryScalarFieldEnum[]
  }

  /**
   * vehicle_category findMany
   */
  export type vehicle_categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_category
     */
    select?: vehicle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_category
     */
    omit?: vehicle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_categoryInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_categories to fetch.
     */
    where?: vehicle_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_categories to fetch.
     */
    orderBy?: vehicle_categoryOrderByWithRelationInput | vehicle_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicle_categories.
     */
    cursor?: vehicle_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_categories.
     */
    skip?: number
    distinct?: Vehicle_categoryScalarFieldEnum | Vehicle_categoryScalarFieldEnum[]
  }

  /**
   * vehicle_category create
   */
  export type vehicle_categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_category
     */
    select?: vehicle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_category
     */
    omit?: vehicle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a vehicle_category.
     */
    data: XOR<vehicle_categoryCreateInput, vehicle_categoryUncheckedCreateInput>
  }

  /**
   * vehicle_category createMany
   */
  export type vehicle_categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicle_categories.
     */
    data: vehicle_categoryCreateManyInput | vehicle_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * vehicle_category createManyAndReturn
   */
  export type vehicle_categoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_category
     */
    select?: vehicle_categorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_category
     */
    omit?: vehicle_categoryOmit<ExtArgs> | null
    /**
     * The data used to create many vehicle_categories.
     */
    data: vehicle_categoryCreateManyInput | vehicle_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * vehicle_category update
   */
  export type vehicle_categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_category
     */
    select?: vehicle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_category
     */
    omit?: vehicle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a vehicle_category.
     */
    data: XOR<vehicle_categoryUpdateInput, vehicle_categoryUncheckedUpdateInput>
    /**
     * Choose, which vehicle_category to update.
     */
    where: vehicle_categoryWhereUniqueInput
  }

  /**
   * vehicle_category updateMany
   */
  export type vehicle_categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicle_categories.
     */
    data: XOR<vehicle_categoryUpdateManyMutationInput, vehicle_categoryUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_categories to update
     */
    where?: vehicle_categoryWhereInput
    /**
     * Limit how many vehicle_categories to update.
     */
    limit?: number
  }

  /**
   * vehicle_category updateManyAndReturn
   */
  export type vehicle_categoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_category
     */
    select?: vehicle_categorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_category
     */
    omit?: vehicle_categoryOmit<ExtArgs> | null
    /**
     * The data used to update vehicle_categories.
     */
    data: XOR<vehicle_categoryUpdateManyMutationInput, vehicle_categoryUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_categories to update
     */
    where?: vehicle_categoryWhereInput
    /**
     * Limit how many vehicle_categories to update.
     */
    limit?: number
  }

  /**
   * vehicle_category upsert
   */
  export type vehicle_categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_category
     */
    select?: vehicle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_category
     */
    omit?: vehicle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the vehicle_category to update in case it exists.
     */
    where: vehicle_categoryWhereUniqueInput
    /**
     * In case the vehicle_category found by the `where` argument doesn't exist, create a new vehicle_category with this data.
     */
    create: XOR<vehicle_categoryCreateInput, vehicle_categoryUncheckedCreateInput>
    /**
     * In case the vehicle_category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehicle_categoryUpdateInput, vehicle_categoryUncheckedUpdateInput>
  }

  /**
   * vehicle_category delete
   */
  export type vehicle_categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_category
     */
    select?: vehicle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_category
     */
    omit?: vehicle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_categoryInclude<ExtArgs> | null
    /**
     * Filter which vehicle_category to delete.
     */
    where: vehicle_categoryWhereUniqueInput
  }

  /**
   * vehicle_category deleteMany
   */
  export type vehicle_categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_categories to delete
     */
    where?: vehicle_categoryWhereInput
    /**
     * Limit how many vehicle_categories to delete.
     */
    limit?: number
  }

  /**
   * vehicle_category.barang
   */
  export type vehicle_category$barangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the barang
     */
    select?: barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the barang
     */
    omit?: barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: barangInclude<ExtArgs> | null
    where?: barangWhereInput
    orderBy?: barangOrderByWithRelationInput | barangOrderByWithRelationInput[]
    cursor?: barangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarangScalarFieldEnum | BarangScalarFieldEnum[]
  }

  /**
   * vehicle_category.vehicle_type
   */
  export type vehicle_category$vehicle_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_type
     */
    select?: vehicle_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_type
     */
    omit?: vehicle_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typeInclude<ExtArgs> | null
    where?: vehicle_typeWhereInput
    orderBy?: vehicle_typeOrderByWithRelationInput | vehicle_typeOrderByWithRelationInput[]
    cursor?: vehicle_typeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Vehicle_typeScalarFieldEnum | Vehicle_typeScalarFieldEnum[]
  }

  /**
   * vehicle_category without action
   */
  export type vehicle_categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_category
     */
    select?: vehicle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_category
     */
    omit?: vehicle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_categoryInclude<ExtArgs> | null
  }


  /**
   * Model vehicle_merk
   */

  export type AggregateVehicle_merk = {
    _count: Vehicle_merkCountAggregateOutputType | null
    _min: Vehicle_merkMinAggregateOutputType | null
    _max: Vehicle_merkMaxAggregateOutputType | null
  }

  export type Vehicle_merkMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_merkMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_merkCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Vehicle_merkMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_merkMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_merkCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Vehicle_merkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_merk to aggregate.
     */
    where?: vehicle_merkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_merks to fetch.
     */
    orderBy?: vehicle_merkOrderByWithRelationInput | vehicle_merkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehicle_merkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_merks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_merks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicle_merks
    **/
    _count?: true | Vehicle_merkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vehicle_merkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vehicle_merkMaxAggregateInputType
  }

  export type GetVehicle_merkAggregateType<T extends Vehicle_merkAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle_merk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle_merk[P]>
      : GetScalarType<T[P], AggregateVehicle_merk[P]>
  }




  export type vehicle_merkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_merkWhereInput
    orderBy?: vehicle_merkOrderByWithAggregationInput | vehicle_merkOrderByWithAggregationInput[]
    by: Vehicle_merkScalarFieldEnum[] | Vehicle_merkScalarFieldEnum
    having?: vehicle_merkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vehicle_merkCountAggregateInputType | true
    _min?: Vehicle_merkMinAggregateInputType
    _max?: Vehicle_merkMaxAggregateInputType
  }

  export type Vehicle_merkGroupByOutputType = {
    id: string
    name: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: Vehicle_merkCountAggregateOutputType | null
    _min: Vehicle_merkMinAggregateOutputType | null
    _max: Vehicle_merkMaxAggregateOutputType | null
  }

  type GetVehicle_merkGroupByPayload<T extends vehicle_merkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Vehicle_merkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Vehicle_merkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Vehicle_merkGroupByOutputType[P]>
            : GetScalarType<T[P], Vehicle_merkGroupByOutputType[P]>
        }
      >
    >


  export type vehicle_merkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | vehicle_merk$usersArgs<ExtArgs>
    _count?: boolean | Vehicle_merkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle_merk"]>

  export type vehicle_merkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vehicle_merk"]>

  export type vehicle_merkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vehicle_merk"]>

  export type vehicle_merkSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type vehicle_merkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle_merk"]>
  export type vehicle_merkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | vehicle_merk$usersArgs<ExtArgs>
    _count?: boolean | Vehicle_merkCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type vehicle_merkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type vehicle_merkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $vehicle_merkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicle_merk"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["vehicle_merk"]>
    composites: {}
  }

  type vehicle_merkGetPayload<S extends boolean | null | undefined | vehicle_merkDefaultArgs> = $Result.GetResult<Prisma.$vehicle_merkPayload, S>

  type vehicle_merkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vehicle_merkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Vehicle_merkCountAggregateInputType | true
    }

  export interface vehicle_merkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicle_merk'], meta: { name: 'vehicle_merk' } }
    /**
     * Find zero or one Vehicle_merk that matches the filter.
     * @param {vehicle_merkFindUniqueArgs} args - Arguments to find a Vehicle_merk
     * @example
     * // Get one Vehicle_merk
     * const vehicle_merk = await prisma.vehicle_merk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehicle_merkFindUniqueArgs>(args: SelectSubset<T, vehicle_merkFindUniqueArgs<ExtArgs>>): Prisma__vehicle_merkClient<$Result.GetResult<Prisma.$vehicle_merkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle_merk that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vehicle_merkFindUniqueOrThrowArgs} args - Arguments to find a Vehicle_merk
     * @example
     * // Get one Vehicle_merk
     * const vehicle_merk = await prisma.vehicle_merk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehicle_merkFindUniqueOrThrowArgs>(args: SelectSubset<T, vehicle_merkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehicle_merkClient<$Result.GetResult<Prisma.$vehicle_merkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_merk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_merkFindFirstArgs} args - Arguments to find a Vehicle_merk
     * @example
     * // Get one Vehicle_merk
     * const vehicle_merk = await prisma.vehicle_merk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehicle_merkFindFirstArgs>(args?: SelectSubset<T, vehicle_merkFindFirstArgs<ExtArgs>>): Prisma__vehicle_merkClient<$Result.GetResult<Prisma.$vehicle_merkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_merk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_merkFindFirstOrThrowArgs} args - Arguments to find a Vehicle_merk
     * @example
     * // Get one Vehicle_merk
     * const vehicle_merk = await prisma.vehicle_merk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehicle_merkFindFirstOrThrowArgs>(args?: SelectSubset<T, vehicle_merkFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehicle_merkClient<$Result.GetResult<Prisma.$vehicle_merkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_merks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_merkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicle_merks
     * const vehicle_merks = await prisma.vehicle_merk.findMany()
     * 
     * // Get first 10 Vehicle_merks
     * const vehicle_merks = await prisma.vehicle_merk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicle_merkWithIdOnly = await prisma.vehicle_merk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehicle_merkFindManyArgs>(args?: SelectSubset<T, vehicle_merkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_merkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle_merk.
     * @param {vehicle_merkCreateArgs} args - Arguments to create a Vehicle_merk.
     * @example
     * // Create one Vehicle_merk
     * const Vehicle_merk = await prisma.vehicle_merk.create({
     *   data: {
     *     // ... data to create a Vehicle_merk
     *   }
     * })
     * 
     */
    create<T extends vehicle_merkCreateArgs>(args: SelectSubset<T, vehicle_merkCreateArgs<ExtArgs>>): Prisma__vehicle_merkClient<$Result.GetResult<Prisma.$vehicle_merkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicle_merks.
     * @param {vehicle_merkCreateManyArgs} args - Arguments to create many Vehicle_merks.
     * @example
     * // Create many Vehicle_merks
     * const vehicle_merk = await prisma.vehicle_merk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehicle_merkCreateManyArgs>(args?: SelectSubset<T, vehicle_merkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicle_merks and returns the data saved in the database.
     * @param {vehicle_merkCreateManyAndReturnArgs} args - Arguments to create many Vehicle_merks.
     * @example
     * // Create many Vehicle_merks
     * const vehicle_merk = await prisma.vehicle_merk.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicle_merks and only return the `id`
     * const vehicle_merkWithIdOnly = await prisma.vehicle_merk.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends vehicle_merkCreateManyAndReturnArgs>(args?: SelectSubset<T, vehicle_merkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_merkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vehicle_merk.
     * @param {vehicle_merkDeleteArgs} args - Arguments to delete one Vehicle_merk.
     * @example
     * // Delete one Vehicle_merk
     * const Vehicle_merk = await prisma.vehicle_merk.delete({
     *   where: {
     *     // ... filter to delete one Vehicle_merk
     *   }
     * })
     * 
     */
    delete<T extends vehicle_merkDeleteArgs>(args: SelectSubset<T, vehicle_merkDeleteArgs<ExtArgs>>): Prisma__vehicle_merkClient<$Result.GetResult<Prisma.$vehicle_merkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle_merk.
     * @param {vehicle_merkUpdateArgs} args - Arguments to update one Vehicle_merk.
     * @example
     * // Update one Vehicle_merk
     * const vehicle_merk = await prisma.vehicle_merk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehicle_merkUpdateArgs>(args: SelectSubset<T, vehicle_merkUpdateArgs<ExtArgs>>): Prisma__vehicle_merkClient<$Result.GetResult<Prisma.$vehicle_merkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicle_merks.
     * @param {vehicle_merkDeleteManyArgs} args - Arguments to filter Vehicle_merks to delete.
     * @example
     * // Delete a few Vehicle_merks
     * const { count } = await prisma.vehicle_merk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehicle_merkDeleteManyArgs>(args?: SelectSubset<T, vehicle_merkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_merks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_merkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicle_merks
     * const vehicle_merk = await prisma.vehicle_merk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehicle_merkUpdateManyArgs>(args: SelectSubset<T, vehicle_merkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_merks and returns the data updated in the database.
     * @param {vehicle_merkUpdateManyAndReturnArgs} args - Arguments to update many Vehicle_merks.
     * @example
     * // Update many Vehicle_merks
     * const vehicle_merk = await prisma.vehicle_merk.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vehicle_merks and only return the `id`
     * const vehicle_merkWithIdOnly = await prisma.vehicle_merk.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends vehicle_merkUpdateManyAndReturnArgs>(args: SelectSubset<T, vehicle_merkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_merkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vehicle_merk.
     * @param {vehicle_merkUpsertArgs} args - Arguments to update or create a Vehicle_merk.
     * @example
     * // Update or create a Vehicle_merk
     * const vehicle_merk = await prisma.vehicle_merk.upsert({
     *   create: {
     *     // ... data to create a Vehicle_merk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle_merk we want to update
     *   }
     * })
     */
    upsert<T extends vehicle_merkUpsertArgs>(args: SelectSubset<T, vehicle_merkUpsertArgs<ExtArgs>>): Prisma__vehicle_merkClient<$Result.GetResult<Prisma.$vehicle_merkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vehicle_merks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_merkCountArgs} args - Arguments to filter Vehicle_merks to count.
     * @example
     * // Count the number of Vehicle_merks
     * const count = await prisma.vehicle_merk.count({
     *   where: {
     *     // ... the filter for the Vehicle_merks we want to count
     *   }
     * })
    **/
    count<T extends vehicle_merkCountArgs>(
      args?: Subset<T, vehicle_merkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vehicle_merkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle_merk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vehicle_merkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vehicle_merkAggregateArgs>(args: Subset<T, Vehicle_merkAggregateArgs>): Prisma.PrismaPromise<GetVehicle_merkAggregateType<T>>

    /**
     * Group by Vehicle_merk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_merkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehicle_merkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehicle_merkGroupByArgs['orderBy'] }
        : { orderBy?: vehicle_merkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehicle_merkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicle_merkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicle_merk model
   */
  readonly fields: vehicle_merkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicle_merk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehicle_merkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends vehicle_merk$usersArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_merk$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicle_merk model
   */
  interface vehicle_merkFieldRefs {
    readonly id: FieldRef<"vehicle_merk", 'String'>
    readonly name: FieldRef<"vehicle_merk", 'String'>
    readonly createdAt: FieldRef<"vehicle_merk", 'DateTime'>
    readonly updatedAt: FieldRef<"vehicle_merk", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * vehicle_merk findUnique
   */
  export type vehicle_merkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_merk
     */
    select?: vehicle_merkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_merk
     */
    omit?: vehicle_merkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_merkInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_merk to fetch.
     */
    where: vehicle_merkWhereUniqueInput
  }

  /**
   * vehicle_merk findUniqueOrThrow
   */
  export type vehicle_merkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_merk
     */
    select?: vehicle_merkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_merk
     */
    omit?: vehicle_merkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_merkInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_merk to fetch.
     */
    where: vehicle_merkWhereUniqueInput
  }

  /**
   * vehicle_merk findFirst
   */
  export type vehicle_merkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_merk
     */
    select?: vehicle_merkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_merk
     */
    omit?: vehicle_merkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_merkInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_merk to fetch.
     */
    where?: vehicle_merkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_merks to fetch.
     */
    orderBy?: vehicle_merkOrderByWithRelationInput | vehicle_merkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_merks.
     */
    cursor?: vehicle_merkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_merks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_merks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_merks.
     */
    distinct?: Vehicle_merkScalarFieldEnum | Vehicle_merkScalarFieldEnum[]
  }

  /**
   * vehicle_merk findFirstOrThrow
   */
  export type vehicle_merkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_merk
     */
    select?: vehicle_merkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_merk
     */
    omit?: vehicle_merkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_merkInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_merk to fetch.
     */
    where?: vehicle_merkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_merks to fetch.
     */
    orderBy?: vehicle_merkOrderByWithRelationInput | vehicle_merkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_merks.
     */
    cursor?: vehicle_merkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_merks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_merks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_merks.
     */
    distinct?: Vehicle_merkScalarFieldEnum | Vehicle_merkScalarFieldEnum[]
  }

  /**
   * vehicle_merk findMany
   */
  export type vehicle_merkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_merk
     */
    select?: vehicle_merkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_merk
     */
    omit?: vehicle_merkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_merkInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_merks to fetch.
     */
    where?: vehicle_merkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_merks to fetch.
     */
    orderBy?: vehicle_merkOrderByWithRelationInput | vehicle_merkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicle_merks.
     */
    cursor?: vehicle_merkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_merks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_merks.
     */
    skip?: number
    distinct?: Vehicle_merkScalarFieldEnum | Vehicle_merkScalarFieldEnum[]
  }

  /**
   * vehicle_merk create
   */
  export type vehicle_merkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_merk
     */
    select?: vehicle_merkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_merk
     */
    omit?: vehicle_merkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_merkInclude<ExtArgs> | null
    /**
     * The data needed to create a vehicle_merk.
     */
    data: XOR<vehicle_merkCreateInput, vehicle_merkUncheckedCreateInput>
  }

  /**
   * vehicle_merk createMany
   */
  export type vehicle_merkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicle_merks.
     */
    data: vehicle_merkCreateManyInput | vehicle_merkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * vehicle_merk createManyAndReturn
   */
  export type vehicle_merkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_merk
     */
    select?: vehicle_merkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_merk
     */
    omit?: vehicle_merkOmit<ExtArgs> | null
    /**
     * The data used to create many vehicle_merks.
     */
    data: vehicle_merkCreateManyInput | vehicle_merkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * vehicle_merk update
   */
  export type vehicle_merkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_merk
     */
    select?: vehicle_merkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_merk
     */
    omit?: vehicle_merkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_merkInclude<ExtArgs> | null
    /**
     * The data needed to update a vehicle_merk.
     */
    data: XOR<vehicle_merkUpdateInput, vehicle_merkUncheckedUpdateInput>
    /**
     * Choose, which vehicle_merk to update.
     */
    where: vehicle_merkWhereUniqueInput
  }

  /**
   * vehicle_merk updateMany
   */
  export type vehicle_merkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicle_merks.
     */
    data: XOR<vehicle_merkUpdateManyMutationInput, vehicle_merkUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_merks to update
     */
    where?: vehicle_merkWhereInput
    /**
     * Limit how many vehicle_merks to update.
     */
    limit?: number
  }

  /**
   * vehicle_merk updateManyAndReturn
   */
  export type vehicle_merkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_merk
     */
    select?: vehicle_merkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_merk
     */
    omit?: vehicle_merkOmit<ExtArgs> | null
    /**
     * The data used to update vehicle_merks.
     */
    data: XOR<vehicle_merkUpdateManyMutationInput, vehicle_merkUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_merks to update
     */
    where?: vehicle_merkWhereInput
    /**
     * Limit how many vehicle_merks to update.
     */
    limit?: number
  }

  /**
   * vehicle_merk upsert
   */
  export type vehicle_merkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_merk
     */
    select?: vehicle_merkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_merk
     */
    omit?: vehicle_merkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_merkInclude<ExtArgs> | null
    /**
     * The filter to search for the vehicle_merk to update in case it exists.
     */
    where: vehicle_merkWhereUniqueInput
    /**
     * In case the vehicle_merk found by the `where` argument doesn't exist, create a new vehicle_merk with this data.
     */
    create: XOR<vehicle_merkCreateInput, vehicle_merkUncheckedCreateInput>
    /**
     * In case the vehicle_merk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehicle_merkUpdateInput, vehicle_merkUncheckedUpdateInput>
  }

  /**
   * vehicle_merk delete
   */
  export type vehicle_merkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_merk
     */
    select?: vehicle_merkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_merk
     */
    omit?: vehicle_merkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_merkInclude<ExtArgs> | null
    /**
     * Filter which vehicle_merk to delete.
     */
    where: vehicle_merkWhereUniqueInput
  }

  /**
   * vehicle_merk deleteMany
   */
  export type vehicle_merkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_merks to delete
     */
    where?: vehicle_merkWhereInput
    /**
     * Limit how many vehicle_merks to delete.
     */
    limit?: number
  }

  /**
   * vehicle_merk.users
   */
  export type vehicle_merk$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * vehicle_merk without action
   */
  export type vehicle_merkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_merk
     */
    select?: vehicle_merkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_merk
     */
    omit?: vehicle_merkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_merkInclude<ExtArgs> | null
  }


  /**
   * Model vehicle_type
   */

  export type AggregateVehicle_type = {
    _count: Vehicle_typeCountAggregateOutputType | null
    _min: Vehicle_typeMinAggregateOutputType | null
    _max: Vehicle_typeMaxAggregateOutputType | null
  }

  export type Vehicle_typeMinAggregateOutputType = {
    id: string | null
    vehicle_category_id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_typeMaxAggregateOutputType = {
    id: string | null
    vehicle_category_id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_typeCountAggregateOutputType = {
    id: number
    vehicle_category_id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Vehicle_typeMinAggregateInputType = {
    id?: true
    vehicle_category_id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_typeMaxAggregateInputType = {
    id?: true
    vehicle_category_id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_typeCountAggregateInputType = {
    id?: true
    vehicle_category_id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Vehicle_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_type to aggregate.
     */
    where?: vehicle_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_types to fetch.
     */
    orderBy?: vehicle_typeOrderByWithRelationInput | vehicle_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehicle_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicle_types
    **/
    _count?: true | Vehicle_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vehicle_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vehicle_typeMaxAggregateInputType
  }

  export type GetVehicle_typeAggregateType<T extends Vehicle_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle_type[P]>
      : GetScalarType<T[P], AggregateVehicle_type[P]>
  }




  export type vehicle_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_typeWhereInput
    orderBy?: vehicle_typeOrderByWithAggregationInput | vehicle_typeOrderByWithAggregationInput[]
    by: Vehicle_typeScalarFieldEnum[] | Vehicle_typeScalarFieldEnum
    having?: vehicle_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vehicle_typeCountAggregateInputType | true
    _min?: Vehicle_typeMinAggregateInputType
    _max?: Vehicle_typeMaxAggregateInputType
  }

  export type Vehicle_typeGroupByOutputType = {
    id: string
    vehicle_category_id: string
    name: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: Vehicle_typeCountAggregateOutputType | null
    _min: Vehicle_typeMinAggregateOutputType | null
    _max: Vehicle_typeMaxAggregateOutputType | null
  }

  type GetVehicle_typeGroupByPayload<T extends vehicle_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Vehicle_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Vehicle_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Vehicle_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Vehicle_typeGroupByOutputType[P]>
        }
      >
    >


  export type vehicle_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicle_category_id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | vehicle_type$usersArgs<ExtArgs>
    vehicle_category?: boolean | vehicle_categoryDefaultArgs<ExtArgs>
    _count?: boolean | Vehicle_typeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle_type"]>

  export type vehicle_typeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicle_category_id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicle_category?: boolean | vehicle_categoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle_type"]>

  export type vehicle_typeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicle_category_id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicle_category?: boolean | vehicle_categoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle_type"]>

  export type vehicle_typeSelectScalar = {
    id?: boolean
    vehicle_category_id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type vehicle_typeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vehicle_category_id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle_type"]>
  export type vehicle_typeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | vehicle_type$usersArgs<ExtArgs>
    vehicle_category?: boolean | vehicle_categoryDefaultArgs<ExtArgs>
    _count?: boolean | Vehicle_typeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type vehicle_typeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle_category?: boolean | vehicle_categoryDefaultArgs<ExtArgs>
  }
  export type vehicle_typeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle_category?: boolean | vehicle_categoryDefaultArgs<ExtArgs>
  }

  export type $vehicle_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicle_type"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>[]
      vehicle_category: Prisma.$vehicle_categoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vehicle_category_id: string
      name: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["vehicle_type"]>
    composites: {}
  }

  type vehicle_typeGetPayload<S extends boolean | null | undefined | vehicle_typeDefaultArgs> = $Result.GetResult<Prisma.$vehicle_typePayload, S>

  type vehicle_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vehicle_typeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Vehicle_typeCountAggregateInputType | true
    }

  export interface vehicle_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicle_type'], meta: { name: 'vehicle_type' } }
    /**
     * Find zero or one Vehicle_type that matches the filter.
     * @param {vehicle_typeFindUniqueArgs} args - Arguments to find a Vehicle_type
     * @example
     * // Get one Vehicle_type
     * const vehicle_type = await prisma.vehicle_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehicle_typeFindUniqueArgs>(args: SelectSubset<T, vehicle_typeFindUniqueArgs<ExtArgs>>): Prisma__vehicle_typeClient<$Result.GetResult<Prisma.$vehicle_typePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle_type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vehicle_typeFindUniqueOrThrowArgs} args - Arguments to find a Vehicle_type
     * @example
     * // Get one Vehicle_type
     * const vehicle_type = await prisma.vehicle_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehicle_typeFindUniqueOrThrowArgs>(args: SelectSubset<T, vehicle_typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehicle_typeClient<$Result.GetResult<Prisma.$vehicle_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_typeFindFirstArgs} args - Arguments to find a Vehicle_type
     * @example
     * // Get one Vehicle_type
     * const vehicle_type = await prisma.vehicle_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehicle_typeFindFirstArgs>(args?: SelectSubset<T, vehicle_typeFindFirstArgs<ExtArgs>>): Prisma__vehicle_typeClient<$Result.GetResult<Prisma.$vehicle_typePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_typeFindFirstOrThrowArgs} args - Arguments to find a Vehicle_type
     * @example
     * // Get one Vehicle_type
     * const vehicle_type = await prisma.vehicle_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehicle_typeFindFirstOrThrowArgs>(args?: SelectSubset<T, vehicle_typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehicle_typeClient<$Result.GetResult<Prisma.$vehicle_typePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicle_types
     * const vehicle_types = await prisma.vehicle_type.findMany()
     * 
     * // Get first 10 Vehicle_types
     * const vehicle_types = await prisma.vehicle_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicle_typeWithIdOnly = await prisma.vehicle_type.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehicle_typeFindManyArgs>(args?: SelectSubset<T, vehicle_typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle_type.
     * @param {vehicle_typeCreateArgs} args - Arguments to create a Vehicle_type.
     * @example
     * // Create one Vehicle_type
     * const Vehicle_type = await prisma.vehicle_type.create({
     *   data: {
     *     // ... data to create a Vehicle_type
     *   }
     * })
     * 
     */
    create<T extends vehicle_typeCreateArgs>(args: SelectSubset<T, vehicle_typeCreateArgs<ExtArgs>>): Prisma__vehicle_typeClient<$Result.GetResult<Prisma.$vehicle_typePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicle_types.
     * @param {vehicle_typeCreateManyArgs} args - Arguments to create many Vehicle_types.
     * @example
     * // Create many Vehicle_types
     * const vehicle_type = await prisma.vehicle_type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehicle_typeCreateManyArgs>(args?: SelectSubset<T, vehicle_typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicle_types and returns the data saved in the database.
     * @param {vehicle_typeCreateManyAndReturnArgs} args - Arguments to create many Vehicle_types.
     * @example
     * // Create many Vehicle_types
     * const vehicle_type = await prisma.vehicle_type.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicle_types and only return the `id`
     * const vehicle_typeWithIdOnly = await prisma.vehicle_type.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends vehicle_typeCreateManyAndReturnArgs>(args?: SelectSubset<T, vehicle_typeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_typePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vehicle_type.
     * @param {vehicle_typeDeleteArgs} args - Arguments to delete one Vehicle_type.
     * @example
     * // Delete one Vehicle_type
     * const Vehicle_type = await prisma.vehicle_type.delete({
     *   where: {
     *     // ... filter to delete one Vehicle_type
     *   }
     * })
     * 
     */
    delete<T extends vehicle_typeDeleteArgs>(args: SelectSubset<T, vehicle_typeDeleteArgs<ExtArgs>>): Prisma__vehicle_typeClient<$Result.GetResult<Prisma.$vehicle_typePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle_type.
     * @param {vehicle_typeUpdateArgs} args - Arguments to update one Vehicle_type.
     * @example
     * // Update one Vehicle_type
     * const vehicle_type = await prisma.vehicle_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehicle_typeUpdateArgs>(args: SelectSubset<T, vehicle_typeUpdateArgs<ExtArgs>>): Prisma__vehicle_typeClient<$Result.GetResult<Prisma.$vehicle_typePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicle_types.
     * @param {vehicle_typeDeleteManyArgs} args - Arguments to filter Vehicle_types to delete.
     * @example
     * // Delete a few Vehicle_types
     * const { count } = await prisma.vehicle_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehicle_typeDeleteManyArgs>(args?: SelectSubset<T, vehicle_typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicle_types
     * const vehicle_type = await prisma.vehicle_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehicle_typeUpdateManyArgs>(args: SelectSubset<T, vehicle_typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_types and returns the data updated in the database.
     * @param {vehicle_typeUpdateManyAndReturnArgs} args - Arguments to update many Vehicle_types.
     * @example
     * // Update many Vehicle_types
     * const vehicle_type = await prisma.vehicle_type.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vehicle_types and only return the `id`
     * const vehicle_typeWithIdOnly = await prisma.vehicle_type.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends vehicle_typeUpdateManyAndReturnArgs>(args: SelectSubset<T, vehicle_typeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_typePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vehicle_type.
     * @param {vehicle_typeUpsertArgs} args - Arguments to update or create a Vehicle_type.
     * @example
     * // Update or create a Vehicle_type
     * const vehicle_type = await prisma.vehicle_type.upsert({
     *   create: {
     *     // ... data to create a Vehicle_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle_type we want to update
     *   }
     * })
     */
    upsert<T extends vehicle_typeUpsertArgs>(args: SelectSubset<T, vehicle_typeUpsertArgs<ExtArgs>>): Prisma__vehicle_typeClient<$Result.GetResult<Prisma.$vehicle_typePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vehicle_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_typeCountArgs} args - Arguments to filter Vehicle_types to count.
     * @example
     * // Count the number of Vehicle_types
     * const count = await prisma.vehicle_type.count({
     *   where: {
     *     // ... the filter for the Vehicle_types we want to count
     *   }
     * })
    **/
    count<T extends vehicle_typeCountArgs>(
      args?: Subset<T, vehicle_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vehicle_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vehicle_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vehicle_typeAggregateArgs>(args: Subset<T, Vehicle_typeAggregateArgs>): Prisma.PrismaPromise<GetVehicle_typeAggregateType<T>>

    /**
     * Group by Vehicle_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehicle_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehicle_typeGroupByArgs['orderBy'] }
        : { orderBy?: vehicle_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehicle_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicle_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicle_type model
   */
  readonly fields: vehicle_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicle_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehicle_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends vehicle_type$usersArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_type$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicle_category<T extends vehicle_categoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_categoryDefaultArgs<ExtArgs>>): Prisma__vehicle_categoryClient<$Result.GetResult<Prisma.$vehicle_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicle_type model
   */
  interface vehicle_typeFieldRefs {
    readonly id: FieldRef<"vehicle_type", 'String'>
    readonly vehicle_category_id: FieldRef<"vehicle_type", 'String'>
    readonly name: FieldRef<"vehicle_type", 'String'>
    readonly createdAt: FieldRef<"vehicle_type", 'DateTime'>
    readonly updatedAt: FieldRef<"vehicle_type", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * vehicle_type findUnique
   */
  export type vehicle_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_type
     */
    select?: vehicle_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_type
     */
    omit?: vehicle_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typeInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_type to fetch.
     */
    where: vehicle_typeWhereUniqueInput
  }

  /**
   * vehicle_type findUniqueOrThrow
   */
  export type vehicle_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_type
     */
    select?: vehicle_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_type
     */
    omit?: vehicle_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typeInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_type to fetch.
     */
    where: vehicle_typeWhereUniqueInput
  }

  /**
   * vehicle_type findFirst
   */
  export type vehicle_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_type
     */
    select?: vehicle_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_type
     */
    omit?: vehicle_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typeInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_type to fetch.
     */
    where?: vehicle_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_types to fetch.
     */
    orderBy?: vehicle_typeOrderByWithRelationInput | vehicle_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_types.
     */
    cursor?: vehicle_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_types.
     */
    distinct?: Vehicle_typeScalarFieldEnum | Vehicle_typeScalarFieldEnum[]
  }

  /**
   * vehicle_type findFirstOrThrow
   */
  export type vehicle_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_type
     */
    select?: vehicle_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_type
     */
    omit?: vehicle_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typeInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_type to fetch.
     */
    where?: vehicle_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_types to fetch.
     */
    orderBy?: vehicle_typeOrderByWithRelationInput | vehicle_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_types.
     */
    cursor?: vehicle_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_types.
     */
    distinct?: Vehicle_typeScalarFieldEnum | Vehicle_typeScalarFieldEnum[]
  }

  /**
   * vehicle_type findMany
   */
  export type vehicle_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_type
     */
    select?: vehicle_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_type
     */
    omit?: vehicle_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typeInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_types to fetch.
     */
    where?: vehicle_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_types to fetch.
     */
    orderBy?: vehicle_typeOrderByWithRelationInput | vehicle_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicle_types.
     */
    cursor?: vehicle_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_types.
     */
    skip?: number
    distinct?: Vehicle_typeScalarFieldEnum | Vehicle_typeScalarFieldEnum[]
  }

  /**
   * vehicle_type create
   */
  export type vehicle_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_type
     */
    select?: vehicle_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_type
     */
    omit?: vehicle_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typeInclude<ExtArgs> | null
    /**
     * The data needed to create a vehicle_type.
     */
    data: XOR<vehicle_typeCreateInput, vehicle_typeUncheckedCreateInput>
  }

  /**
   * vehicle_type createMany
   */
  export type vehicle_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicle_types.
     */
    data: vehicle_typeCreateManyInput | vehicle_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * vehicle_type createManyAndReturn
   */
  export type vehicle_typeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_type
     */
    select?: vehicle_typeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_type
     */
    omit?: vehicle_typeOmit<ExtArgs> | null
    /**
     * The data used to create many vehicle_types.
     */
    data: vehicle_typeCreateManyInput | vehicle_typeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * vehicle_type update
   */
  export type vehicle_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_type
     */
    select?: vehicle_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_type
     */
    omit?: vehicle_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typeInclude<ExtArgs> | null
    /**
     * The data needed to update a vehicle_type.
     */
    data: XOR<vehicle_typeUpdateInput, vehicle_typeUncheckedUpdateInput>
    /**
     * Choose, which vehicle_type to update.
     */
    where: vehicle_typeWhereUniqueInput
  }

  /**
   * vehicle_type updateMany
   */
  export type vehicle_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicle_types.
     */
    data: XOR<vehicle_typeUpdateManyMutationInput, vehicle_typeUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_types to update
     */
    where?: vehicle_typeWhereInput
    /**
     * Limit how many vehicle_types to update.
     */
    limit?: number
  }

  /**
   * vehicle_type updateManyAndReturn
   */
  export type vehicle_typeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_type
     */
    select?: vehicle_typeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_type
     */
    omit?: vehicle_typeOmit<ExtArgs> | null
    /**
     * The data used to update vehicle_types.
     */
    data: XOR<vehicle_typeUpdateManyMutationInput, vehicle_typeUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_types to update
     */
    where?: vehicle_typeWhereInput
    /**
     * Limit how many vehicle_types to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * vehicle_type upsert
   */
  export type vehicle_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_type
     */
    select?: vehicle_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_type
     */
    omit?: vehicle_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typeInclude<ExtArgs> | null
    /**
     * The filter to search for the vehicle_type to update in case it exists.
     */
    where: vehicle_typeWhereUniqueInput
    /**
     * In case the vehicle_type found by the `where` argument doesn't exist, create a new vehicle_type with this data.
     */
    create: XOR<vehicle_typeCreateInput, vehicle_typeUncheckedCreateInput>
    /**
     * In case the vehicle_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehicle_typeUpdateInput, vehicle_typeUncheckedUpdateInput>
  }

  /**
   * vehicle_type delete
   */
  export type vehicle_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_type
     */
    select?: vehicle_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_type
     */
    omit?: vehicle_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typeInclude<ExtArgs> | null
    /**
     * Filter which vehicle_type to delete.
     */
    where: vehicle_typeWhereUniqueInput
  }

  /**
   * vehicle_type deleteMany
   */
  export type vehicle_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_types to delete
     */
    where?: vehicle_typeWhereInput
    /**
     * Limit how many vehicle_types to delete.
     */
    limit?: number
  }

  /**
   * vehicle_type.users
   */
  export type vehicle_type$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * vehicle_type without action
   */
  export type vehicle_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_type
     */
    select?: vehicle_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_type
     */
    omit?: vehicle_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_typeInclude<ExtArgs> | null
  }


  /**
   * Model vehicle_year
   */

  export type AggregateVehicle_year = {
    _count: Vehicle_yearCountAggregateOutputType | null
    _min: Vehicle_yearMinAggregateOutputType | null
    _max: Vehicle_yearMaxAggregateOutputType | null
  }

  export type Vehicle_yearMinAggregateOutputType = {
    id: string | null
    year: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_yearMaxAggregateOutputType = {
    id: string | null
    year: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_yearCountAggregateOutputType = {
    id: number
    year: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Vehicle_yearMinAggregateInputType = {
    id?: true
    year?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_yearMaxAggregateInputType = {
    id?: true
    year?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_yearCountAggregateInputType = {
    id?: true
    year?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Vehicle_yearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_year to aggregate.
     */
    where?: vehicle_yearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_years to fetch.
     */
    orderBy?: vehicle_yearOrderByWithRelationInput | vehicle_yearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehicle_yearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_years from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_years.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicle_years
    **/
    _count?: true | Vehicle_yearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vehicle_yearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vehicle_yearMaxAggregateInputType
  }

  export type GetVehicle_yearAggregateType<T extends Vehicle_yearAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle_year]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle_year[P]>
      : GetScalarType<T[P], AggregateVehicle_year[P]>
  }




  export type vehicle_yearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_yearWhereInput
    orderBy?: vehicle_yearOrderByWithAggregationInput | vehicle_yearOrderByWithAggregationInput[]
    by: Vehicle_yearScalarFieldEnum[] | Vehicle_yearScalarFieldEnum
    having?: vehicle_yearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vehicle_yearCountAggregateInputType | true
    _min?: Vehicle_yearMinAggregateInputType
    _max?: Vehicle_yearMaxAggregateInputType
  }

  export type Vehicle_yearGroupByOutputType = {
    id: string
    year: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: Vehicle_yearCountAggregateOutputType | null
    _min: Vehicle_yearMinAggregateOutputType | null
    _max: Vehicle_yearMaxAggregateOutputType | null
  }

  type GetVehicle_yearGroupByPayload<T extends vehicle_yearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Vehicle_yearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Vehicle_yearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Vehicle_yearGroupByOutputType[P]>
            : GetScalarType<T[P], Vehicle_yearGroupByOutputType[P]>
        }
      >
    >


  export type vehicle_yearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | vehicle_year$usersArgs<ExtArgs>
    _count?: boolean | Vehicle_yearCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle_year"]>

  export type vehicle_yearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vehicle_year"]>

  export type vehicle_yearSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vehicle_year"]>

  export type vehicle_yearSelectScalar = {
    id?: boolean
    year?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type vehicle_yearOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "year" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle_year"]>
  export type vehicle_yearInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | vehicle_year$usersArgs<ExtArgs>
    _count?: boolean | Vehicle_yearCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type vehicle_yearIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type vehicle_yearIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $vehicle_yearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicle_year"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      year: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["vehicle_year"]>
    composites: {}
  }

  type vehicle_yearGetPayload<S extends boolean | null | undefined | vehicle_yearDefaultArgs> = $Result.GetResult<Prisma.$vehicle_yearPayload, S>

  type vehicle_yearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vehicle_yearFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Vehicle_yearCountAggregateInputType | true
    }

  export interface vehicle_yearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicle_year'], meta: { name: 'vehicle_year' } }
    /**
     * Find zero or one Vehicle_year that matches the filter.
     * @param {vehicle_yearFindUniqueArgs} args - Arguments to find a Vehicle_year
     * @example
     * // Get one Vehicle_year
     * const vehicle_year = await prisma.vehicle_year.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehicle_yearFindUniqueArgs>(args: SelectSubset<T, vehicle_yearFindUniqueArgs<ExtArgs>>): Prisma__vehicle_yearClient<$Result.GetResult<Prisma.$vehicle_yearPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle_year that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vehicle_yearFindUniqueOrThrowArgs} args - Arguments to find a Vehicle_year
     * @example
     * // Get one Vehicle_year
     * const vehicle_year = await prisma.vehicle_year.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehicle_yearFindUniqueOrThrowArgs>(args: SelectSubset<T, vehicle_yearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehicle_yearClient<$Result.GetResult<Prisma.$vehicle_yearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_year that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_yearFindFirstArgs} args - Arguments to find a Vehicle_year
     * @example
     * // Get one Vehicle_year
     * const vehicle_year = await prisma.vehicle_year.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehicle_yearFindFirstArgs>(args?: SelectSubset<T, vehicle_yearFindFirstArgs<ExtArgs>>): Prisma__vehicle_yearClient<$Result.GetResult<Prisma.$vehicle_yearPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_year that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_yearFindFirstOrThrowArgs} args - Arguments to find a Vehicle_year
     * @example
     * // Get one Vehicle_year
     * const vehicle_year = await prisma.vehicle_year.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehicle_yearFindFirstOrThrowArgs>(args?: SelectSubset<T, vehicle_yearFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehicle_yearClient<$Result.GetResult<Prisma.$vehicle_yearPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_years that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_yearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicle_years
     * const vehicle_years = await prisma.vehicle_year.findMany()
     * 
     * // Get first 10 Vehicle_years
     * const vehicle_years = await prisma.vehicle_year.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicle_yearWithIdOnly = await prisma.vehicle_year.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehicle_yearFindManyArgs>(args?: SelectSubset<T, vehicle_yearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_yearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle_year.
     * @param {vehicle_yearCreateArgs} args - Arguments to create a Vehicle_year.
     * @example
     * // Create one Vehicle_year
     * const Vehicle_year = await prisma.vehicle_year.create({
     *   data: {
     *     // ... data to create a Vehicle_year
     *   }
     * })
     * 
     */
    create<T extends vehicle_yearCreateArgs>(args: SelectSubset<T, vehicle_yearCreateArgs<ExtArgs>>): Prisma__vehicle_yearClient<$Result.GetResult<Prisma.$vehicle_yearPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicle_years.
     * @param {vehicle_yearCreateManyArgs} args - Arguments to create many Vehicle_years.
     * @example
     * // Create many Vehicle_years
     * const vehicle_year = await prisma.vehicle_year.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehicle_yearCreateManyArgs>(args?: SelectSubset<T, vehicle_yearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicle_years and returns the data saved in the database.
     * @param {vehicle_yearCreateManyAndReturnArgs} args - Arguments to create many Vehicle_years.
     * @example
     * // Create many Vehicle_years
     * const vehicle_year = await prisma.vehicle_year.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicle_years and only return the `id`
     * const vehicle_yearWithIdOnly = await prisma.vehicle_year.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends vehicle_yearCreateManyAndReturnArgs>(args?: SelectSubset<T, vehicle_yearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_yearPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vehicle_year.
     * @param {vehicle_yearDeleteArgs} args - Arguments to delete one Vehicle_year.
     * @example
     * // Delete one Vehicle_year
     * const Vehicle_year = await prisma.vehicle_year.delete({
     *   where: {
     *     // ... filter to delete one Vehicle_year
     *   }
     * })
     * 
     */
    delete<T extends vehicle_yearDeleteArgs>(args: SelectSubset<T, vehicle_yearDeleteArgs<ExtArgs>>): Prisma__vehicle_yearClient<$Result.GetResult<Prisma.$vehicle_yearPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle_year.
     * @param {vehicle_yearUpdateArgs} args - Arguments to update one Vehicle_year.
     * @example
     * // Update one Vehicle_year
     * const vehicle_year = await prisma.vehicle_year.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehicle_yearUpdateArgs>(args: SelectSubset<T, vehicle_yearUpdateArgs<ExtArgs>>): Prisma__vehicle_yearClient<$Result.GetResult<Prisma.$vehicle_yearPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicle_years.
     * @param {vehicle_yearDeleteManyArgs} args - Arguments to filter Vehicle_years to delete.
     * @example
     * // Delete a few Vehicle_years
     * const { count } = await prisma.vehicle_year.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehicle_yearDeleteManyArgs>(args?: SelectSubset<T, vehicle_yearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_years.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_yearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicle_years
     * const vehicle_year = await prisma.vehicle_year.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehicle_yearUpdateManyArgs>(args: SelectSubset<T, vehicle_yearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_years and returns the data updated in the database.
     * @param {vehicle_yearUpdateManyAndReturnArgs} args - Arguments to update many Vehicle_years.
     * @example
     * // Update many Vehicle_years
     * const vehicle_year = await prisma.vehicle_year.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vehicle_years and only return the `id`
     * const vehicle_yearWithIdOnly = await prisma.vehicle_year.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends vehicle_yearUpdateManyAndReturnArgs>(args: SelectSubset<T, vehicle_yearUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_yearPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vehicle_year.
     * @param {vehicle_yearUpsertArgs} args - Arguments to update or create a Vehicle_year.
     * @example
     * // Update or create a Vehicle_year
     * const vehicle_year = await prisma.vehicle_year.upsert({
     *   create: {
     *     // ... data to create a Vehicle_year
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle_year we want to update
     *   }
     * })
     */
    upsert<T extends vehicle_yearUpsertArgs>(args: SelectSubset<T, vehicle_yearUpsertArgs<ExtArgs>>): Prisma__vehicle_yearClient<$Result.GetResult<Prisma.$vehicle_yearPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vehicle_years.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_yearCountArgs} args - Arguments to filter Vehicle_years to count.
     * @example
     * // Count the number of Vehicle_years
     * const count = await prisma.vehicle_year.count({
     *   where: {
     *     // ... the filter for the Vehicle_years we want to count
     *   }
     * })
    **/
    count<T extends vehicle_yearCountArgs>(
      args?: Subset<T, vehicle_yearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vehicle_yearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle_year.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vehicle_yearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vehicle_yearAggregateArgs>(args: Subset<T, Vehicle_yearAggregateArgs>): Prisma.PrismaPromise<GetVehicle_yearAggregateType<T>>

    /**
     * Group by Vehicle_year.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_yearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehicle_yearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehicle_yearGroupByArgs['orderBy'] }
        : { orderBy?: vehicle_yearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehicle_yearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicle_yearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicle_year model
   */
  readonly fields: vehicle_yearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicle_year.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehicle_yearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends vehicle_year$usersArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_year$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicle_year model
   */
  interface vehicle_yearFieldRefs {
    readonly id: FieldRef<"vehicle_year", 'String'>
    readonly year: FieldRef<"vehicle_year", 'String'>
    readonly createdAt: FieldRef<"vehicle_year", 'DateTime'>
    readonly updatedAt: FieldRef<"vehicle_year", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * vehicle_year findUnique
   */
  export type vehicle_yearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_year
     */
    select?: vehicle_yearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_year
     */
    omit?: vehicle_yearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_yearInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_year to fetch.
     */
    where: vehicle_yearWhereUniqueInput
  }

  /**
   * vehicle_year findUniqueOrThrow
   */
  export type vehicle_yearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_year
     */
    select?: vehicle_yearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_year
     */
    omit?: vehicle_yearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_yearInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_year to fetch.
     */
    where: vehicle_yearWhereUniqueInput
  }

  /**
   * vehicle_year findFirst
   */
  export type vehicle_yearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_year
     */
    select?: vehicle_yearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_year
     */
    omit?: vehicle_yearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_yearInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_year to fetch.
     */
    where?: vehicle_yearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_years to fetch.
     */
    orderBy?: vehicle_yearOrderByWithRelationInput | vehicle_yearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_years.
     */
    cursor?: vehicle_yearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_years from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_years.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_years.
     */
    distinct?: Vehicle_yearScalarFieldEnum | Vehicle_yearScalarFieldEnum[]
  }

  /**
   * vehicle_year findFirstOrThrow
   */
  export type vehicle_yearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_year
     */
    select?: vehicle_yearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_year
     */
    omit?: vehicle_yearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_yearInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_year to fetch.
     */
    where?: vehicle_yearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_years to fetch.
     */
    orderBy?: vehicle_yearOrderByWithRelationInput | vehicle_yearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_years.
     */
    cursor?: vehicle_yearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_years from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_years.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_years.
     */
    distinct?: Vehicle_yearScalarFieldEnum | Vehicle_yearScalarFieldEnum[]
  }

  /**
   * vehicle_year findMany
   */
  export type vehicle_yearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_year
     */
    select?: vehicle_yearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_year
     */
    omit?: vehicle_yearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_yearInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_years to fetch.
     */
    where?: vehicle_yearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_years to fetch.
     */
    orderBy?: vehicle_yearOrderByWithRelationInput | vehicle_yearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicle_years.
     */
    cursor?: vehicle_yearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_years from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_years.
     */
    skip?: number
    distinct?: Vehicle_yearScalarFieldEnum | Vehicle_yearScalarFieldEnum[]
  }

  /**
   * vehicle_year create
   */
  export type vehicle_yearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_year
     */
    select?: vehicle_yearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_year
     */
    omit?: vehicle_yearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_yearInclude<ExtArgs> | null
    /**
     * The data needed to create a vehicle_year.
     */
    data: XOR<vehicle_yearCreateInput, vehicle_yearUncheckedCreateInput>
  }

  /**
   * vehicle_year createMany
   */
  export type vehicle_yearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicle_years.
     */
    data: vehicle_yearCreateManyInput | vehicle_yearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * vehicle_year createManyAndReturn
   */
  export type vehicle_yearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_year
     */
    select?: vehicle_yearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_year
     */
    omit?: vehicle_yearOmit<ExtArgs> | null
    /**
     * The data used to create many vehicle_years.
     */
    data: vehicle_yearCreateManyInput | vehicle_yearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * vehicle_year update
   */
  export type vehicle_yearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_year
     */
    select?: vehicle_yearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_year
     */
    omit?: vehicle_yearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_yearInclude<ExtArgs> | null
    /**
     * The data needed to update a vehicle_year.
     */
    data: XOR<vehicle_yearUpdateInput, vehicle_yearUncheckedUpdateInput>
    /**
     * Choose, which vehicle_year to update.
     */
    where: vehicle_yearWhereUniqueInput
  }

  /**
   * vehicle_year updateMany
   */
  export type vehicle_yearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicle_years.
     */
    data: XOR<vehicle_yearUpdateManyMutationInput, vehicle_yearUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_years to update
     */
    where?: vehicle_yearWhereInput
    /**
     * Limit how many vehicle_years to update.
     */
    limit?: number
  }

  /**
   * vehicle_year updateManyAndReturn
   */
  export type vehicle_yearUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_year
     */
    select?: vehicle_yearSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_year
     */
    omit?: vehicle_yearOmit<ExtArgs> | null
    /**
     * The data used to update vehicle_years.
     */
    data: XOR<vehicle_yearUpdateManyMutationInput, vehicle_yearUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_years to update
     */
    where?: vehicle_yearWhereInput
    /**
     * Limit how many vehicle_years to update.
     */
    limit?: number
  }

  /**
   * vehicle_year upsert
   */
  export type vehicle_yearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_year
     */
    select?: vehicle_yearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_year
     */
    omit?: vehicle_yearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_yearInclude<ExtArgs> | null
    /**
     * The filter to search for the vehicle_year to update in case it exists.
     */
    where: vehicle_yearWhereUniqueInput
    /**
     * In case the vehicle_year found by the `where` argument doesn't exist, create a new vehicle_year with this data.
     */
    create: XOR<vehicle_yearCreateInput, vehicle_yearUncheckedCreateInput>
    /**
     * In case the vehicle_year was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehicle_yearUpdateInput, vehicle_yearUncheckedUpdateInput>
  }

  /**
   * vehicle_year delete
   */
  export type vehicle_yearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_year
     */
    select?: vehicle_yearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_year
     */
    omit?: vehicle_yearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_yearInclude<ExtArgs> | null
    /**
     * Filter which vehicle_year to delete.
     */
    where: vehicle_yearWhereUniqueInput
  }

  /**
   * vehicle_year deleteMany
   */
  export type vehicle_yearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_years to delete
     */
    where?: vehicle_yearWhereInput
    /**
     * Limit how many vehicle_years to delete.
     */
    limit?: number
  }

  /**
   * vehicle_year.users
   */
  export type vehicle_year$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * vehicle_year without action
   */
  export type vehicle_yearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_year
     */
    select?: vehicle_yearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_year
     */
    omit?: vehicle_yearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_yearInclude<ExtArgs> | null
  }


  /**
   * Model warehouse
   */

  export type AggregateWarehouse = {
    _count: WarehouseCountAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  export type WarehouseMinAggregateOutputType = {
    id: string | null
    level_id: string | null
    name_warehouse: string | null
    username: string | null
    password: string | null
    warehouse_address: string | null
    phone_number_warehouse: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseMaxAggregateOutputType = {
    id: string | null
    level_id: string | null
    name_warehouse: string | null
    username: string | null
    password: string | null
    warehouse_address: string | null
    phone_number_warehouse: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseCountAggregateOutputType = {
    id: number
    level_id: number
    name_warehouse: number
    username: number
    password: number
    warehouse_address: number
    phone_number_warehouse: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WarehouseMinAggregateInputType = {
    id?: true
    level_id?: true
    name_warehouse?: true
    username?: true
    password?: true
    warehouse_address?: true
    phone_number_warehouse?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseMaxAggregateInputType = {
    id?: true
    level_id?: true
    name_warehouse?: true
    username?: true
    password?: true
    warehouse_address?: true
    phone_number_warehouse?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseCountAggregateInputType = {
    id?: true
    level_id?: true
    name_warehouse?: true
    username?: true
    password?: true
    warehouse_address?: true
    phone_number_warehouse?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WarehouseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which warehouse to aggregate.
     */
    where?: warehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warehouses to fetch.
     */
    orderBy?: warehouseOrderByWithRelationInput | warehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: warehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned warehouses
    **/
    _count?: true | WarehouseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseMaxAggregateInputType
  }

  export type GetWarehouseAggregateType<T extends WarehouseAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouse[P]>
      : GetScalarType<T[P], AggregateWarehouse[P]>
  }




  export type warehouseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: warehouseWhereInput
    orderBy?: warehouseOrderByWithAggregationInput | warehouseOrderByWithAggregationInput[]
    by: WarehouseScalarFieldEnum[] | WarehouseScalarFieldEnum
    having?: warehouseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseCountAggregateInputType | true
    _min?: WarehouseMinAggregateInputType
    _max?: WarehouseMaxAggregateInputType
  }

  export type WarehouseGroupByOutputType = {
    id: string
    level_id: string
    name_warehouse: string
    username: string
    password: string
    warehouse_address: string
    phone_number_warehouse: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: WarehouseCountAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  type GetWarehouseGroupByPayload<T extends warehouseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
        }
      >
    >


  export type warehouseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level_id?: boolean
    name_warehouse?: boolean
    username?: boolean
    password?: boolean
    warehouse_address?: boolean
    phone_number_warehouse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mekanik?: boolean | warehouse$mekanikArgs<ExtArgs>
    order_barang_order_barang_from_warehouse_idTowarehouse?: boolean | warehouse$order_barang_order_barang_from_warehouse_idTowarehouseArgs<ExtArgs>
    order_barang_order_barang_to_warehouse_idTowarehouse?: boolean | warehouse$order_barang_order_barang_to_warehouse_idTowarehouseArgs<ExtArgs>
    transaksi?: boolean | warehouse$transaksiArgs<ExtArgs>
    level?: boolean | levelDefaultArgs<ExtArgs>
    warehouse_inventory?: boolean | warehouse$warehouse_inventoryArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type warehouseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level_id?: boolean
    name_warehouse?: boolean
    username?: boolean
    password?: boolean
    warehouse_address?: boolean
    phone_number_warehouse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean | levelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type warehouseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level_id?: boolean
    name_warehouse?: boolean
    username?: boolean
    password?: boolean
    warehouse_address?: boolean
    phone_number_warehouse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean | levelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type warehouseSelectScalar = {
    id?: boolean
    level_id?: boolean
    name_warehouse?: boolean
    username?: boolean
    password?: boolean
    warehouse_address?: boolean
    phone_number_warehouse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type warehouseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "level_id" | "name_warehouse" | "username" | "password" | "warehouse_address" | "phone_number_warehouse" | "createdAt" | "updatedAt", ExtArgs["result"]["warehouse"]>
  export type warehouseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mekanik?: boolean | warehouse$mekanikArgs<ExtArgs>
    order_barang_order_barang_from_warehouse_idTowarehouse?: boolean | warehouse$order_barang_order_barang_from_warehouse_idTowarehouseArgs<ExtArgs>
    order_barang_order_barang_to_warehouse_idTowarehouse?: boolean | warehouse$order_barang_order_barang_to_warehouse_idTowarehouseArgs<ExtArgs>
    transaksi?: boolean | warehouse$transaksiArgs<ExtArgs>
    level?: boolean | levelDefaultArgs<ExtArgs>
    warehouse_inventory?: boolean | warehouse$warehouse_inventoryArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type warehouseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    level?: boolean | levelDefaultArgs<ExtArgs>
  }
  export type warehouseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    level?: boolean | levelDefaultArgs<ExtArgs>
  }

  export type $warehousePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "warehouse"
    objects: {
      mekanik: Prisma.$mekanikPayload<ExtArgs>[]
      order_barang_order_barang_from_warehouse_idTowarehouse: Prisma.$order_barangPayload<ExtArgs>[]
      order_barang_order_barang_to_warehouse_idTowarehouse: Prisma.$order_barangPayload<ExtArgs>[]
      transaksi: Prisma.$transaksiPayload<ExtArgs>[]
      level: Prisma.$levelPayload<ExtArgs>
      warehouse_inventory: Prisma.$warehouse_inventoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      level_id: string
      name_warehouse: string
      username: string
      password: string
      warehouse_address: string
      phone_number_warehouse: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["warehouse"]>
    composites: {}
  }

  type warehouseGetPayload<S extends boolean | null | undefined | warehouseDefaultArgs> = $Result.GetResult<Prisma.$warehousePayload, S>

  type warehouseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<warehouseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseCountAggregateInputType | true
    }

  export interface warehouseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['warehouse'], meta: { name: 'warehouse' } }
    /**
     * Find zero or one Warehouse that matches the filter.
     * @param {warehouseFindUniqueArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends warehouseFindUniqueArgs>(args: SelectSubset<T, warehouseFindUniqueArgs<ExtArgs>>): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Warehouse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {warehouseFindUniqueOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends warehouseFindUniqueOrThrowArgs>(args: SelectSubset<T, warehouseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warehouseFindFirstArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends warehouseFindFirstArgs>(args?: SelectSubset<T, warehouseFindFirstArgs<ExtArgs>>): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warehouseFindFirstOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends warehouseFindFirstOrThrowArgs>(args?: SelectSubset<T, warehouseFindFirstOrThrowArgs<ExtArgs>>): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Warehouses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warehouseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Warehouses
     * const warehouses = await prisma.warehouse.findMany()
     * 
     * // Get first 10 Warehouses
     * const warehouses = await prisma.warehouse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends warehouseFindManyArgs>(args?: SelectSubset<T, warehouseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Warehouse.
     * @param {warehouseCreateArgs} args - Arguments to create a Warehouse.
     * @example
     * // Create one Warehouse
     * const Warehouse = await prisma.warehouse.create({
     *   data: {
     *     // ... data to create a Warehouse
     *   }
     * })
     * 
     */
    create<T extends warehouseCreateArgs>(args: SelectSubset<T, warehouseCreateArgs<ExtArgs>>): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Warehouses.
     * @param {warehouseCreateManyArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends warehouseCreateManyArgs>(args?: SelectSubset<T, warehouseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Warehouses and returns the data saved in the database.
     * @param {warehouseCreateManyAndReturnArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends warehouseCreateManyAndReturnArgs>(args?: SelectSubset<T, warehouseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Warehouse.
     * @param {warehouseDeleteArgs} args - Arguments to delete one Warehouse.
     * @example
     * // Delete one Warehouse
     * const Warehouse = await prisma.warehouse.delete({
     *   where: {
     *     // ... filter to delete one Warehouse
     *   }
     * })
     * 
     */
    delete<T extends warehouseDeleteArgs>(args: SelectSubset<T, warehouseDeleteArgs<ExtArgs>>): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Warehouse.
     * @param {warehouseUpdateArgs} args - Arguments to update one Warehouse.
     * @example
     * // Update one Warehouse
     * const warehouse = await prisma.warehouse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends warehouseUpdateArgs>(args: SelectSubset<T, warehouseUpdateArgs<ExtArgs>>): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Warehouses.
     * @param {warehouseDeleteManyArgs} args - Arguments to filter Warehouses to delete.
     * @example
     * // Delete a few Warehouses
     * const { count } = await prisma.warehouse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends warehouseDeleteManyArgs>(args?: SelectSubset<T, warehouseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warehouseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends warehouseUpdateManyArgs>(args: SelectSubset<T, warehouseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses and returns the data updated in the database.
     * @param {warehouseUpdateManyAndReturnArgs} args - Arguments to update many Warehouses.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends warehouseUpdateManyAndReturnArgs>(args: SelectSubset<T, warehouseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Warehouse.
     * @param {warehouseUpsertArgs} args - Arguments to update or create a Warehouse.
     * @example
     * // Update or create a Warehouse
     * const warehouse = await prisma.warehouse.upsert({
     *   create: {
     *     // ... data to create a Warehouse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Warehouse we want to update
     *   }
     * })
     */
    upsert<T extends warehouseUpsertArgs>(args: SelectSubset<T, warehouseUpsertArgs<ExtArgs>>): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warehouseCountArgs} args - Arguments to filter Warehouses to count.
     * @example
     * // Count the number of Warehouses
     * const count = await prisma.warehouse.count({
     *   where: {
     *     // ... the filter for the Warehouses we want to count
     *   }
     * })
    **/
    count<T extends warehouseCountArgs>(
      args?: Subset<T, warehouseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseAggregateArgs>(args: Subset<T, WarehouseAggregateArgs>): Prisma.PrismaPromise<GetWarehouseAggregateType<T>>

    /**
     * Group by Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warehouseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends warehouseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: warehouseGroupByArgs['orderBy'] }
        : { orderBy?: warehouseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, warehouseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the warehouse model
   */
  readonly fields: warehouseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for warehouse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__warehouseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mekanik<T extends warehouse$mekanikArgs<ExtArgs> = {}>(args?: Subset<T, warehouse$mekanikArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mekanikPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    order_barang_order_barang_from_warehouse_idTowarehouse<T extends warehouse$order_barang_order_barang_from_warehouse_idTowarehouseArgs<ExtArgs> = {}>(args?: Subset<T, warehouse$order_barang_order_barang_from_warehouse_idTowarehouseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_barangPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    order_barang_order_barang_to_warehouse_idTowarehouse<T extends warehouse$order_barang_order_barang_to_warehouse_idTowarehouseArgs<ExtArgs> = {}>(args?: Subset<T, warehouse$order_barang_order_barang_to_warehouse_idTowarehouseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_barangPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transaksi<T extends warehouse$transaksiArgs<ExtArgs> = {}>(args?: Subset<T, warehouse$transaksiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    level<T extends levelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, levelDefaultArgs<ExtArgs>>): Prisma__levelClient<$Result.GetResult<Prisma.$levelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    warehouse_inventory<T extends warehouse$warehouse_inventoryArgs<ExtArgs> = {}>(args?: Subset<T, warehouse$warehouse_inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$warehouse_inventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the warehouse model
   */
  interface warehouseFieldRefs {
    readonly id: FieldRef<"warehouse", 'String'>
    readonly level_id: FieldRef<"warehouse", 'String'>
    readonly name_warehouse: FieldRef<"warehouse", 'String'>
    readonly username: FieldRef<"warehouse", 'String'>
    readonly password: FieldRef<"warehouse", 'String'>
    readonly warehouse_address: FieldRef<"warehouse", 'String'>
    readonly phone_number_warehouse: FieldRef<"warehouse", 'String'>
    readonly createdAt: FieldRef<"warehouse", 'DateTime'>
    readonly updatedAt: FieldRef<"warehouse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * warehouse findUnique
   */
  export type warehouseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse
     */
    omit?: warehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouseInclude<ExtArgs> | null
    /**
     * Filter, which warehouse to fetch.
     */
    where: warehouseWhereUniqueInput
  }

  /**
   * warehouse findUniqueOrThrow
   */
  export type warehouseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse
     */
    omit?: warehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouseInclude<ExtArgs> | null
    /**
     * Filter, which warehouse to fetch.
     */
    where: warehouseWhereUniqueInput
  }

  /**
   * warehouse findFirst
   */
  export type warehouseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse
     */
    omit?: warehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouseInclude<ExtArgs> | null
    /**
     * Filter, which warehouse to fetch.
     */
    where?: warehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warehouses to fetch.
     */
    orderBy?: warehouseOrderByWithRelationInput | warehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for warehouses.
     */
    cursor?: warehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * warehouse findFirstOrThrow
   */
  export type warehouseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse
     */
    omit?: warehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouseInclude<ExtArgs> | null
    /**
     * Filter, which warehouse to fetch.
     */
    where?: warehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warehouses to fetch.
     */
    orderBy?: warehouseOrderByWithRelationInput | warehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for warehouses.
     */
    cursor?: warehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * warehouse findMany
   */
  export type warehouseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse
     */
    omit?: warehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouseInclude<ExtArgs> | null
    /**
     * Filter, which warehouses to fetch.
     */
    where?: warehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warehouses to fetch.
     */
    orderBy?: warehouseOrderByWithRelationInput | warehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing warehouses.
     */
    cursor?: warehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warehouses.
     */
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * warehouse create
   */
  export type warehouseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse
     */
    omit?: warehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouseInclude<ExtArgs> | null
    /**
     * The data needed to create a warehouse.
     */
    data: XOR<warehouseCreateInput, warehouseUncheckedCreateInput>
  }

  /**
   * warehouse createMany
   */
  export type warehouseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many warehouses.
     */
    data: warehouseCreateManyInput | warehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * warehouse createManyAndReturn
   */
  export type warehouseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse
     */
    omit?: warehouseOmit<ExtArgs> | null
    /**
     * The data used to create many warehouses.
     */
    data: warehouseCreateManyInput | warehouseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * warehouse update
   */
  export type warehouseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse
     */
    omit?: warehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouseInclude<ExtArgs> | null
    /**
     * The data needed to update a warehouse.
     */
    data: XOR<warehouseUpdateInput, warehouseUncheckedUpdateInput>
    /**
     * Choose, which warehouse to update.
     */
    where: warehouseWhereUniqueInput
  }

  /**
   * warehouse updateMany
   */
  export type warehouseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update warehouses.
     */
    data: XOR<warehouseUpdateManyMutationInput, warehouseUncheckedUpdateManyInput>
    /**
     * Filter which warehouses to update
     */
    where?: warehouseWhereInput
    /**
     * Limit how many warehouses to update.
     */
    limit?: number
  }

  /**
   * warehouse updateManyAndReturn
   */
  export type warehouseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse
     */
    omit?: warehouseOmit<ExtArgs> | null
    /**
     * The data used to update warehouses.
     */
    data: XOR<warehouseUpdateManyMutationInput, warehouseUncheckedUpdateManyInput>
    /**
     * Filter which warehouses to update
     */
    where?: warehouseWhereInput
    /**
     * Limit how many warehouses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * warehouse upsert
   */
  export type warehouseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse
     */
    omit?: warehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouseInclude<ExtArgs> | null
    /**
     * The filter to search for the warehouse to update in case it exists.
     */
    where: warehouseWhereUniqueInput
    /**
     * In case the warehouse found by the `where` argument doesn't exist, create a new warehouse with this data.
     */
    create: XOR<warehouseCreateInput, warehouseUncheckedCreateInput>
    /**
     * In case the warehouse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<warehouseUpdateInput, warehouseUncheckedUpdateInput>
  }

  /**
   * warehouse delete
   */
  export type warehouseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse
     */
    omit?: warehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouseInclude<ExtArgs> | null
    /**
     * Filter which warehouse to delete.
     */
    where: warehouseWhereUniqueInput
  }

  /**
   * warehouse deleteMany
   */
  export type warehouseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which warehouses to delete
     */
    where?: warehouseWhereInput
    /**
     * Limit how many warehouses to delete.
     */
    limit?: number
  }

  /**
   * warehouse.mekanik
   */
  export type warehouse$mekanikArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mekanik
     */
    select?: mekanikSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mekanik
     */
    omit?: mekanikOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mekanikInclude<ExtArgs> | null
    where?: mekanikWhereInput
    orderBy?: mekanikOrderByWithRelationInput | mekanikOrderByWithRelationInput[]
    cursor?: mekanikWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MekanikScalarFieldEnum | MekanikScalarFieldEnum[]
  }

  /**
   * warehouse.order_barang_order_barang_from_warehouse_idTowarehouse
   */
  export type warehouse$order_barang_order_barang_from_warehouse_idTowarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang
     */
    select?: order_barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang
     */
    omit?: order_barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barangInclude<ExtArgs> | null
    where?: order_barangWhereInput
    orderBy?: order_barangOrderByWithRelationInput | order_barangOrderByWithRelationInput[]
    cursor?: order_barangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_barangScalarFieldEnum | Order_barangScalarFieldEnum[]
  }

  /**
   * warehouse.order_barang_order_barang_to_warehouse_idTowarehouse
   */
  export type warehouse$order_barang_order_barang_to_warehouse_idTowarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_barang
     */
    select?: order_barangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_barang
     */
    omit?: order_barangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_barangInclude<ExtArgs> | null
    where?: order_barangWhereInput
    orderBy?: order_barangOrderByWithRelationInput | order_barangOrderByWithRelationInput[]
    cursor?: order_barangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_barangScalarFieldEnum | Order_barangScalarFieldEnum[]
  }

  /**
   * warehouse.transaksi
   */
  export type warehouse$transaksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaksi
     */
    omit?: transaksiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    where?: transaksiWhereInput
    orderBy?: transaksiOrderByWithRelationInput | transaksiOrderByWithRelationInput[]
    cursor?: transaksiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransaksiScalarFieldEnum | TransaksiScalarFieldEnum[]
  }

  /**
   * warehouse.warehouse_inventory
   */
  export type warehouse$warehouse_inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse_inventory
     */
    select?: warehouse_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse_inventory
     */
    omit?: warehouse_inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouse_inventoryInclude<ExtArgs> | null
    where?: warehouse_inventoryWhereInput
    orderBy?: warehouse_inventoryOrderByWithRelationInput | warehouse_inventoryOrderByWithRelationInput[]
    cursor?: warehouse_inventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Warehouse_inventoryScalarFieldEnum | Warehouse_inventoryScalarFieldEnum[]
  }

  /**
   * warehouse without action
   */
  export type warehouseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse
     */
    omit?: warehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouseInclude<ExtArgs> | null
  }


  /**
   * Model warehouse_inventory
   */

  export type AggregateWarehouse_inventory = {
    _count: Warehouse_inventoryCountAggregateOutputType | null
    _min: Warehouse_inventoryMinAggregateOutputType | null
    _max: Warehouse_inventoryMaxAggregateOutputType | null
  }

  export type Warehouse_inventoryMinAggregateOutputType = {
    id: string | null
    warehouse_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Warehouse_inventoryMaxAggregateOutputType = {
    id: string | null
    warehouse_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Warehouse_inventoryCountAggregateOutputType = {
    id: number
    warehouse_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Warehouse_inventoryMinAggregateInputType = {
    id?: true
    warehouse_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Warehouse_inventoryMaxAggregateInputType = {
    id?: true
    warehouse_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Warehouse_inventoryCountAggregateInputType = {
    id?: true
    warehouse_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Warehouse_inventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which warehouse_inventory to aggregate.
     */
    where?: warehouse_inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warehouse_inventories to fetch.
     */
    orderBy?: warehouse_inventoryOrderByWithRelationInput | warehouse_inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: warehouse_inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warehouse_inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warehouse_inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned warehouse_inventories
    **/
    _count?: true | Warehouse_inventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Warehouse_inventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Warehouse_inventoryMaxAggregateInputType
  }

  export type GetWarehouse_inventoryAggregateType<T extends Warehouse_inventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouse_inventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouse_inventory[P]>
      : GetScalarType<T[P], AggregateWarehouse_inventory[P]>
  }




  export type warehouse_inventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: warehouse_inventoryWhereInput
    orderBy?: warehouse_inventoryOrderByWithAggregationInput | warehouse_inventoryOrderByWithAggregationInput[]
    by: Warehouse_inventoryScalarFieldEnum[] | Warehouse_inventoryScalarFieldEnum
    having?: warehouse_inventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Warehouse_inventoryCountAggregateInputType | true
    _min?: Warehouse_inventoryMinAggregateInputType
    _max?: Warehouse_inventoryMaxAggregateInputType
  }

  export type Warehouse_inventoryGroupByOutputType = {
    id: string
    warehouse_id: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: Warehouse_inventoryCountAggregateOutputType | null
    _min: Warehouse_inventoryMinAggregateOutputType | null
    _max: Warehouse_inventoryMaxAggregateOutputType | null
  }

  type GetWarehouse_inventoryGroupByPayload<T extends warehouse_inventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Warehouse_inventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Warehouse_inventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Warehouse_inventoryGroupByOutputType[P]>
            : GetScalarType<T[P], Warehouse_inventoryGroupByOutputType[P]>
        }
      >
    >


  export type warehouse_inventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    warehouse_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventory?: boolean | warehouse_inventory$inventoryArgs<ExtArgs>
    warehouse?: boolean | warehouseDefaultArgs<ExtArgs>
    _count?: boolean | Warehouse_inventoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse_inventory"]>

  export type warehouse_inventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    warehouse_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | warehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse_inventory"]>

  export type warehouse_inventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    warehouse_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | warehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse_inventory"]>

  export type warehouse_inventorySelectScalar = {
    id?: boolean
    warehouse_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type warehouse_inventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "warehouse_id" | "createdAt" | "updatedAt", ExtArgs["result"]["warehouse_inventory"]>
  export type warehouse_inventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | warehouse_inventory$inventoryArgs<ExtArgs>
    warehouse?: boolean | warehouseDefaultArgs<ExtArgs>
    _count?: boolean | Warehouse_inventoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type warehouse_inventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | warehouseDefaultArgs<ExtArgs>
  }
  export type warehouse_inventoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | warehouseDefaultArgs<ExtArgs>
  }

  export type $warehouse_inventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "warehouse_inventory"
    objects: {
      inventory: Prisma.$inventoryPayload<ExtArgs>[]
      warehouse: Prisma.$warehousePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      warehouse_id: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["warehouse_inventory"]>
    composites: {}
  }

  type warehouse_inventoryGetPayload<S extends boolean | null | undefined | warehouse_inventoryDefaultArgs> = $Result.GetResult<Prisma.$warehouse_inventoryPayload, S>

  type warehouse_inventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<warehouse_inventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Warehouse_inventoryCountAggregateInputType | true
    }

  export interface warehouse_inventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['warehouse_inventory'], meta: { name: 'warehouse_inventory' } }
    /**
     * Find zero or one Warehouse_inventory that matches the filter.
     * @param {warehouse_inventoryFindUniqueArgs} args - Arguments to find a Warehouse_inventory
     * @example
     * // Get one Warehouse_inventory
     * const warehouse_inventory = await prisma.warehouse_inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends warehouse_inventoryFindUniqueArgs>(args: SelectSubset<T, warehouse_inventoryFindUniqueArgs<ExtArgs>>): Prisma__warehouse_inventoryClient<$Result.GetResult<Prisma.$warehouse_inventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Warehouse_inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {warehouse_inventoryFindUniqueOrThrowArgs} args - Arguments to find a Warehouse_inventory
     * @example
     * // Get one Warehouse_inventory
     * const warehouse_inventory = await prisma.warehouse_inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends warehouse_inventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, warehouse_inventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__warehouse_inventoryClient<$Result.GetResult<Prisma.$warehouse_inventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse_inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warehouse_inventoryFindFirstArgs} args - Arguments to find a Warehouse_inventory
     * @example
     * // Get one Warehouse_inventory
     * const warehouse_inventory = await prisma.warehouse_inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends warehouse_inventoryFindFirstArgs>(args?: SelectSubset<T, warehouse_inventoryFindFirstArgs<ExtArgs>>): Prisma__warehouse_inventoryClient<$Result.GetResult<Prisma.$warehouse_inventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse_inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warehouse_inventoryFindFirstOrThrowArgs} args - Arguments to find a Warehouse_inventory
     * @example
     * // Get one Warehouse_inventory
     * const warehouse_inventory = await prisma.warehouse_inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends warehouse_inventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, warehouse_inventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__warehouse_inventoryClient<$Result.GetResult<Prisma.$warehouse_inventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Warehouse_inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warehouse_inventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Warehouse_inventories
     * const warehouse_inventories = await prisma.warehouse_inventory.findMany()
     * 
     * // Get first 10 Warehouse_inventories
     * const warehouse_inventories = await prisma.warehouse_inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouse_inventoryWithIdOnly = await prisma.warehouse_inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends warehouse_inventoryFindManyArgs>(args?: SelectSubset<T, warehouse_inventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$warehouse_inventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Warehouse_inventory.
     * @param {warehouse_inventoryCreateArgs} args - Arguments to create a Warehouse_inventory.
     * @example
     * // Create one Warehouse_inventory
     * const Warehouse_inventory = await prisma.warehouse_inventory.create({
     *   data: {
     *     // ... data to create a Warehouse_inventory
     *   }
     * })
     * 
     */
    create<T extends warehouse_inventoryCreateArgs>(args: SelectSubset<T, warehouse_inventoryCreateArgs<ExtArgs>>): Prisma__warehouse_inventoryClient<$Result.GetResult<Prisma.$warehouse_inventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Warehouse_inventories.
     * @param {warehouse_inventoryCreateManyArgs} args - Arguments to create many Warehouse_inventories.
     * @example
     * // Create many Warehouse_inventories
     * const warehouse_inventory = await prisma.warehouse_inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends warehouse_inventoryCreateManyArgs>(args?: SelectSubset<T, warehouse_inventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Warehouse_inventories and returns the data saved in the database.
     * @param {warehouse_inventoryCreateManyAndReturnArgs} args - Arguments to create many Warehouse_inventories.
     * @example
     * // Create many Warehouse_inventories
     * const warehouse_inventory = await prisma.warehouse_inventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Warehouse_inventories and only return the `id`
     * const warehouse_inventoryWithIdOnly = await prisma.warehouse_inventory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends warehouse_inventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, warehouse_inventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$warehouse_inventoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Warehouse_inventory.
     * @param {warehouse_inventoryDeleteArgs} args - Arguments to delete one Warehouse_inventory.
     * @example
     * // Delete one Warehouse_inventory
     * const Warehouse_inventory = await prisma.warehouse_inventory.delete({
     *   where: {
     *     // ... filter to delete one Warehouse_inventory
     *   }
     * })
     * 
     */
    delete<T extends warehouse_inventoryDeleteArgs>(args: SelectSubset<T, warehouse_inventoryDeleteArgs<ExtArgs>>): Prisma__warehouse_inventoryClient<$Result.GetResult<Prisma.$warehouse_inventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Warehouse_inventory.
     * @param {warehouse_inventoryUpdateArgs} args - Arguments to update one Warehouse_inventory.
     * @example
     * // Update one Warehouse_inventory
     * const warehouse_inventory = await prisma.warehouse_inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends warehouse_inventoryUpdateArgs>(args: SelectSubset<T, warehouse_inventoryUpdateArgs<ExtArgs>>): Prisma__warehouse_inventoryClient<$Result.GetResult<Prisma.$warehouse_inventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Warehouse_inventories.
     * @param {warehouse_inventoryDeleteManyArgs} args - Arguments to filter Warehouse_inventories to delete.
     * @example
     * // Delete a few Warehouse_inventories
     * const { count } = await prisma.warehouse_inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends warehouse_inventoryDeleteManyArgs>(args?: SelectSubset<T, warehouse_inventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouse_inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warehouse_inventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Warehouse_inventories
     * const warehouse_inventory = await prisma.warehouse_inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends warehouse_inventoryUpdateManyArgs>(args: SelectSubset<T, warehouse_inventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouse_inventories and returns the data updated in the database.
     * @param {warehouse_inventoryUpdateManyAndReturnArgs} args - Arguments to update many Warehouse_inventories.
     * @example
     * // Update many Warehouse_inventories
     * const warehouse_inventory = await prisma.warehouse_inventory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Warehouse_inventories and only return the `id`
     * const warehouse_inventoryWithIdOnly = await prisma.warehouse_inventory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends warehouse_inventoryUpdateManyAndReturnArgs>(args: SelectSubset<T, warehouse_inventoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$warehouse_inventoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Warehouse_inventory.
     * @param {warehouse_inventoryUpsertArgs} args - Arguments to update or create a Warehouse_inventory.
     * @example
     * // Update or create a Warehouse_inventory
     * const warehouse_inventory = await prisma.warehouse_inventory.upsert({
     *   create: {
     *     // ... data to create a Warehouse_inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Warehouse_inventory we want to update
     *   }
     * })
     */
    upsert<T extends warehouse_inventoryUpsertArgs>(args: SelectSubset<T, warehouse_inventoryUpsertArgs<ExtArgs>>): Prisma__warehouse_inventoryClient<$Result.GetResult<Prisma.$warehouse_inventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Warehouse_inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warehouse_inventoryCountArgs} args - Arguments to filter Warehouse_inventories to count.
     * @example
     * // Count the number of Warehouse_inventories
     * const count = await prisma.warehouse_inventory.count({
     *   where: {
     *     // ... the filter for the Warehouse_inventories we want to count
     *   }
     * })
    **/
    count<T extends warehouse_inventoryCountArgs>(
      args?: Subset<T, warehouse_inventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Warehouse_inventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Warehouse_inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Warehouse_inventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Warehouse_inventoryAggregateArgs>(args: Subset<T, Warehouse_inventoryAggregateArgs>): Prisma.PrismaPromise<GetWarehouse_inventoryAggregateType<T>>

    /**
     * Group by Warehouse_inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warehouse_inventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends warehouse_inventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: warehouse_inventoryGroupByArgs['orderBy'] }
        : { orderBy?: warehouse_inventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, warehouse_inventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouse_inventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the warehouse_inventory model
   */
  readonly fields: warehouse_inventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for warehouse_inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__warehouse_inventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventory<T extends warehouse_inventory$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, warehouse_inventory$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    warehouse<T extends warehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, warehouseDefaultArgs<ExtArgs>>): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the warehouse_inventory model
   */
  interface warehouse_inventoryFieldRefs {
    readonly id: FieldRef<"warehouse_inventory", 'String'>
    readonly warehouse_id: FieldRef<"warehouse_inventory", 'String'>
    readonly createdAt: FieldRef<"warehouse_inventory", 'DateTime'>
    readonly updatedAt: FieldRef<"warehouse_inventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * warehouse_inventory findUnique
   */
  export type warehouse_inventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse_inventory
     */
    select?: warehouse_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse_inventory
     */
    omit?: warehouse_inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouse_inventoryInclude<ExtArgs> | null
    /**
     * Filter, which warehouse_inventory to fetch.
     */
    where: warehouse_inventoryWhereUniqueInput
  }

  /**
   * warehouse_inventory findUniqueOrThrow
   */
  export type warehouse_inventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse_inventory
     */
    select?: warehouse_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse_inventory
     */
    omit?: warehouse_inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouse_inventoryInclude<ExtArgs> | null
    /**
     * Filter, which warehouse_inventory to fetch.
     */
    where: warehouse_inventoryWhereUniqueInput
  }

  /**
   * warehouse_inventory findFirst
   */
  export type warehouse_inventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse_inventory
     */
    select?: warehouse_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse_inventory
     */
    omit?: warehouse_inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouse_inventoryInclude<ExtArgs> | null
    /**
     * Filter, which warehouse_inventory to fetch.
     */
    where?: warehouse_inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warehouse_inventories to fetch.
     */
    orderBy?: warehouse_inventoryOrderByWithRelationInput | warehouse_inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for warehouse_inventories.
     */
    cursor?: warehouse_inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warehouse_inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warehouse_inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of warehouse_inventories.
     */
    distinct?: Warehouse_inventoryScalarFieldEnum | Warehouse_inventoryScalarFieldEnum[]
  }

  /**
   * warehouse_inventory findFirstOrThrow
   */
  export type warehouse_inventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse_inventory
     */
    select?: warehouse_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse_inventory
     */
    omit?: warehouse_inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouse_inventoryInclude<ExtArgs> | null
    /**
     * Filter, which warehouse_inventory to fetch.
     */
    where?: warehouse_inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warehouse_inventories to fetch.
     */
    orderBy?: warehouse_inventoryOrderByWithRelationInput | warehouse_inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for warehouse_inventories.
     */
    cursor?: warehouse_inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warehouse_inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warehouse_inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of warehouse_inventories.
     */
    distinct?: Warehouse_inventoryScalarFieldEnum | Warehouse_inventoryScalarFieldEnum[]
  }

  /**
   * warehouse_inventory findMany
   */
  export type warehouse_inventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse_inventory
     */
    select?: warehouse_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse_inventory
     */
    omit?: warehouse_inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouse_inventoryInclude<ExtArgs> | null
    /**
     * Filter, which warehouse_inventories to fetch.
     */
    where?: warehouse_inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warehouse_inventories to fetch.
     */
    orderBy?: warehouse_inventoryOrderByWithRelationInput | warehouse_inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing warehouse_inventories.
     */
    cursor?: warehouse_inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warehouse_inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warehouse_inventories.
     */
    skip?: number
    distinct?: Warehouse_inventoryScalarFieldEnum | Warehouse_inventoryScalarFieldEnum[]
  }

  /**
   * warehouse_inventory create
   */
  export type warehouse_inventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse_inventory
     */
    select?: warehouse_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse_inventory
     */
    omit?: warehouse_inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouse_inventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a warehouse_inventory.
     */
    data: XOR<warehouse_inventoryCreateInput, warehouse_inventoryUncheckedCreateInput>
  }

  /**
   * warehouse_inventory createMany
   */
  export type warehouse_inventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many warehouse_inventories.
     */
    data: warehouse_inventoryCreateManyInput | warehouse_inventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * warehouse_inventory createManyAndReturn
   */
  export type warehouse_inventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse_inventory
     */
    select?: warehouse_inventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse_inventory
     */
    omit?: warehouse_inventoryOmit<ExtArgs> | null
    /**
     * The data used to create many warehouse_inventories.
     */
    data: warehouse_inventoryCreateManyInput | warehouse_inventoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouse_inventoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * warehouse_inventory update
   */
  export type warehouse_inventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse_inventory
     */
    select?: warehouse_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse_inventory
     */
    omit?: warehouse_inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouse_inventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a warehouse_inventory.
     */
    data: XOR<warehouse_inventoryUpdateInput, warehouse_inventoryUncheckedUpdateInput>
    /**
     * Choose, which warehouse_inventory to update.
     */
    where: warehouse_inventoryWhereUniqueInput
  }

  /**
   * warehouse_inventory updateMany
   */
  export type warehouse_inventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update warehouse_inventories.
     */
    data: XOR<warehouse_inventoryUpdateManyMutationInput, warehouse_inventoryUncheckedUpdateManyInput>
    /**
     * Filter which warehouse_inventories to update
     */
    where?: warehouse_inventoryWhereInput
    /**
     * Limit how many warehouse_inventories to update.
     */
    limit?: number
  }

  /**
   * warehouse_inventory updateManyAndReturn
   */
  export type warehouse_inventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse_inventory
     */
    select?: warehouse_inventorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse_inventory
     */
    omit?: warehouse_inventoryOmit<ExtArgs> | null
    /**
     * The data used to update warehouse_inventories.
     */
    data: XOR<warehouse_inventoryUpdateManyMutationInput, warehouse_inventoryUncheckedUpdateManyInput>
    /**
     * Filter which warehouse_inventories to update
     */
    where?: warehouse_inventoryWhereInput
    /**
     * Limit how many warehouse_inventories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouse_inventoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * warehouse_inventory upsert
   */
  export type warehouse_inventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse_inventory
     */
    select?: warehouse_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse_inventory
     */
    omit?: warehouse_inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouse_inventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the warehouse_inventory to update in case it exists.
     */
    where: warehouse_inventoryWhereUniqueInput
    /**
     * In case the warehouse_inventory found by the `where` argument doesn't exist, create a new warehouse_inventory with this data.
     */
    create: XOR<warehouse_inventoryCreateInput, warehouse_inventoryUncheckedCreateInput>
    /**
     * In case the warehouse_inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<warehouse_inventoryUpdateInput, warehouse_inventoryUncheckedUpdateInput>
  }

  /**
   * warehouse_inventory delete
   */
  export type warehouse_inventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse_inventory
     */
    select?: warehouse_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse_inventory
     */
    omit?: warehouse_inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouse_inventoryInclude<ExtArgs> | null
    /**
     * Filter which warehouse_inventory to delete.
     */
    where: warehouse_inventoryWhereUniqueInput
  }

  /**
   * warehouse_inventory deleteMany
   */
  export type warehouse_inventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which warehouse_inventories to delete
     */
    where?: warehouse_inventoryWhereInput
    /**
     * Limit how many warehouse_inventories to delete.
     */
    limit?: number
  }

  /**
   * warehouse_inventory.inventory
   */
  export type warehouse_inventory$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    where?: inventoryWhereInput
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    cursor?: inventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * warehouse_inventory without action
   */
  export type warehouse_inventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse_inventory
     */
    select?: warehouse_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the warehouse_inventory
     */
    omit?: warehouse_inventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warehouse_inventoryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BarangScalarFieldEnum: {
    id: 'id',
    category_vehicle_id: 'category_vehicle_id',
    name_barang: 'name_barang',
    description_barang: 'description_barang',
    price: 'price',
    point: 'point',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BarangScalarFieldEnum = (typeof BarangScalarFieldEnum)[keyof typeof BarangScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    status_id: 'status_id',
    name: 'name',
    point: 'point',
    address: 'address',
    phone_number: 'phone_number',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    warehouse_inventory_id: 'warehouse_inventory_id',
    barang_id: 'barang_id',
    qty: 'qty',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const LevelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LevelScalarFieldEnum = (typeof LevelScalarFieldEnum)[keyof typeof LevelScalarFieldEnum]


  export const MekanikScalarFieldEnum: {
    id: 'id',
    employee_id: 'employee_id',
    warehouse_id: 'warehouse_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MekanikScalarFieldEnum = (typeof MekanikScalarFieldEnum)[keyof typeof MekanikScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const Order_barangScalarFieldEnum: {
    id: 'id',
    from_warehouse_id: 'from_warehouse_id',
    to_warehouse_id: 'to_warehouse_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Order_barangScalarFieldEnum = (typeof Order_barangScalarFieldEnum)[keyof typeof Order_barangScalarFieldEnum]


  export const Order_barang_detailScalarFieldEnum: {
    id: 'id',
    order_barang_id: 'order_barang_id',
    barang_id: 'barang_id',
    qty: 'qty',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Order_barang_detailScalarFieldEnum = (typeof Order_barang_detailScalarFieldEnum)[keyof typeof Order_barang_detailScalarFieldEnum]


  export const StatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StatusScalarFieldEnum = (typeof StatusScalarFieldEnum)[keyof typeof StatusScalarFieldEnum]


  export const TransaksiScalarFieldEnum: {
    id: 'id',
    users_id: 'users_id',
    mekanik_id: 'mekanik_id',
    warehouse_id: 'warehouse_id',
    point: 'point',
    total: 'total',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransaksiScalarFieldEnum = (typeof TransaksiScalarFieldEnum)[keyof typeof TransaksiScalarFieldEnum]


  export const Transaksi_detailScalarFieldEnum: {
    id: 'id',
    transaksi_id: 'transaksi_id',
    barang_id: 'barang_id',
    qty: 'qty',
    sub_total: 'sub_total',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Transaksi_detailScalarFieldEnum = (typeof Transaksi_detailScalarFieldEnum)[keyof typeof Transaksi_detailScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    status_id: 'status_id',
    member_id: 'member_id',
    vehicle_year_id: 'vehicle_year_id',
    vehicle_merk_id: 'vehicle_merk_id',
    vehicle_type_id: 'vehicle_type_id',
    no_police: 'no_police',
    name: 'name',
    point: 'point',
    address: 'address',
    phone_number: 'phone_number',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const Vehicle_categoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Vehicle_categoryScalarFieldEnum = (typeof Vehicle_categoryScalarFieldEnum)[keyof typeof Vehicle_categoryScalarFieldEnum]


  export const Vehicle_merkScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Vehicle_merkScalarFieldEnum = (typeof Vehicle_merkScalarFieldEnum)[keyof typeof Vehicle_merkScalarFieldEnum]


  export const Vehicle_typeScalarFieldEnum: {
    id: 'id',
    vehicle_category_id: 'vehicle_category_id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Vehicle_typeScalarFieldEnum = (typeof Vehicle_typeScalarFieldEnum)[keyof typeof Vehicle_typeScalarFieldEnum]


  export const Vehicle_yearScalarFieldEnum: {
    id: 'id',
    year: 'year',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Vehicle_yearScalarFieldEnum = (typeof Vehicle_yearScalarFieldEnum)[keyof typeof Vehicle_yearScalarFieldEnum]


  export const WarehouseScalarFieldEnum: {
    id: 'id',
    level_id: 'level_id',
    name_warehouse: 'name_warehouse',
    username: 'username',
    password: 'password',
    warehouse_address: 'warehouse_address',
    phone_number_warehouse: 'phone_number_warehouse',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WarehouseScalarFieldEnum = (typeof WarehouseScalarFieldEnum)[keyof typeof WarehouseScalarFieldEnum]


  export const Warehouse_inventoryScalarFieldEnum: {
    id: 'id',
    warehouse_id: 'warehouse_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Warehouse_inventoryScalarFieldEnum = (typeof Warehouse_inventoryScalarFieldEnum)[keyof typeof Warehouse_inventoryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type barangWhereInput = {
    AND?: barangWhereInput | barangWhereInput[]
    OR?: barangWhereInput[]
    NOT?: barangWhereInput | barangWhereInput[]
    id?: StringFilter<"barang"> | string
    category_vehicle_id?: StringFilter<"barang"> | string
    name_barang?: StringFilter<"barang"> | string
    description_barang?: StringNullableFilter<"barang"> | string | null
    price?: DecimalFilter<"barang"> | Decimal | DecimalJsLike | number | string
    point?: IntNullableFilter<"barang"> | number | null
    createdAt?: DateTimeNullableFilter<"barang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"barang"> | Date | string | null
    vehicle_category?: XOR<Vehicle_categoryScalarRelationFilter, vehicle_categoryWhereInput>
    inventory?: InventoryListRelationFilter
    order_barang_detail?: Order_barang_detailListRelationFilter
    transaksi_detail?: Transaksi_detailListRelationFilter
  }

  export type barangOrderByWithRelationInput = {
    id?: SortOrder
    category_vehicle_id?: SortOrder
    name_barang?: SortOrder
    description_barang?: SortOrderInput | SortOrder
    price?: SortOrder
    point?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    vehicle_category?: vehicle_categoryOrderByWithRelationInput
    inventory?: inventoryOrderByRelationAggregateInput
    order_barang_detail?: order_barang_detailOrderByRelationAggregateInput
    transaksi_detail?: transaksi_detailOrderByRelationAggregateInput
  }

  export type barangWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: barangWhereInput | barangWhereInput[]
    OR?: barangWhereInput[]
    NOT?: barangWhereInput | barangWhereInput[]
    category_vehicle_id?: StringFilter<"barang"> | string
    name_barang?: StringFilter<"barang"> | string
    description_barang?: StringNullableFilter<"barang"> | string | null
    price?: DecimalFilter<"barang"> | Decimal | DecimalJsLike | number | string
    point?: IntNullableFilter<"barang"> | number | null
    createdAt?: DateTimeNullableFilter<"barang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"barang"> | Date | string | null
    vehicle_category?: XOR<Vehicle_categoryScalarRelationFilter, vehicle_categoryWhereInput>
    inventory?: InventoryListRelationFilter
    order_barang_detail?: Order_barang_detailListRelationFilter
    transaksi_detail?: Transaksi_detailListRelationFilter
  }, "id">

  export type barangOrderByWithAggregationInput = {
    id?: SortOrder
    category_vehicle_id?: SortOrder
    name_barang?: SortOrder
    description_barang?: SortOrderInput | SortOrder
    price?: SortOrder
    point?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: barangCountOrderByAggregateInput
    _avg?: barangAvgOrderByAggregateInput
    _max?: barangMaxOrderByAggregateInput
    _min?: barangMinOrderByAggregateInput
    _sum?: barangSumOrderByAggregateInput
  }

  export type barangScalarWhereWithAggregatesInput = {
    AND?: barangScalarWhereWithAggregatesInput | barangScalarWhereWithAggregatesInput[]
    OR?: barangScalarWhereWithAggregatesInput[]
    NOT?: barangScalarWhereWithAggregatesInput | barangScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"barang"> | string
    category_vehicle_id?: StringWithAggregatesFilter<"barang"> | string
    name_barang?: StringWithAggregatesFilter<"barang"> | string
    description_barang?: StringNullableWithAggregatesFilter<"barang"> | string | null
    price?: DecimalWithAggregatesFilter<"barang"> | Decimal | DecimalJsLike | number | string
    point?: IntNullableWithAggregatesFilter<"barang"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"barang"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"barang"> | Date | string | null
  }

  export type employeeWhereInput = {
    AND?: employeeWhereInput | employeeWhereInput[]
    OR?: employeeWhereInput[]
    NOT?: employeeWhereInput | employeeWhereInput[]
    id?: StringFilter<"employee"> | string
    status_id?: StringFilter<"employee"> | string
    name?: StringFilter<"employee"> | string
    point?: IntNullableFilter<"employee"> | number | null
    address?: StringNullableFilter<"employee"> | string | null
    phone_number?: StringNullableFilter<"employee"> | string | null
    createdAt?: DateTimeNullableFilter<"employee"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"employee"> | Date | string | null
    status?: XOR<StatusScalarRelationFilter, statusWhereInput>
    mekanik?: MekanikListRelationFilter
  }

  export type employeeOrderByWithRelationInput = {
    id?: SortOrder
    status_id?: SortOrder
    name?: SortOrder
    point?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    status?: statusOrderByWithRelationInput
    mekanik?: mekanikOrderByRelationAggregateInput
  }

  export type employeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: employeeWhereInput | employeeWhereInput[]
    OR?: employeeWhereInput[]
    NOT?: employeeWhereInput | employeeWhereInput[]
    status_id?: StringFilter<"employee"> | string
    name?: StringFilter<"employee"> | string
    point?: IntNullableFilter<"employee"> | number | null
    address?: StringNullableFilter<"employee"> | string | null
    phone_number?: StringNullableFilter<"employee"> | string | null
    createdAt?: DateTimeNullableFilter<"employee"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"employee"> | Date | string | null
    status?: XOR<StatusScalarRelationFilter, statusWhereInput>
    mekanik?: MekanikListRelationFilter
  }, "id">

  export type employeeOrderByWithAggregationInput = {
    id?: SortOrder
    status_id?: SortOrder
    name?: SortOrder
    point?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: employeeCountOrderByAggregateInput
    _avg?: employeeAvgOrderByAggregateInput
    _max?: employeeMaxOrderByAggregateInput
    _min?: employeeMinOrderByAggregateInput
    _sum?: employeeSumOrderByAggregateInput
  }

  export type employeeScalarWhereWithAggregatesInput = {
    AND?: employeeScalarWhereWithAggregatesInput | employeeScalarWhereWithAggregatesInput[]
    OR?: employeeScalarWhereWithAggregatesInput[]
    NOT?: employeeScalarWhereWithAggregatesInput | employeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"employee"> | string
    status_id?: StringWithAggregatesFilter<"employee"> | string
    name?: StringWithAggregatesFilter<"employee"> | string
    point?: IntNullableWithAggregatesFilter<"employee"> | number | null
    address?: StringNullableWithAggregatesFilter<"employee"> | string | null
    phone_number?: StringNullableWithAggregatesFilter<"employee"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"employee"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"employee"> | Date | string | null
  }

  export type inventoryWhereInput = {
    AND?: inventoryWhereInput | inventoryWhereInput[]
    OR?: inventoryWhereInput[]
    NOT?: inventoryWhereInput | inventoryWhereInput[]
    id?: StringFilter<"inventory"> | string
    warehouse_inventory_id?: StringFilter<"inventory"> | string
    barang_id?: StringFilter<"inventory"> | string
    qty?: IntFilter<"inventory"> | number
    createdAt?: DateTimeNullableFilter<"inventory"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"inventory"> | Date | string | null
    barang?: XOR<BarangScalarRelationFilter, barangWhereInput>
    warehouse_inventory?: XOR<Warehouse_inventoryScalarRelationFilter, warehouse_inventoryWhereInput>
  }

  export type inventoryOrderByWithRelationInput = {
    id?: SortOrder
    warehouse_inventory_id?: SortOrder
    barang_id?: SortOrder
    qty?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    barang?: barangOrderByWithRelationInput
    warehouse_inventory?: warehouse_inventoryOrderByWithRelationInput
  }

  export type inventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: inventoryWhereInput | inventoryWhereInput[]
    OR?: inventoryWhereInput[]
    NOT?: inventoryWhereInput | inventoryWhereInput[]
    warehouse_inventory_id?: StringFilter<"inventory"> | string
    barang_id?: StringFilter<"inventory"> | string
    qty?: IntFilter<"inventory"> | number
    createdAt?: DateTimeNullableFilter<"inventory"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"inventory"> | Date | string | null
    barang?: XOR<BarangScalarRelationFilter, barangWhereInput>
    warehouse_inventory?: XOR<Warehouse_inventoryScalarRelationFilter, warehouse_inventoryWhereInput>
  }, "id">

  export type inventoryOrderByWithAggregationInput = {
    id?: SortOrder
    warehouse_inventory_id?: SortOrder
    barang_id?: SortOrder
    qty?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: inventoryCountOrderByAggregateInput
    _avg?: inventoryAvgOrderByAggregateInput
    _max?: inventoryMaxOrderByAggregateInput
    _min?: inventoryMinOrderByAggregateInput
    _sum?: inventorySumOrderByAggregateInput
  }

  export type inventoryScalarWhereWithAggregatesInput = {
    AND?: inventoryScalarWhereWithAggregatesInput | inventoryScalarWhereWithAggregatesInput[]
    OR?: inventoryScalarWhereWithAggregatesInput[]
    NOT?: inventoryScalarWhereWithAggregatesInput | inventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"inventory"> | string
    warehouse_inventory_id?: StringWithAggregatesFilter<"inventory"> | string
    barang_id?: StringWithAggregatesFilter<"inventory"> | string
    qty?: IntWithAggregatesFilter<"inventory"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"inventory"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"inventory"> | Date | string | null
  }

  export type levelWhereInput = {
    AND?: levelWhereInput | levelWhereInput[]
    OR?: levelWhereInput[]
    NOT?: levelWhereInput | levelWhereInput[]
    id?: StringFilter<"level"> | string
    name?: StringFilter<"level"> | string
    createdAt?: DateTimeNullableFilter<"level"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"level"> | Date | string | null
    warehouse?: WarehouseListRelationFilter
  }

  export type levelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    warehouse?: warehouseOrderByRelationAggregateInput
  }

  export type levelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: levelWhereInput | levelWhereInput[]
    OR?: levelWhereInput[]
    NOT?: levelWhereInput | levelWhereInput[]
    name?: StringFilter<"level"> | string
    createdAt?: DateTimeNullableFilter<"level"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"level"> | Date | string | null
    warehouse?: WarehouseListRelationFilter
  }, "id">

  export type levelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: levelCountOrderByAggregateInput
    _max?: levelMaxOrderByAggregateInput
    _min?: levelMinOrderByAggregateInput
  }

  export type levelScalarWhereWithAggregatesInput = {
    AND?: levelScalarWhereWithAggregatesInput | levelScalarWhereWithAggregatesInput[]
    OR?: levelScalarWhereWithAggregatesInput[]
    NOT?: levelScalarWhereWithAggregatesInput | levelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"level"> | string
    name?: StringWithAggregatesFilter<"level"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"level"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"level"> | Date | string | null
  }

  export type mekanikWhereInput = {
    AND?: mekanikWhereInput | mekanikWhereInput[]
    OR?: mekanikWhereInput[]
    NOT?: mekanikWhereInput | mekanikWhereInput[]
    id?: StringFilter<"mekanik"> | string
    employee_id?: StringFilter<"mekanik"> | string
    warehouse_id?: StringFilter<"mekanik"> | string
    createdAt?: DateTimeNullableFilter<"mekanik"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"mekanik"> | Date | string | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, warehouseWhereInput>
    transaksi?: TransaksiListRelationFilter
  }

  export type mekanikOrderByWithRelationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    warehouse_id?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    employee?: employeeOrderByWithRelationInput
    warehouse?: warehouseOrderByWithRelationInput
    transaksi?: transaksiOrderByRelationAggregateInput
  }

  export type mekanikWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: mekanikWhereInput | mekanikWhereInput[]
    OR?: mekanikWhereInput[]
    NOT?: mekanikWhereInput | mekanikWhereInput[]
    employee_id?: StringFilter<"mekanik"> | string
    warehouse_id?: StringFilter<"mekanik"> | string
    createdAt?: DateTimeNullableFilter<"mekanik"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"mekanik"> | Date | string | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, warehouseWhereInput>
    transaksi?: TransaksiListRelationFilter
  }, "id">

  export type mekanikOrderByWithAggregationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    warehouse_id?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: mekanikCountOrderByAggregateInput
    _max?: mekanikMaxOrderByAggregateInput
    _min?: mekanikMinOrderByAggregateInput
  }

  export type mekanikScalarWhereWithAggregatesInput = {
    AND?: mekanikScalarWhereWithAggregatesInput | mekanikScalarWhereWithAggregatesInput[]
    OR?: mekanikScalarWhereWithAggregatesInput[]
    NOT?: mekanikScalarWhereWithAggregatesInput | mekanikScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"mekanik"> | string
    employee_id?: StringWithAggregatesFilter<"mekanik"> | string
    warehouse_id?: StringWithAggregatesFilter<"mekanik"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"mekanik"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"mekanik"> | Date | string | null
  }

  export type memberWhereInput = {
    AND?: memberWhereInput | memberWhereInput[]
    OR?: memberWhereInput[]
    NOT?: memberWhereInput | memberWhereInput[]
    id?: StringFilter<"member"> | string
    name?: StringFilter<"member"> | string
    createdAt?: DateTimeNullableFilter<"member"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"member"> | Date | string | null
    users?: UsersListRelationFilter
  }

  export type memberOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    users?: usersOrderByRelationAggregateInput
  }

  export type memberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: memberWhereInput | memberWhereInput[]
    OR?: memberWhereInput[]
    NOT?: memberWhereInput | memberWhereInput[]
    name?: StringFilter<"member"> | string
    createdAt?: DateTimeNullableFilter<"member"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"member"> | Date | string | null
    users?: UsersListRelationFilter
  }, "id">

  export type memberOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: memberCountOrderByAggregateInput
    _max?: memberMaxOrderByAggregateInput
    _min?: memberMinOrderByAggregateInput
  }

  export type memberScalarWhereWithAggregatesInput = {
    AND?: memberScalarWhereWithAggregatesInput | memberScalarWhereWithAggregatesInput[]
    OR?: memberScalarWhereWithAggregatesInput[]
    NOT?: memberScalarWhereWithAggregatesInput | memberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"member"> | string
    name?: StringWithAggregatesFilter<"member"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"member"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"member"> | Date | string | null
  }

  export type order_barangWhereInput = {
    AND?: order_barangWhereInput | order_barangWhereInput[]
    OR?: order_barangWhereInput[]
    NOT?: order_barangWhereInput | order_barangWhereInput[]
    id?: StringFilter<"order_barang"> | string
    from_warehouse_id?: StringFilter<"order_barang"> | string
    to_warehouse_id?: StringFilter<"order_barang"> | string
    createdAt?: DateTimeNullableFilter<"order_barang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"order_barang"> | Date | string | null
    warehouse_order_barang_from_warehouse_idTowarehouse?: XOR<WarehouseScalarRelationFilter, warehouseWhereInput>
    warehouse_order_barang_to_warehouse_idTowarehouse?: XOR<WarehouseScalarRelationFilter, warehouseWhereInput>
    order_barang_detail?: Order_barang_detailListRelationFilter
  }

  export type order_barangOrderByWithRelationInput = {
    id?: SortOrder
    from_warehouse_id?: SortOrder
    to_warehouse_id?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    warehouse_order_barang_from_warehouse_idTowarehouse?: warehouseOrderByWithRelationInput
    warehouse_order_barang_to_warehouse_idTowarehouse?: warehouseOrderByWithRelationInput
    order_barang_detail?: order_barang_detailOrderByRelationAggregateInput
  }

  export type order_barangWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: order_barangWhereInput | order_barangWhereInput[]
    OR?: order_barangWhereInput[]
    NOT?: order_barangWhereInput | order_barangWhereInput[]
    from_warehouse_id?: StringFilter<"order_barang"> | string
    to_warehouse_id?: StringFilter<"order_barang"> | string
    createdAt?: DateTimeNullableFilter<"order_barang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"order_barang"> | Date | string | null
    warehouse_order_barang_from_warehouse_idTowarehouse?: XOR<WarehouseScalarRelationFilter, warehouseWhereInput>
    warehouse_order_barang_to_warehouse_idTowarehouse?: XOR<WarehouseScalarRelationFilter, warehouseWhereInput>
    order_barang_detail?: Order_barang_detailListRelationFilter
  }, "id">

  export type order_barangOrderByWithAggregationInput = {
    id?: SortOrder
    from_warehouse_id?: SortOrder
    to_warehouse_id?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: order_barangCountOrderByAggregateInput
    _max?: order_barangMaxOrderByAggregateInput
    _min?: order_barangMinOrderByAggregateInput
  }

  export type order_barangScalarWhereWithAggregatesInput = {
    AND?: order_barangScalarWhereWithAggregatesInput | order_barangScalarWhereWithAggregatesInput[]
    OR?: order_barangScalarWhereWithAggregatesInput[]
    NOT?: order_barangScalarWhereWithAggregatesInput | order_barangScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"order_barang"> | string
    from_warehouse_id?: StringWithAggregatesFilter<"order_barang"> | string
    to_warehouse_id?: StringWithAggregatesFilter<"order_barang"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"order_barang"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"order_barang"> | Date | string | null
  }

  export type order_barang_detailWhereInput = {
    AND?: order_barang_detailWhereInput | order_barang_detailWhereInput[]
    OR?: order_barang_detailWhereInput[]
    NOT?: order_barang_detailWhereInput | order_barang_detailWhereInput[]
    id?: StringFilter<"order_barang_detail"> | string
    order_barang_id?: StringFilter<"order_barang_detail"> | string
    barang_id?: StringFilter<"order_barang_detail"> | string
    qty?: IntFilter<"order_barang_detail"> | number
    createdAt?: DateTimeNullableFilter<"order_barang_detail"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"order_barang_detail"> | Date | string | null
    barang?: XOR<BarangScalarRelationFilter, barangWhereInput>
    order_barang?: XOR<Order_barangScalarRelationFilter, order_barangWhereInput>
  }

  export type order_barang_detailOrderByWithRelationInput = {
    id?: SortOrder
    order_barang_id?: SortOrder
    barang_id?: SortOrder
    qty?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    barang?: barangOrderByWithRelationInput
    order_barang?: order_barangOrderByWithRelationInput
  }

  export type order_barang_detailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: order_barang_detailWhereInput | order_barang_detailWhereInput[]
    OR?: order_barang_detailWhereInput[]
    NOT?: order_barang_detailWhereInput | order_barang_detailWhereInput[]
    order_barang_id?: StringFilter<"order_barang_detail"> | string
    barang_id?: StringFilter<"order_barang_detail"> | string
    qty?: IntFilter<"order_barang_detail"> | number
    createdAt?: DateTimeNullableFilter<"order_barang_detail"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"order_barang_detail"> | Date | string | null
    barang?: XOR<BarangScalarRelationFilter, barangWhereInput>
    order_barang?: XOR<Order_barangScalarRelationFilter, order_barangWhereInput>
  }, "id">

  export type order_barang_detailOrderByWithAggregationInput = {
    id?: SortOrder
    order_barang_id?: SortOrder
    barang_id?: SortOrder
    qty?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: order_barang_detailCountOrderByAggregateInput
    _avg?: order_barang_detailAvgOrderByAggregateInput
    _max?: order_barang_detailMaxOrderByAggregateInput
    _min?: order_barang_detailMinOrderByAggregateInput
    _sum?: order_barang_detailSumOrderByAggregateInput
  }

  export type order_barang_detailScalarWhereWithAggregatesInput = {
    AND?: order_barang_detailScalarWhereWithAggregatesInput | order_barang_detailScalarWhereWithAggregatesInput[]
    OR?: order_barang_detailScalarWhereWithAggregatesInput[]
    NOT?: order_barang_detailScalarWhereWithAggregatesInput | order_barang_detailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"order_barang_detail"> | string
    order_barang_id?: StringWithAggregatesFilter<"order_barang_detail"> | string
    barang_id?: StringWithAggregatesFilter<"order_barang_detail"> | string
    qty?: IntWithAggregatesFilter<"order_barang_detail"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"order_barang_detail"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"order_barang_detail"> | Date | string | null
  }

  export type statusWhereInput = {
    AND?: statusWhereInput | statusWhereInput[]
    OR?: statusWhereInput[]
    NOT?: statusWhereInput | statusWhereInput[]
    id?: StringFilter<"status"> | string
    name?: StringFilter<"status"> | string
    createdAt?: DateTimeNullableFilter<"status"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"status"> | Date | string | null
    employee?: EmployeeListRelationFilter
    users?: UsersListRelationFilter
  }

  export type statusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    employee?: employeeOrderByRelationAggregateInput
    users?: usersOrderByRelationAggregateInput
  }

  export type statusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: statusWhereInput | statusWhereInput[]
    OR?: statusWhereInput[]
    NOT?: statusWhereInput | statusWhereInput[]
    name?: StringFilter<"status"> | string
    createdAt?: DateTimeNullableFilter<"status"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"status"> | Date | string | null
    employee?: EmployeeListRelationFilter
    users?: UsersListRelationFilter
  }, "id">

  export type statusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: statusCountOrderByAggregateInput
    _max?: statusMaxOrderByAggregateInput
    _min?: statusMinOrderByAggregateInput
  }

  export type statusScalarWhereWithAggregatesInput = {
    AND?: statusScalarWhereWithAggregatesInput | statusScalarWhereWithAggregatesInput[]
    OR?: statusScalarWhereWithAggregatesInput[]
    NOT?: statusScalarWhereWithAggregatesInput | statusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"status"> | string
    name?: StringWithAggregatesFilter<"status"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"status"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"status"> | Date | string | null
  }

  export type transaksiWhereInput = {
    AND?: transaksiWhereInput | transaksiWhereInput[]
    OR?: transaksiWhereInput[]
    NOT?: transaksiWhereInput | transaksiWhereInput[]
    id?: StringFilter<"transaksi"> | string
    users_id?: StringFilter<"transaksi"> | string
    mekanik_id?: StringFilter<"transaksi"> | string
    warehouse_id?: StringFilter<"transaksi"> | string
    point?: IntFilter<"transaksi"> | number
    total?: DecimalFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeNullableFilter<"transaksi"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"transaksi"> | Date | string | null
    mekanik?: XOR<MekanikScalarRelationFilter, mekanikWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, warehouseWhereInput>
    transaksi_detail?: Transaksi_detailListRelationFilter
  }

  export type transaksiOrderByWithRelationInput = {
    id?: SortOrder
    users_id?: SortOrder
    mekanik_id?: SortOrder
    warehouse_id?: SortOrder
    point?: SortOrder
    total?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    mekanik?: mekanikOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    warehouse?: warehouseOrderByWithRelationInput
    transaksi_detail?: transaksi_detailOrderByRelationAggregateInput
  }

  export type transaksiWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: transaksiWhereInput | transaksiWhereInput[]
    OR?: transaksiWhereInput[]
    NOT?: transaksiWhereInput | transaksiWhereInput[]
    users_id?: StringFilter<"transaksi"> | string
    mekanik_id?: StringFilter<"transaksi"> | string
    warehouse_id?: StringFilter<"transaksi"> | string
    point?: IntFilter<"transaksi"> | number
    total?: DecimalFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeNullableFilter<"transaksi"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"transaksi"> | Date | string | null
    mekanik?: XOR<MekanikScalarRelationFilter, mekanikWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, warehouseWhereInput>
    transaksi_detail?: Transaksi_detailListRelationFilter
  }, "id">

  export type transaksiOrderByWithAggregationInput = {
    id?: SortOrder
    users_id?: SortOrder
    mekanik_id?: SortOrder
    warehouse_id?: SortOrder
    point?: SortOrder
    total?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: transaksiCountOrderByAggregateInput
    _avg?: transaksiAvgOrderByAggregateInput
    _max?: transaksiMaxOrderByAggregateInput
    _min?: transaksiMinOrderByAggregateInput
    _sum?: transaksiSumOrderByAggregateInput
  }

  export type transaksiScalarWhereWithAggregatesInput = {
    AND?: transaksiScalarWhereWithAggregatesInput | transaksiScalarWhereWithAggregatesInput[]
    OR?: transaksiScalarWhereWithAggregatesInput[]
    NOT?: transaksiScalarWhereWithAggregatesInput | transaksiScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"transaksi"> | string
    users_id?: StringWithAggregatesFilter<"transaksi"> | string
    mekanik_id?: StringWithAggregatesFilter<"transaksi"> | string
    warehouse_id?: StringWithAggregatesFilter<"transaksi"> | string
    point?: IntWithAggregatesFilter<"transaksi"> | number
    total?: DecimalWithAggregatesFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"transaksi"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"transaksi"> | Date | string | null
  }

  export type transaksi_detailWhereInput = {
    AND?: transaksi_detailWhereInput | transaksi_detailWhereInput[]
    OR?: transaksi_detailWhereInput[]
    NOT?: transaksi_detailWhereInput | transaksi_detailWhereInput[]
    id?: StringFilter<"transaksi_detail"> | string
    transaksi_id?: StringFilter<"transaksi_detail"> | string
    barang_id?: StringFilter<"transaksi_detail"> | string
    qty?: IntFilter<"transaksi_detail"> | number
    sub_total?: DecimalFilter<"transaksi_detail"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeNullableFilter<"transaksi_detail"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"transaksi_detail"> | Date | string | null
    barang?: XOR<BarangScalarRelationFilter, barangWhereInput>
    transaksi?: XOR<TransaksiScalarRelationFilter, transaksiWhereInput>
  }

  export type transaksi_detailOrderByWithRelationInput = {
    id?: SortOrder
    transaksi_id?: SortOrder
    barang_id?: SortOrder
    qty?: SortOrder
    sub_total?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    barang?: barangOrderByWithRelationInput
    transaksi?: transaksiOrderByWithRelationInput
  }

  export type transaksi_detailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: transaksi_detailWhereInput | transaksi_detailWhereInput[]
    OR?: transaksi_detailWhereInput[]
    NOT?: transaksi_detailWhereInput | transaksi_detailWhereInput[]
    transaksi_id?: StringFilter<"transaksi_detail"> | string
    barang_id?: StringFilter<"transaksi_detail"> | string
    qty?: IntFilter<"transaksi_detail"> | number
    sub_total?: DecimalFilter<"transaksi_detail"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeNullableFilter<"transaksi_detail"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"transaksi_detail"> | Date | string | null
    barang?: XOR<BarangScalarRelationFilter, barangWhereInput>
    transaksi?: XOR<TransaksiScalarRelationFilter, transaksiWhereInput>
  }, "id">

  export type transaksi_detailOrderByWithAggregationInput = {
    id?: SortOrder
    transaksi_id?: SortOrder
    barang_id?: SortOrder
    qty?: SortOrder
    sub_total?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: transaksi_detailCountOrderByAggregateInput
    _avg?: transaksi_detailAvgOrderByAggregateInput
    _max?: transaksi_detailMaxOrderByAggregateInput
    _min?: transaksi_detailMinOrderByAggregateInput
    _sum?: transaksi_detailSumOrderByAggregateInput
  }

  export type transaksi_detailScalarWhereWithAggregatesInput = {
    AND?: transaksi_detailScalarWhereWithAggregatesInput | transaksi_detailScalarWhereWithAggregatesInput[]
    OR?: transaksi_detailScalarWhereWithAggregatesInput[]
    NOT?: transaksi_detailScalarWhereWithAggregatesInput | transaksi_detailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"transaksi_detail"> | string
    transaksi_id?: StringWithAggregatesFilter<"transaksi_detail"> | string
    barang_id?: StringWithAggregatesFilter<"transaksi_detail"> | string
    qty?: IntWithAggregatesFilter<"transaksi_detail"> | number
    sub_total?: DecimalWithAggregatesFilter<"transaksi_detail"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"transaksi_detail"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"transaksi_detail"> | Date | string | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    status_id?: StringFilter<"users"> | string
    member_id?: StringFilter<"users"> | string
    vehicle_year_id?: StringFilter<"users"> | string
    vehicle_merk_id?: StringFilter<"users"> | string
    vehicle_type_id?: StringFilter<"users"> | string
    no_police?: StringFilter<"users"> | string
    name?: StringNullableFilter<"users"> | string | null
    point?: IntNullableFilter<"users"> | number | null
    address?: StringNullableFilter<"users"> | string | null
    phone_number?: StringFilter<"users"> | string
    createdAt?: DateTimeNullableFilter<"users"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"users"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"users"> | Date | string | null
    transaksi?: TransaksiListRelationFilter
    member?: XOR<MemberScalarRelationFilter, memberWhereInput>
    status?: XOR<StatusScalarRelationFilter, statusWhereInput>
    vehicle_merk?: XOR<Vehicle_merkScalarRelationFilter, vehicle_merkWhereInput>
    vehicle_year?: XOR<Vehicle_yearScalarRelationFilter, vehicle_yearWhereInput>
    vehicle_type?: XOR<Vehicle_typeScalarRelationFilter, vehicle_typeWhereInput>
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    status_id?: SortOrder
    member_id?: SortOrder
    vehicle_year_id?: SortOrder
    vehicle_merk_id?: SortOrder
    vehicle_type_id?: SortOrder
    no_police?: SortOrder
    name?: SortOrderInput | SortOrder
    point?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    transaksi?: transaksiOrderByRelationAggregateInput
    member?: memberOrderByWithRelationInput
    status?: statusOrderByWithRelationInput
    vehicle_merk?: vehicle_merkOrderByWithRelationInput
    vehicle_year?: vehicle_yearOrderByWithRelationInput
    vehicle_type?: vehicle_typeOrderByWithRelationInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    status_id?: StringFilter<"users"> | string
    member_id?: StringFilter<"users"> | string
    vehicle_year_id?: StringFilter<"users"> | string
    vehicle_merk_id?: StringFilter<"users"> | string
    vehicle_type_id?: StringFilter<"users"> | string
    no_police?: StringFilter<"users"> | string
    name?: StringNullableFilter<"users"> | string | null
    point?: IntNullableFilter<"users"> | number | null
    address?: StringNullableFilter<"users"> | string | null
    phone_number?: StringFilter<"users"> | string
    createdAt?: DateTimeNullableFilter<"users"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"users"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"users"> | Date | string | null
    transaksi?: TransaksiListRelationFilter
    member?: XOR<MemberScalarRelationFilter, memberWhereInput>
    status?: XOR<StatusScalarRelationFilter, statusWhereInput>
    vehicle_merk?: XOR<Vehicle_merkScalarRelationFilter, vehicle_merkWhereInput>
    vehicle_year?: XOR<Vehicle_yearScalarRelationFilter, vehicle_yearWhereInput>
    vehicle_type?: XOR<Vehicle_typeScalarRelationFilter, vehicle_typeWhereInput>
  }, "id">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    status_id?: SortOrder
    member_id?: SortOrder
    vehicle_year_id?: SortOrder
    vehicle_merk_id?: SortOrder
    vehicle_type_id?: SortOrder
    no_police?: SortOrder
    name?: SortOrderInput | SortOrder
    point?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    status_id?: StringWithAggregatesFilter<"users"> | string
    member_id?: StringWithAggregatesFilter<"users"> | string
    vehicle_year_id?: StringWithAggregatesFilter<"users"> | string
    vehicle_merk_id?: StringWithAggregatesFilter<"users"> | string
    vehicle_type_id?: StringWithAggregatesFilter<"users"> | string
    no_police?: StringWithAggregatesFilter<"users"> | string
    name?: StringNullableWithAggregatesFilter<"users"> | string | null
    point?: IntNullableWithAggregatesFilter<"users"> | number | null
    address?: StringNullableWithAggregatesFilter<"users"> | string | null
    phone_number?: StringWithAggregatesFilter<"users"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type vehicle_categoryWhereInput = {
    AND?: vehicle_categoryWhereInput | vehicle_categoryWhereInput[]
    OR?: vehicle_categoryWhereInput[]
    NOT?: vehicle_categoryWhereInput | vehicle_categoryWhereInput[]
    id?: StringFilter<"vehicle_category"> | string
    name?: StringFilter<"vehicle_category"> | string
    createdAt?: DateTimeNullableFilter<"vehicle_category"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"vehicle_category"> | Date | string | null
    barang?: BarangListRelationFilter
    vehicle_type?: Vehicle_typeListRelationFilter
  }

  export type vehicle_categoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    barang?: barangOrderByRelationAggregateInput
    vehicle_type?: vehicle_typeOrderByRelationAggregateInput
  }

  export type vehicle_categoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: vehicle_categoryWhereInput | vehicle_categoryWhereInput[]
    OR?: vehicle_categoryWhereInput[]
    NOT?: vehicle_categoryWhereInput | vehicle_categoryWhereInput[]
    name?: StringFilter<"vehicle_category"> | string
    createdAt?: DateTimeNullableFilter<"vehicle_category"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"vehicle_category"> | Date | string | null
    barang?: BarangListRelationFilter
    vehicle_type?: Vehicle_typeListRelationFilter
  }, "id">

  export type vehicle_categoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: vehicle_categoryCountOrderByAggregateInput
    _max?: vehicle_categoryMaxOrderByAggregateInput
    _min?: vehicle_categoryMinOrderByAggregateInput
  }

  export type vehicle_categoryScalarWhereWithAggregatesInput = {
    AND?: vehicle_categoryScalarWhereWithAggregatesInput | vehicle_categoryScalarWhereWithAggregatesInput[]
    OR?: vehicle_categoryScalarWhereWithAggregatesInput[]
    NOT?: vehicle_categoryScalarWhereWithAggregatesInput | vehicle_categoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"vehicle_category"> | string
    name?: StringWithAggregatesFilter<"vehicle_category"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"vehicle_category"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"vehicle_category"> | Date | string | null
  }

  export type vehicle_merkWhereInput = {
    AND?: vehicle_merkWhereInput | vehicle_merkWhereInput[]
    OR?: vehicle_merkWhereInput[]
    NOT?: vehicle_merkWhereInput | vehicle_merkWhereInput[]
    id?: StringFilter<"vehicle_merk"> | string
    name?: StringFilter<"vehicle_merk"> | string
    createdAt?: DateTimeNullableFilter<"vehicle_merk"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"vehicle_merk"> | Date | string | null
    users?: UsersListRelationFilter
  }

  export type vehicle_merkOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    users?: usersOrderByRelationAggregateInput
  }

  export type vehicle_merkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: vehicle_merkWhereInput | vehicle_merkWhereInput[]
    OR?: vehicle_merkWhereInput[]
    NOT?: vehicle_merkWhereInput | vehicle_merkWhereInput[]
    name?: StringFilter<"vehicle_merk"> | string
    createdAt?: DateTimeNullableFilter<"vehicle_merk"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"vehicle_merk"> | Date | string | null
    users?: UsersListRelationFilter
  }, "id">

  export type vehicle_merkOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: vehicle_merkCountOrderByAggregateInput
    _max?: vehicle_merkMaxOrderByAggregateInput
    _min?: vehicle_merkMinOrderByAggregateInput
  }

  export type vehicle_merkScalarWhereWithAggregatesInput = {
    AND?: vehicle_merkScalarWhereWithAggregatesInput | vehicle_merkScalarWhereWithAggregatesInput[]
    OR?: vehicle_merkScalarWhereWithAggregatesInput[]
    NOT?: vehicle_merkScalarWhereWithAggregatesInput | vehicle_merkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"vehicle_merk"> | string
    name?: StringWithAggregatesFilter<"vehicle_merk"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"vehicle_merk"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"vehicle_merk"> | Date | string | null
  }

  export type vehicle_typeWhereInput = {
    AND?: vehicle_typeWhereInput | vehicle_typeWhereInput[]
    OR?: vehicle_typeWhereInput[]
    NOT?: vehicle_typeWhereInput | vehicle_typeWhereInput[]
    id?: StringFilter<"vehicle_type"> | string
    vehicle_category_id?: StringFilter<"vehicle_type"> | string
    name?: StringFilter<"vehicle_type"> | string
    createdAt?: DateTimeNullableFilter<"vehicle_type"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"vehicle_type"> | Date | string | null
    users?: UsersListRelationFilter
    vehicle_category?: XOR<Vehicle_categoryScalarRelationFilter, vehicle_categoryWhereInput>
  }

  export type vehicle_typeOrderByWithRelationInput = {
    id?: SortOrder
    vehicle_category_id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    users?: usersOrderByRelationAggregateInput
    vehicle_category?: vehicle_categoryOrderByWithRelationInput
  }

  export type vehicle_typeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: vehicle_typeWhereInput | vehicle_typeWhereInput[]
    OR?: vehicle_typeWhereInput[]
    NOT?: vehicle_typeWhereInput | vehicle_typeWhereInput[]
    vehicle_category_id?: StringFilter<"vehicle_type"> | string
    name?: StringFilter<"vehicle_type"> | string
    createdAt?: DateTimeNullableFilter<"vehicle_type"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"vehicle_type"> | Date | string | null
    users?: UsersListRelationFilter
    vehicle_category?: XOR<Vehicle_categoryScalarRelationFilter, vehicle_categoryWhereInput>
  }, "id">

  export type vehicle_typeOrderByWithAggregationInput = {
    id?: SortOrder
    vehicle_category_id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: vehicle_typeCountOrderByAggregateInput
    _max?: vehicle_typeMaxOrderByAggregateInput
    _min?: vehicle_typeMinOrderByAggregateInput
  }

  export type vehicle_typeScalarWhereWithAggregatesInput = {
    AND?: vehicle_typeScalarWhereWithAggregatesInput | vehicle_typeScalarWhereWithAggregatesInput[]
    OR?: vehicle_typeScalarWhereWithAggregatesInput[]
    NOT?: vehicle_typeScalarWhereWithAggregatesInput | vehicle_typeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"vehicle_type"> | string
    vehicle_category_id?: StringWithAggregatesFilter<"vehicle_type"> | string
    name?: StringWithAggregatesFilter<"vehicle_type"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"vehicle_type"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"vehicle_type"> | Date | string | null
  }

  export type vehicle_yearWhereInput = {
    AND?: vehicle_yearWhereInput | vehicle_yearWhereInput[]
    OR?: vehicle_yearWhereInput[]
    NOT?: vehicle_yearWhereInput | vehicle_yearWhereInput[]
    id?: StringFilter<"vehicle_year"> | string
    year?: StringFilter<"vehicle_year"> | string
    createdAt?: DateTimeNullableFilter<"vehicle_year"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"vehicle_year"> | Date | string | null
    users?: UsersListRelationFilter
  }

  export type vehicle_yearOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    users?: usersOrderByRelationAggregateInput
  }

  export type vehicle_yearWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: vehicle_yearWhereInput | vehicle_yearWhereInput[]
    OR?: vehicle_yearWhereInput[]
    NOT?: vehicle_yearWhereInput | vehicle_yearWhereInput[]
    year?: StringFilter<"vehicle_year"> | string
    createdAt?: DateTimeNullableFilter<"vehicle_year"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"vehicle_year"> | Date | string | null
    users?: UsersListRelationFilter
  }, "id">

  export type vehicle_yearOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: vehicle_yearCountOrderByAggregateInput
    _max?: vehicle_yearMaxOrderByAggregateInput
    _min?: vehicle_yearMinOrderByAggregateInput
  }

  export type vehicle_yearScalarWhereWithAggregatesInput = {
    AND?: vehicle_yearScalarWhereWithAggregatesInput | vehicle_yearScalarWhereWithAggregatesInput[]
    OR?: vehicle_yearScalarWhereWithAggregatesInput[]
    NOT?: vehicle_yearScalarWhereWithAggregatesInput | vehicle_yearScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"vehicle_year"> | string
    year?: StringWithAggregatesFilter<"vehicle_year"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"vehicle_year"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"vehicle_year"> | Date | string | null
  }

  export type warehouseWhereInput = {
    AND?: warehouseWhereInput | warehouseWhereInput[]
    OR?: warehouseWhereInput[]
    NOT?: warehouseWhereInput | warehouseWhereInput[]
    id?: StringFilter<"warehouse"> | string
    level_id?: StringFilter<"warehouse"> | string
    name_warehouse?: StringFilter<"warehouse"> | string
    username?: StringFilter<"warehouse"> | string
    password?: StringFilter<"warehouse"> | string
    warehouse_address?: StringFilter<"warehouse"> | string
    phone_number_warehouse?: StringNullableFilter<"warehouse"> | string | null
    createdAt?: DateTimeNullableFilter<"warehouse"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"warehouse"> | Date | string | null
    mekanik?: MekanikListRelationFilter
    order_barang_order_barang_from_warehouse_idTowarehouse?: Order_barangListRelationFilter
    order_barang_order_barang_to_warehouse_idTowarehouse?: Order_barangListRelationFilter
    transaksi?: TransaksiListRelationFilter
    level?: XOR<LevelScalarRelationFilter, levelWhereInput>
    warehouse_inventory?: Warehouse_inventoryListRelationFilter
  }

  export type warehouseOrderByWithRelationInput = {
    id?: SortOrder
    level_id?: SortOrder
    name_warehouse?: SortOrder
    username?: SortOrder
    password?: SortOrder
    warehouse_address?: SortOrder
    phone_number_warehouse?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    mekanik?: mekanikOrderByRelationAggregateInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangOrderByRelationAggregateInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangOrderByRelationAggregateInput
    transaksi?: transaksiOrderByRelationAggregateInput
    level?: levelOrderByWithRelationInput
    warehouse_inventory?: warehouse_inventoryOrderByRelationAggregateInput
  }

  export type warehouseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: warehouseWhereInput | warehouseWhereInput[]
    OR?: warehouseWhereInput[]
    NOT?: warehouseWhereInput | warehouseWhereInput[]
    level_id?: StringFilter<"warehouse"> | string
    name_warehouse?: StringFilter<"warehouse"> | string
    username?: StringFilter<"warehouse"> | string
    password?: StringFilter<"warehouse"> | string
    warehouse_address?: StringFilter<"warehouse"> | string
    phone_number_warehouse?: StringNullableFilter<"warehouse"> | string | null
    createdAt?: DateTimeNullableFilter<"warehouse"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"warehouse"> | Date | string | null
    mekanik?: MekanikListRelationFilter
    order_barang_order_barang_from_warehouse_idTowarehouse?: Order_barangListRelationFilter
    order_barang_order_barang_to_warehouse_idTowarehouse?: Order_barangListRelationFilter
    transaksi?: TransaksiListRelationFilter
    level?: XOR<LevelScalarRelationFilter, levelWhereInput>
    warehouse_inventory?: Warehouse_inventoryListRelationFilter
  }, "id">

  export type warehouseOrderByWithAggregationInput = {
    id?: SortOrder
    level_id?: SortOrder
    name_warehouse?: SortOrder
    username?: SortOrder
    password?: SortOrder
    warehouse_address?: SortOrder
    phone_number_warehouse?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: warehouseCountOrderByAggregateInput
    _max?: warehouseMaxOrderByAggregateInput
    _min?: warehouseMinOrderByAggregateInput
  }

  export type warehouseScalarWhereWithAggregatesInput = {
    AND?: warehouseScalarWhereWithAggregatesInput | warehouseScalarWhereWithAggregatesInput[]
    OR?: warehouseScalarWhereWithAggregatesInput[]
    NOT?: warehouseScalarWhereWithAggregatesInput | warehouseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"warehouse"> | string
    level_id?: StringWithAggregatesFilter<"warehouse"> | string
    name_warehouse?: StringWithAggregatesFilter<"warehouse"> | string
    username?: StringWithAggregatesFilter<"warehouse"> | string
    password?: StringWithAggregatesFilter<"warehouse"> | string
    warehouse_address?: StringWithAggregatesFilter<"warehouse"> | string
    phone_number_warehouse?: StringNullableWithAggregatesFilter<"warehouse"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"warehouse"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"warehouse"> | Date | string | null
  }

  export type warehouse_inventoryWhereInput = {
    AND?: warehouse_inventoryWhereInput | warehouse_inventoryWhereInput[]
    OR?: warehouse_inventoryWhereInput[]
    NOT?: warehouse_inventoryWhereInput | warehouse_inventoryWhereInput[]
    id?: StringFilter<"warehouse_inventory"> | string
    warehouse_id?: StringFilter<"warehouse_inventory"> | string
    createdAt?: DateTimeNullableFilter<"warehouse_inventory"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"warehouse_inventory"> | Date | string | null
    inventory?: InventoryListRelationFilter
    warehouse?: XOR<WarehouseScalarRelationFilter, warehouseWhereInput>
  }

  export type warehouse_inventoryOrderByWithRelationInput = {
    id?: SortOrder
    warehouse_id?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    inventory?: inventoryOrderByRelationAggregateInput
    warehouse?: warehouseOrderByWithRelationInput
  }

  export type warehouse_inventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: warehouse_inventoryWhereInput | warehouse_inventoryWhereInput[]
    OR?: warehouse_inventoryWhereInput[]
    NOT?: warehouse_inventoryWhereInput | warehouse_inventoryWhereInput[]
    warehouse_id?: StringFilter<"warehouse_inventory"> | string
    createdAt?: DateTimeNullableFilter<"warehouse_inventory"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"warehouse_inventory"> | Date | string | null
    inventory?: InventoryListRelationFilter
    warehouse?: XOR<WarehouseScalarRelationFilter, warehouseWhereInput>
  }, "id">

  export type warehouse_inventoryOrderByWithAggregationInput = {
    id?: SortOrder
    warehouse_id?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: warehouse_inventoryCountOrderByAggregateInput
    _max?: warehouse_inventoryMaxOrderByAggregateInput
    _min?: warehouse_inventoryMinOrderByAggregateInput
  }

  export type warehouse_inventoryScalarWhereWithAggregatesInput = {
    AND?: warehouse_inventoryScalarWhereWithAggregatesInput | warehouse_inventoryScalarWhereWithAggregatesInput[]
    OR?: warehouse_inventoryScalarWhereWithAggregatesInput[]
    NOT?: warehouse_inventoryScalarWhereWithAggregatesInput | warehouse_inventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"warehouse_inventory"> | string
    warehouse_id?: StringWithAggregatesFilter<"warehouse_inventory"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"warehouse_inventory"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"warehouse_inventory"> | Date | string | null
  }

  export type barangCreateInput = {
    id: string
    name_barang: string
    description_barang?: string | null
    price: Decimal | DecimalJsLike | number | string
    point?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    vehicle_category: vehicle_categoryCreateNestedOneWithoutBarangInput
    inventory?: inventoryCreateNestedManyWithoutBarangInput
    order_barang_detail?: order_barang_detailCreateNestedManyWithoutBarangInput
    transaksi_detail?: transaksi_detailCreateNestedManyWithoutBarangInput
  }

  export type barangUncheckedCreateInput = {
    id: string
    category_vehicle_id: string
    name_barang: string
    description_barang?: string | null
    price: Decimal | DecimalJsLike | number | string
    point?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    inventory?: inventoryUncheckedCreateNestedManyWithoutBarangInput
    order_barang_detail?: order_barang_detailUncheckedCreateNestedManyWithoutBarangInput
    transaksi_detail?: transaksi_detailUncheckedCreateNestedManyWithoutBarangInput
  }

  export type barangUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_barang?: StringFieldUpdateOperationsInput | string
    description_barang?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicle_category?: vehicle_categoryUpdateOneRequiredWithoutBarangNestedInput
    inventory?: inventoryUpdateManyWithoutBarangNestedInput
    order_barang_detail?: order_barang_detailUpdateManyWithoutBarangNestedInput
    transaksi_detail?: transaksi_detailUpdateManyWithoutBarangNestedInput
  }

  export type barangUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_vehicle_id?: StringFieldUpdateOperationsInput | string
    name_barang?: StringFieldUpdateOperationsInput | string
    description_barang?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventory?: inventoryUncheckedUpdateManyWithoutBarangNestedInput
    order_barang_detail?: order_barang_detailUncheckedUpdateManyWithoutBarangNestedInput
    transaksi_detail?: transaksi_detailUncheckedUpdateManyWithoutBarangNestedInput
  }

  export type barangCreateManyInput = {
    id: string
    category_vehicle_id: string
    name_barang: string
    description_barang?: string | null
    price: Decimal | DecimalJsLike | number | string
    point?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type barangUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_barang?: StringFieldUpdateOperationsInput | string
    description_barang?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type barangUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_vehicle_id?: StringFieldUpdateOperationsInput | string
    name_barang?: StringFieldUpdateOperationsInput | string
    description_barang?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type employeeCreateInput = {
    id: string
    name: string
    point?: number | null
    address?: string | null
    phone_number?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    status: statusCreateNestedOneWithoutEmployeeInput
    mekanik?: mekanikCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateInput = {
    id: string
    status_id: string
    name: string
    point?: number | null
    address?: string | null
    phone_number?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    mekanik?: mekanikUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: statusUpdateOneRequiredWithoutEmployeeNestedInput
    mekanik?: mekanikUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mekanik?: mekanikUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeCreateManyInput = {
    id: string
    status_id: string
    name: string
    point?: number | null
    address?: string | null
    phone_number?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type employeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type employeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inventoryCreateInput = {
    id: string
    qty?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    barang: barangCreateNestedOneWithoutInventoryInput
    warehouse_inventory: warehouse_inventoryCreateNestedOneWithoutInventoryInput
  }

  export type inventoryUncheckedCreateInput = {
    id: string
    warehouse_inventory_id: string
    barang_id: string
    qty?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type inventoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    barang?: barangUpdateOneRequiredWithoutInventoryNestedInput
    warehouse_inventory?: warehouse_inventoryUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type inventoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouse_inventory_id?: StringFieldUpdateOperationsInput | string
    barang_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inventoryCreateManyInput = {
    id: string
    warehouse_inventory_id: string
    barang_id: string
    qty?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type inventoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inventoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouse_inventory_id?: StringFieldUpdateOperationsInput | string
    barang_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type levelCreateInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    warehouse?: warehouseCreateNestedManyWithoutLevelInput
  }

  export type levelUncheckedCreateInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    warehouse?: warehouseUncheckedCreateNestedManyWithoutLevelInput
  }

  export type levelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse?: warehouseUpdateManyWithoutLevelNestedInput
  }

  export type levelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse?: warehouseUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type levelCreateManyInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type levelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type levelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mekanikCreateInput = {
    id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employee: employeeCreateNestedOneWithoutMekanikInput
    warehouse: warehouseCreateNestedOneWithoutMekanikInput
    transaksi?: transaksiCreateNestedManyWithoutMekanikInput
  }

  export type mekanikUncheckedCreateInput = {
    id: string
    employee_id: string
    warehouse_id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    transaksi?: transaksiUncheckedCreateNestedManyWithoutMekanikInput
  }

  export type mekanikUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: employeeUpdateOneRequiredWithoutMekanikNestedInput
    warehouse?: warehouseUpdateOneRequiredWithoutMekanikNestedInput
    transaksi?: transaksiUpdateManyWithoutMekanikNestedInput
  }

  export type mekanikUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    warehouse_id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUncheckedUpdateManyWithoutMekanikNestedInput
  }

  export type mekanikCreateManyInput = {
    id: string
    employee_id: string
    warehouse_id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type mekanikUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mekanikUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    warehouse_id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type memberCreateInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    users?: usersCreateNestedManyWithoutMemberInput
  }

  export type memberUncheckedCreateInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    users?: usersUncheckedCreateNestedManyWithoutMemberInput
  }

  export type memberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateManyWithoutMemberNestedInput
  }

  export type memberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type memberCreateManyInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type memberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type memberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type order_barangCreateInput = {
    id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    warehouse_order_barang_from_warehouse_idTowarehouse: warehouseCreateNestedOneWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput
    warehouse_order_barang_to_warehouse_idTowarehouse: warehouseCreateNestedOneWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput
    order_barang_detail?: order_barang_detailCreateNestedManyWithoutOrder_barangInput
  }

  export type order_barangUncheckedCreateInput = {
    id: string
    from_warehouse_id: string
    to_warehouse_id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    order_barang_detail?: order_barang_detailUncheckedCreateNestedManyWithoutOrder_barangInput
  }

  export type order_barangUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse_order_barang_from_warehouse_idTowarehouse?: warehouseUpdateOneRequiredWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseNestedInput
    warehouse_order_barang_to_warehouse_idTowarehouse?: warehouseUpdateOneRequiredWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseNestedInput
    order_barang_detail?: order_barang_detailUpdateManyWithoutOrder_barangNestedInput
  }

  export type order_barangUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_warehouse_id?: StringFieldUpdateOperationsInput | string
    to_warehouse_id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order_barang_detail?: order_barang_detailUncheckedUpdateManyWithoutOrder_barangNestedInput
  }

  export type order_barangCreateManyInput = {
    id: string
    from_warehouse_id: string
    to_warehouse_id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type order_barangUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type order_barangUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_warehouse_id?: StringFieldUpdateOperationsInput | string
    to_warehouse_id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type order_barang_detailCreateInput = {
    id: string
    qty: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    barang: barangCreateNestedOneWithoutOrder_barang_detailInput
    order_barang: order_barangCreateNestedOneWithoutOrder_barang_detailInput
  }

  export type order_barang_detailUncheckedCreateInput = {
    id: string
    order_barang_id: string
    barang_id: string
    qty: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type order_barang_detailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    barang?: barangUpdateOneRequiredWithoutOrder_barang_detailNestedInput
    order_barang?: order_barangUpdateOneRequiredWithoutOrder_barang_detailNestedInput
  }

  export type order_barang_detailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_barang_id?: StringFieldUpdateOperationsInput | string
    barang_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type order_barang_detailCreateManyInput = {
    id: string
    order_barang_id: string
    barang_id: string
    qty: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type order_barang_detailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type order_barang_detailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_barang_id?: StringFieldUpdateOperationsInput | string
    barang_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type statusCreateInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employee?: employeeCreateNestedManyWithoutStatusInput
    users?: usersCreateNestedManyWithoutStatusInput
  }

  export type statusUncheckedCreateInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employee?: employeeUncheckedCreateNestedManyWithoutStatusInput
    users?: usersUncheckedCreateNestedManyWithoutStatusInput
  }

  export type statusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: employeeUpdateManyWithoutStatusNestedInput
    users?: usersUpdateManyWithoutStatusNestedInput
  }

  export type statusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: employeeUncheckedUpdateManyWithoutStatusNestedInput
    users?: usersUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type statusCreateManyInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type statusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type statusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksiCreateInput = {
    id: string
    point?: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    mekanik: mekanikCreateNestedOneWithoutTransaksiInput
    users: usersCreateNestedOneWithoutTransaksiInput
    warehouse: warehouseCreateNestedOneWithoutTransaksiInput
    transaksi_detail?: transaksi_detailCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiUncheckedCreateInput = {
    id: string
    users_id: string
    mekanik_id: string
    warehouse_id: string
    point?: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    transaksi_detail?: transaksi_detailUncheckedCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mekanik?: mekanikUpdateOneRequiredWithoutTransaksiNestedInput
    users?: usersUpdateOneRequiredWithoutTransaksiNestedInput
    warehouse?: warehouseUpdateOneRequiredWithoutTransaksiNestedInput
    transaksi_detail?: transaksi_detailUpdateManyWithoutTransaksiNestedInput
  }

  export type transaksiUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    users_id?: StringFieldUpdateOperationsInput | string
    mekanik_id?: StringFieldUpdateOperationsInput | string
    warehouse_id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi_detail?: transaksi_detailUncheckedUpdateManyWithoutTransaksiNestedInput
  }

  export type transaksiCreateManyInput = {
    id: string
    users_id: string
    mekanik_id: string
    warehouse_id: string
    point?: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type transaksiUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksiUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    users_id?: StringFieldUpdateOperationsInput | string
    mekanik_id?: StringFieldUpdateOperationsInput | string
    warehouse_id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksi_detailCreateInput = {
    id: string
    qty: number
    sub_total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    barang: barangCreateNestedOneWithoutTransaksi_detailInput
    transaksi: transaksiCreateNestedOneWithoutTransaksi_detailInput
  }

  export type transaksi_detailUncheckedCreateInput = {
    id: string
    transaksi_id: string
    barang_id: string
    qty: number
    sub_total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type transaksi_detailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    sub_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    barang?: barangUpdateOneRequiredWithoutTransaksi_detailNestedInput
    transaksi?: transaksiUpdateOneRequiredWithoutTransaksi_detailNestedInput
  }

  export type transaksi_detailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transaksi_id?: StringFieldUpdateOperationsInput | string
    barang_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    sub_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksi_detailCreateManyInput = {
    id: string
    transaksi_id: string
    barang_id: string
    qty: number
    sub_total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type transaksi_detailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    sub_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksi_detailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transaksi_id?: StringFieldUpdateOperationsInput | string
    barang_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    sub_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateInput = {
    id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    transaksi?: transaksiCreateNestedManyWithoutUsersInput
    member: memberCreateNestedOneWithoutUsersInput
    status: statusCreateNestedOneWithoutUsersInput
    vehicle_merk: vehicle_merkCreateNestedOneWithoutUsersInput
    vehicle_year: vehicle_yearCreateNestedOneWithoutUsersInput
    vehicle_type: vehicle_typeCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id: string
    status_id: string
    member_id: string
    vehicle_year_id: string
    vehicle_merk_id: string
    vehicle_type_id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    transaksi?: transaksiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUpdateManyWithoutUsersNestedInput
    member?: memberUpdateOneRequiredWithoutUsersNestedInput
    status?: statusUpdateOneRequiredWithoutUsersNestedInput
    vehicle_merk?: vehicle_merkUpdateOneRequiredWithoutUsersNestedInput
    vehicle_year?: vehicle_yearUpdateOneRequiredWithoutUsersNestedInput
    vehicle_type?: vehicle_typeUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status_id?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
    vehicle_year_id?: StringFieldUpdateOperationsInput | string
    vehicle_merk_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id: string
    status_id: string
    member_id: string
    vehicle_year_id: string
    vehicle_merk_id: string
    vehicle_type_id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status_id?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
    vehicle_year_id?: StringFieldUpdateOperationsInput | string
    vehicle_merk_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehicle_categoryCreateInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    barang?: barangCreateNestedManyWithoutVehicle_categoryInput
    vehicle_type?: vehicle_typeCreateNestedManyWithoutVehicle_categoryInput
  }

  export type vehicle_categoryUncheckedCreateInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    barang?: barangUncheckedCreateNestedManyWithoutVehicle_categoryInput
    vehicle_type?: vehicle_typeUncheckedCreateNestedManyWithoutVehicle_categoryInput
  }

  export type vehicle_categoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    barang?: barangUpdateManyWithoutVehicle_categoryNestedInput
    vehicle_type?: vehicle_typeUpdateManyWithoutVehicle_categoryNestedInput
  }

  export type vehicle_categoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    barang?: barangUncheckedUpdateManyWithoutVehicle_categoryNestedInput
    vehicle_type?: vehicle_typeUncheckedUpdateManyWithoutVehicle_categoryNestedInput
  }

  export type vehicle_categoryCreateManyInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type vehicle_categoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehicle_categoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehicle_merkCreateInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    users?: usersCreateNestedManyWithoutVehicle_merkInput
  }

  export type vehicle_merkUncheckedCreateInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    users?: usersUncheckedCreateNestedManyWithoutVehicle_merkInput
  }

  export type vehicle_merkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateManyWithoutVehicle_merkNestedInput
  }

  export type vehicle_merkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUncheckedUpdateManyWithoutVehicle_merkNestedInput
  }

  export type vehicle_merkCreateManyInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type vehicle_merkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehicle_merkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehicle_typeCreateInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    users?: usersCreateNestedManyWithoutVehicle_typeInput
    vehicle_category: vehicle_categoryCreateNestedOneWithoutVehicle_typeInput
  }

  export type vehicle_typeUncheckedCreateInput = {
    id: string
    vehicle_category_id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    users?: usersUncheckedCreateNestedManyWithoutVehicle_typeInput
  }

  export type vehicle_typeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateManyWithoutVehicle_typeNestedInput
    vehicle_category?: vehicle_categoryUpdateOneRequiredWithoutVehicle_typeNestedInput
  }

  export type vehicle_typeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicle_category_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUncheckedUpdateManyWithoutVehicle_typeNestedInput
  }

  export type vehicle_typeCreateManyInput = {
    id: string
    vehicle_category_id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type vehicle_typeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehicle_typeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicle_category_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehicle_yearCreateInput = {
    id: string
    year: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    users?: usersCreateNestedManyWithoutVehicle_yearInput
  }

  export type vehicle_yearUncheckedCreateInput = {
    id: string
    year: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    users?: usersUncheckedCreateNestedManyWithoutVehicle_yearInput
  }

  export type vehicle_yearUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateManyWithoutVehicle_yearNestedInput
  }

  export type vehicle_yearUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUncheckedUpdateManyWithoutVehicle_yearNestedInput
  }

  export type vehicle_yearCreateManyInput = {
    id: string
    year: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type vehicle_yearUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehicle_yearUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type warehouseCreateInput = {
    id: string
    name_warehouse: string
    username: string
    password: string
    warehouse_address: string
    phone_number_warehouse?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    mekanik?: mekanikCreateNestedManyWithoutWarehouseInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangCreateNestedManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangCreateNestedManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput
    transaksi?: transaksiCreateNestedManyWithoutWarehouseInput
    level: levelCreateNestedOneWithoutWarehouseInput
    warehouse_inventory?: warehouse_inventoryCreateNestedManyWithoutWarehouseInput
  }

  export type warehouseUncheckedCreateInput = {
    id: string
    level_id: string
    name_warehouse: string
    username: string
    password: string
    warehouse_address: string
    phone_number_warehouse?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    mekanik?: mekanikUncheckedCreateNestedManyWithoutWarehouseInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangUncheckedCreateNestedManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangUncheckedCreateNestedManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutWarehouseInput
    warehouse_inventory?: warehouse_inventoryUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type warehouseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_warehouse?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    warehouse_address?: StringFieldUpdateOperationsInput | string
    phone_number_warehouse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mekanik?: mekanikUpdateManyWithoutWarehouseNestedInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangUpdateManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseNestedInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangUpdateManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseNestedInput
    transaksi?: transaksiUpdateManyWithoutWarehouseNestedInput
    level?: levelUpdateOneRequiredWithoutWarehouseNestedInput
    warehouse_inventory?: warehouse_inventoryUpdateManyWithoutWarehouseNestedInput
  }

  export type warehouseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level_id?: StringFieldUpdateOperationsInput | string
    name_warehouse?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    warehouse_address?: StringFieldUpdateOperationsInput | string
    phone_number_warehouse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mekanik?: mekanikUncheckedUpdateManyWithoutWarehouseNestedInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangUncheckedUpdateManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseNestedInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangUncheckedUpdateManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutWarehouseNestedInput
    warehouse_inventory?: warehouse_inventoryUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type warehouseCreateManyInput = {
    id: string
    level_id: string
    name_warehouse: string
    username: string
    password: string
    warehouse_address: string
    phone_number_warehouse?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type warehouseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_warehouse?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    warehouse_address?: StringFieldUpdateOperationsInput | string
    phone_number_warehouse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type warehouseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    level_id?: StringFieldUpdateOperationsInput | string
    name_warehouse?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    warehouse_address?: StringFieldUpdateOperationsInput | string
    phone_number_warehouse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type warehouse_inventoryCreateInput = {
    id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    inventory?: inventoryCreateNestedManyWithoutWarehouse_inventoryInput
    warehouse: warehouseCreateNestedOneWithoutWarehouse_inventoryInput
  }

  export type warehouse_inventoryUncheckedCreateInput = {
    id: string
    warehouse_id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    inventory?: inventoryUncheckedCreateNestedManyWithoutWarehouse_inventoryInput
  }

  export type warehouse_inventoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventory?: inventoryUpdateManyWithoutWarehouse_inventoryNestedInput
    warehouse?: warehouseUpdateOneRequiredWithoutWarehouse_inventoryNestedInput
  }

  export type warehouse_inventoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouse_id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventory?: inventoryUncheckedUpdateManyWithoutWarehouse_inventoryNestedInput
  }

  export type warehouse_inventoryCreateManyInput = {
    id: string
    warehouse_id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type warehouse_inventoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type warehouse_inventoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouse_id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Vehicle_categoryScalarRelationFilter = {
    is?: vehicle_categoryWhereInput
    isNot?: vehicle_categoryWhereInput
  }

  export type InventoryListRelationFilter = {
    every?: inventoryWhereInput
    some?: inventoryWhereInput
    none?: inventoryWhereInput
  }

  export type Order_barang_detailListRelationFilter = {
    every?: order_barang_detailWhereInput
    some?: order_barang_detailWhereInput
    none?: order_barang_detailWhereInput
  }

  export type Transaksi_detailListRelationFilter = {
    every?: transaksi_detailWhereInput
    some?: transaksi_detailWhereInput
    none?: transaksi_detailWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type inventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type order_barang_detailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type transaksi_detailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type barangCountOrderByAggregateInput = {
    id?: SortOrder
    category_vehicle_id?: SortOrder
    name_barang?: SortOrder
    description_barang?: SortOrder
    price?: SortOrder
    point?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type barangAvgOrderByAggregateInput = {
    price?: SortOrder
    point?: SortOrder
  }

  export type barangMaxOrderByAggregateInput = {
    id?: SortOrder
    category_vehicle_id?: SortOrder
    name_barang?: SortOrder
    description_barang?: SortOrder
    price?: SortOrder
    point?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type barangMinOrderByAggregateInput = {
    id?: SortOrder
    category_vehicle_id?: SortOrder
    name_barang?: SortOrder
    description_barang?: SortOrder
    price?: SortOrder
    point?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type barangSumOrderByAggregateInput = {
    price?: SortOrder
    point?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StatusScalarRelationFilter = {
    is?: statusWhereInput
    isNot?: statusWhereInput
  }

  export type MekanikListRelationFilter = {
    every?: mekanikWhereInput
    some?: mekanikWhereInput
    none?: mekanikWhereInput
  }

  export type mekanikOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type employeeCountOrderByAggregateInput = {
    id?: SortOrder
    status_id?: SortOrder
    name?: SortOrder
    point?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type employeeAvgOrderByAggregateInput = {
    point?: SortOrder
  }

  export type employeeMaxOrderByAggregateInput = {
    id?: SortOrder
    status_id?: SortOrder
    name?: SortOrder
    point?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type employeeMinOrderByAggregateInput = {
    id?: SortOrder
    status_id?: SortOrder
    name?: SortOrder
    point?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type employeeSumOrderByAggregateInput = {
    point?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BarangScalarRelationFilter = {
    is?: barangWhereInput
    isNot?: barangWhereInput
  }

  export type Warehouse_inventoryScalarRelationFilter = {
    is?: warehouse_inventoryWhereInput
    isNot?: warehouse_inventoryWhereInput
  }

  export type inventoryCountOrderByAggregateInput = {
    id?: SortOrder
    warehouse_inventory_id?: SortOrder
    barang_id?: SortOrder
    qty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type inventoryAvgOrderByAggregateInput = {
    qty?: SortOrder
  }

  export type inventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    warehouse_inventory_id?: SortOrder
    barang_id?: SortOrder
    qty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type inventoryMinOrderByAggregateInput = {
    id?: SortOrder
    warehouse_inventory_id?: SortOrder
    barang_id?: SortOrder
    qty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type inventorySumOrderByAggregateInput = {
    qty?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type WarehouseListRelationFilter = {
    every?: warehouseWhereInput
    some?: warehouseWhereInput
    none?: warehouseWhereInput
  }

  export type warehouseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type levelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type levelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type levelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeScalarRelationFilter = {
    is?: employeeWhereInput
    isNot?: employeeWhereInput
  }

  export type WarehouseScalarRelationFilter = {
    is?: warehouseWhereInput
    isNot?: warehouseWhereInput
  }

  export type TransaksiListRelationFilter = {
    every?: transaksiWhereInput
    some?: transaksiWhereInput
    none?: transaksiWhereInput
  }

  export type transaksiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mekanikCountOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    warehouse_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type mekanikMaxOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    warehouse_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type mekanikMinOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    warehouse_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type memberCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type memberMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type memberMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type order_barangCountOrderByAggregateInput = {
    id?: SortOrder
    from_warehouse_id?: SortOrder
    to_warehouse_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type order_barangMaxOrderByAggregateInput = {
    id?: SortOrder
    from_warehouse_id?: SortOrder
    to_warehouse_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type order_barangMinOrderByAggregateInput = {
    id?: SortOrder
    from_warehouse_id?: SortOrder
    to_warehouse_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Order_barangScalarRelationFilter = {
    is?: order_barangWhereInput
    isNot?: order_barangWhereInput
  }

  export type order_barang_detailCountOrderByAggregateInput = {
    id?: SortOrder
    order_barang_id?: SortOrder
    barang_id?: SortOrder
    qty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type order_barang_detailAvgOrderByAggregateInput = {
    qty?: SortOrder
  }

  export type order_barang_detailMaxOrderByAggregateInput = {
    id?: SortOrder
    order_barang_id?: SortOrder
    barang_id?: SortOrder
    qty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type order_barang_detailMinOrderByAggregateInput = {
    id?: SortOrder
    order_barang_id?: SortOrder
    barang_id?: SortOrder
    qty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type order_barang_detailSumOrderByAggregateInput = {
    qty?: SortOrder
  }

  export type EmployeeListRelationFilter = {
    every?: employeeWhereInput
    some?: employeeWhereInput
    none?: employeeWhereInput
  }

  export type employeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type statusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type statusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type statusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MekanikScalarRelationFilter = {
    is?: mekanikWhereInput
    isNot?: mekanikWhereInput
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type transaksiCountOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    mekanik_id?: SortOrder
    warehouse_id?: SortOrder
    point?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transaksiAvgOrderByAggregateInput = {
    point?: SortOrder
    total?: SortOrder
  }

  export type transaksiMaxOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    mekanik_id?: SortOrder
    warehouse_id?: SortOrder
    point?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transaksiMinOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    mekanik_id?: SortOrder
    warehouse_id?: SortOrder
    point?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transaksiSumOrderByAggregateInput = {
    point?: SortOrder
    total?: SortOrder
  }

  export type TransaksiScalarRelationFilter = {
    is?: transaksiWhereInput
    isNot?: transaksiWhereInput
  }

  export type transaksi_detailCountOrderByAggregateInput = {
    id?: SortOrder
    transaksi_id?: SortOrder
    barang_id?: SortOrder
    qty?: SortOrder
    sub_total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transaksi_detailAvgOrderByAggregateInput = {
    qty?: SortOrder
    sub_total?: SortOrder
  }

  export type transaksi_detailMaxOrderByAggregateInput = {
    id?: SortOrder
    transaksi_id?: SortOrder
    barang_id?: SortOrder
    qty?: SortOrder
    sub_total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transaksi_detailMinOrderByAggregateInput = {
    id?: SortOrder
    transaksi_id?: SortOrder
    barang_id?: SortOrder
    qty?: SortOrder
    sub_total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transaksi_detailSumOrderByAggregateInput = {
    qty?: SortOrder
    sub_total?: SortOrder
  }

  export type MemberScalarRelationFilter = {
    is?: memberWhereInput
    isNot?: memberWhereInput
  }

  export type Vehicle_merkScalarRelationFilter = {
    is?: vehicle_merkWhereInput
    isNot?: vehicle_merkWhereInput
  }

  export type Vehicle_yearScalarRelationFilter = {
    is?: vehicle_yearWhereInput
    isNot?: vehicle_yearWhereInput
  }

  export type Vehicle_typeScalarRelationFilter = {
    is?: vehicle_typeWhereInput
    isNot?: vehicle_typeWhereInput
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    status_id?: SortOrder
    member_id?: SortOrder
    vehicle_year_id?: SortOrder
    vehicle_merk_id?: SortOrder
    vehicle_type_id?: SortOrder
    no_police?: SortOrder
    name?: SortOrder
    point?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    point?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    status_id?: SortOrder
    member_id?: SortOrder
    vehicle_year_id?: SortOrder
    vehicle_merk_id?: SortOrder
    vehicle_type_id?: SortOrder
    no_police?: SortOrder
    name?: SortOrder
    point?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    status_id?: SortOrder
    member_id?: SortOrder
    vehicle_year_id?: SortOrder
    vehicle_merk_id?: SortOrder
    vehicle_type_id?: SortOrder
    no_police?: SortOrder
    name?: SortOrder
    point?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    point?: SortOrder
  }

  export type BarangListRelationFilter = {
    every?: barangWhereInput
    some?: barangWhereInput
    none?: barangWhereInput
  }

  export type Vehicle_typeListRelationFilter = {
    every?: vehicle_typeWhereInput
    some?: vehicle_typeWhereInput
    none?: vehicle_typeWhereInput
  }

  export type barangOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vehicle_typeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vehicle_categoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_categoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_merkCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_merkMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_merkMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_typeCountOrderByAggregateInput = {
    id?: SortOrder
    vehicle_category_id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    vehicle_category_id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_typeMinOrderByAggregateInput = {
    id?: SortOrder
    vehicle_category_id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_yearCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_yearMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_yearMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Order_barangListRelationFilter = {
    every?: order_barangWhereInput
    some?: order_barangWhereInput
    none?: order_barangWhereInput
  }

  export type LevelScalarRelationFilter = {
    is?: levelWhereInput
    isNot?: levelWhereInput
  }

  export type Warehouse_inventoryListRelationFilter = {
    every?: warehouse_inventoryWhereInput
    some?: warehouse_inventoryWhereInput
    none?: warehouse_inventoryWhereInput
  }

  export type order_barangOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type warehouse_inventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type warehouseCountOrderByAggregateInput = {
    id?: SortOrder
    level_id?: SortOrder
    name_warehouse?: SortOrder
    username?: SortOrder
    password?: SortOrder
    warehouse_address?: SortOrder
    phone_number_warehouse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type warehouseMaxOrderByAggregateInput = {
    id?: SortOrder
    level_id?: SortOrder
    name_warehouse?: SortOrder
    username?: SortOrder
    password?: SortOrder
    warehouse_address?: SortOrder
    phone_number_warehouse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type warehouseMinOrderByAggregateInput = {
    id?: SortOrder
    level_id?: SortOrder
    name_warehouse?: SortOrder
    username?: SortOrder
    password?: SortOrder
    warehouse_address?: SortOrder
    phone_number_warehouse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type warehouse_inventoryCountOrderByAggregateInput = {
    id?: SortOrder
    warehouse_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type warehouse_inventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    warehouse_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type warehouse_inventoryMinOrderByAggregateInput = {
    id?: SortOrder
    warehouse_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_categoryCreateNestedOneWithoutBarangInput = {
    create?: XOR<vehicle_categoryCreateWithoutBarangInput, vehicle_categoryUncheckedCreateWithoutBarangInput>
    connectOrCreate?: vehicle_categoryCreateOrConnectWithoutBarangInput
    connect?: vehicle_categoryWhereUniqueInput
  }

  export type inventoryCreateNestedManyWithoutBarangInput = {
    create?: XOR<inventoryCreateWithoutBarangInput, inventoryUncheckedCreateWithoutBarangInput> | inventoryCreateWithoutBarangInput[] | inventoryUncheckedCreateWithoutBarangInput[]
    connectOrCreate?: inventoryCreateOrConnectWithoutBarangInput | inventoryCreateOrConnectWithoutBarangInput[]
    createMany?: inventoryCreateManyBarangInputEnvelope
    connect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
  }

  export type order_barang_detailCreateNestedManyWithoutBarangInput = {
    create?: XOR<order_barang_detailCreateWithoutBarangInput, order_barang_detailUncheckedCreateWithoutBarangInput> | order_barang_detailCreateWithoutBarangInput[] | order_barang_detailUncheckedCreateWithoutBarangInput[]
    connectOrCreate?: order_barang_detailCreateOrConnectWithoutBarangInput | order_barang_detailCreateOrConnectWithoutBarangInput[]
    createMany?: order_barang_detailCreateManyBarangInputEnvelope
    connect?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
  }

  export type transaksi_detailCreateNestedManyWithoutBarangInput = {
    create?: XOR<transaksi_detailCreateWithoutBarangInput, transaksi_detailUncheckedCreateWithoutBarangInput> | transaksi_detailCreateWithoutBarangInput[] | transaksi_detailUncheckedCreateWithoutBarangInput[]
    connectOrCreate?: transaksi_detailCreateOrConnectWithoutBarangInput | transaksi_detailCreateOrConnectWithoutBarangInput[]
    createMany?: transaksi_detailCreateManyBarangInputEnvelope
    connect?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
  }

  export type inventoryUncheckedCreateNestedManyWithoutBarangInput = {
    create?: XOR<inventoryCreateWithoutBarangInput, inventoryUncheckedCreateWithoutBarangInput> | inventoryCreateWithoutBarangInput[] | inventoryUncheckedCreateWithoutBarangInput[]
    connectOrCreate?: inventoryCreateOrConnectWithoutBarangInput | inventoryCreateOrConnectWithoutBarangInput[]
    createMany?: inventoryCreateManyBarangInputEnvelope
    connect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
  }

  export type order_barang_detailUncheckedCreateNestedManyWithoutBarangInput = {
    create?: XOR<order_barang_detailCreateWithoutBarangInput, order_barang_detailUncheckedCreateWithoutBarangInput> | order_barang_detailCreateWithoutBarangInput[] | order_barang_detailUncheckedCreateWithoutBarangInput[]
    connectOrCreate?: order_barang_detailCreateOrConnectWithoutBarangInput | order_barang_detailCreateOrConnectWithoutBarangInput[]
    createMany?: order_barang_detailCreateManyBarangInputEnvelope
    connect?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
  }

  export type transaksi_detailUncheckedCreateNestedManyWithoutBarangInput = {
    create?: XOR<transaksi_detailCreateWithoutBarangInput, transaksi_detailUncheckedCreateWithoutBarangInput> | transaksi_detailCreateWithoutBarangInput[] | transaksi_detailUncheckedCreateWithoutBarangInput[]
    connectOrCreate?: transaksi_detailCreateOrConnectWithoutBarangInput | transaksi_detailCreateOrConnectWithoutBarangInput[]
    createMany?: transaksi_detailCreateManyBarangInputEnvelope
    connect?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type vehicle_categoryUpdateOneRequiredWithoutBarangNestedInput = {
    create?: XOR<vehicle_categoryCreateWithoutBarangInput, vehicle_categoryUncheckedCreateWithoutBarangInput>
    connectOrCreate?: vehicle_categoryCreateOrConnectWithoutBarangInput
    upsert?: vehicle_categoryUpsertWithoutBarangInput
    connect?: vehicle_categoryWhereUniqueInput
    update?: XOR<XOR<vehicle_categoryUpdateToOneWithWhereWithoutBarangInput, vehicle_categoryUpdateWithoutBarangInput>, vehicle_categoryUncheckedUpdateWithoutBarangInput>
  }

  export type inventoryUpdateManyWithoutBarangNestedInput = {
    create?: XOR<inventoryCreateWithoutBarangInput, inventoryUncheckedCreateWithoutBarangInput> | inventoryCreateWithoutBarangInput[] | inventoryUncheckedCreateWithoutBarangInput[]
    connectOrCreate?: inventoryCreateOrConnectWithoutBarangInput | inventoryCreateOrConnectWithoutBarangInput[]
    upsert?: inventoryUpsertWithWhereUniqueWithoutBarangInput | inventoryUpsertWithWhereUniqueWithoutBarangInput[]
    createMany?: inventoryCreateManyBarangInputEnvelope
    set?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    disconnect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    delete?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    connect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    update?: inventoryUpdateWithWhereUniqueWithoutBarangInput | inventoryUpdateWithWhereUniqueWithoutBarangInput[]
    updateMany?: inventoryUpdateManyWithWhereWithoutBarangInput | inventoryUpdateManyWithWhereWithoutBarangInput[]
    deleteMany?: inventoryScalarWhereInput | inventoryScalarWhereInput[]
  }

  export type order_barang_detailUpdateManyWithoutBarangNestedInput = {
    create?: XOR<order_barang_detailCreateWithoutBarangInput, order_barang_detailUncheckedCreateWithoutBarangInput> | order_barang_detailCreateWithoutBarangInput[] | order_barang_detailUncheckedCreateWithoutBarangInput[]
    connectOrCreate?: order_barang_detailCreateOrConnectWithoutBarangInput | order_barang_detailCreateOrConnectWithoutBarangInput[]
    upsert?: order_barang_detailUpsertWithWhereUniqueWithoutBarangInput | order_barang_detailUpsertWithWhereUniqueWithoutBarangInput[]
    createMany?: order_barang_detailCreateManyBarangInputEnvelope
    set?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
    disconnect?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
    delete?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
    connect?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
    update?: order_barang_detailUpdateWithWhereUniqueWithoutBarangInput | order_barang_detailUpdateWithWhereUniqueWithoutBarangInput[]
    updateMany?: order_barang_detailUpdateManyWithWhereWithoutBarangInput | order_barang_detailUpdateManyWithWhereWithoutBarangInput[]
    deleteMany?: order_barang_detailScalarWhereInput | order_barang_detailScalarWhereInput[]
  }

  export type transaksi_detailUpdateManyWithoutBarangNestedInput = {
    create?: XOR<transaksi_detailCreateWithoutBarangInput, transaksi_detailUncheckedCreateWithoutBarangInput> | transaksi_detailCreateWithoutBarangInput[] | transaksi_detailUncheckedCreateWithoutBarangInput[]
    connectOrCreate?: transaksi_detailCreateOrConnectWithoutBarangInput | transaksi_detailCreateOrConnectWithoutBarangInput[]
    upsert?: transaksi_detailUpsertWithWhereUniqueWithoutBarangInput | transaksi_detailUpsertWithWhereUniqueWithoutBarangInput[]
    createMany?: transaksi_detailCreateManyBarangInputEnvelope
    set?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
    disconnect?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
    delete?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
    connect?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
    update?: transaksi_detailUpdateWithWhereUniqueWithoutBarangInput | transaksi_detailUpdateWithWhereUniqueWithoutBarangInput[]
    updateMany?: transaksi_detailUpdateManyWithWhereWithoutBarangInput | transaksi_detailUpdateManyWithWhereWithoutBarangInput[]
    deleteMany?: transaksi_detailScalarWhereInput | transaksi_detailScalarWhereInput[]
  }

  export type inventoryUncheckedUpdateManyWithoutBarangNestedInput = {
    create?: XOR<inventoryCreateWithoutBarangInput, inventoryUncheckedCreateWithoutBarangInput> | inventoryCreateWithoutBarangInput[] | inventoryUncheckedCreateWithoutBarangInput[]
    connectOrCreate?: inventoryCreateOrConnectWithoutBarangInput | inventoryCreateOrConnectWithoutBarangInput[]
    upsert?: inventoryUpsertWithWhereUniqueWithoutBarangInput | inventoryUpsertWithWhereUniqueWithoutBarangInput[]
    createMany?: inventoryCreateManyBarangInputEnvelope
    set?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    disconnect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    delete?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    connect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    update?: inventoryUpdateWithWhereUniqueWithoutBarangInput | inventoryUpdateWithWhereUniqueWithoutBarangInput[]
    updateMany?: inventoryUpdateManyWithWhereWithoutBarangInput | inventoryUpdateManyWithWhereWithoutBarangInput[]
    deleteMany?: inventoryScalarWhereInput | inventoryScalarWhereInput[]
  }

  export type order_barang_detailUncheckedUpdateManyWithoutBarangNestedInput = {
    create?: XOR<order_barang_detailCreateWithoutBarangInput, order_barang_detailUncheckedCreateWithoutBarangInput> | order_barang_detailCreateWithoutBarangInput[] | order_barang_detailUncheckedCreateWithoutBarangInput[]
    connectOrCreate?: order_barang_detailCreateOrConnectWithoutBarangInput | order_barang_detailCreateOrConnectWithoutBarangInput[]
    upsert?: order_barang_detailUpsertWithWhereUniqueWithoutBarangInput | order_barang_detailUpsertWithWhereUniqueWithoutBarangInput[]
    createMany?: order_barang_detailCreateManyBarangInputEnvelope
    set?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
    disconnect?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
    delete?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
    connect?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
    update?: order_barang_detailUpdateWithWhereUniqueWithoutBarangInput | order_barang_detailUpdateWithWhereUniqueWithoutBarangInput[]
    updateMany?: order_barang_detailUpdateManyWithWhereWithoutBarangInput | order_barang_detailUpdateManyWithWhereWithoutBarangInput[]
    deleteMany?: order_barang_detailScalarWhereInput | order_barang_detailScalarWhereInput[]
  }

  export type transaksi_detailUncheckedUpdateManyWithoutBarangNestedInput = {
    create?: XOR<transaksi_detailCreateWithoutBarangInput, transaksi_detailUncheckedCreateWithoutBarangInput> | transaksi_detailCreateWithoutBarangInput[] | transaksi_detailUncheckedCreateWithoutBarangInput[]
    connectOrCreate?: transaksi_detailCreateOrConnectWithoutBarangInput | transaksi_detailCreateOrConnectWithoutBarangInput[]
    upsert?: transaksi_detailUpsertWithWhereUniqueWithoutBarangInput | transaksi_detailUpsertWithWhereUniqueWithoutBarangInput[]
    createMany?: transaksi_detailCreateManyBarangInputEnvelope
    set?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
    disconnect?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
    delete?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
    connect?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
    update?: transaksi_detailUpdateWithWhereUniqueWithoutBarangInput | transaksi_detailUpdateWithWhereUniqueWithoutBarangInput[]
    updateMany?: transaksi_detailUpdateManyWithWhereWithoutBarangInput | transaksi_detailUpdateManyWithWhereWithoutBarangInput[]
    deleteMany?: transaksi_detailScalarWhereInput | transaksi_detailScalarWhereInput[]
  }

  export type statusCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<statusCreateWithoutEmployeeInput, statusUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: statusCreateOrConnectWithoutEmployeeInput
    connect?: statusWhereUniqueInput
  }

  export type mekanikCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<mekanikCreateWithoutEmployeeInput, mekanikUncheckedCreateWithoutEmployeeInput> | mekanikCreateWithoutEmployeeInput[] | mekanikUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: mekanikCreateOrConnectWithoutEmployeeInput | mekanikCreateOrConnectWithoutEmployeeInput[]
    createMany?: mekanikCreateManyEmployeeInputEnvelope
    connect?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
  }

  export type mekanikUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<mekanikCreateWithoutEmployeeInput, mekanikUncheckedCreateWithoutEmployeeInput> | mekanikCreateWithoutEmployeeInput[] | mekanikUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: mekanikCreateOrConnectWithoutEmployeeInput | mekanikCreateOrConnectWithoutEmployeeInput[]
    createMany?: mekanikCreateManyEmployeeInputEnvelope
    connect?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
  }

  export type statusUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<statusCreateWithoutEmployeeInput, statusUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: statusCreateOrConnectWithoutEmployeeInput
    upsert?: statusUpsertWithoutEmployeeInput
    connect?: statusWhereUniqueInput
    update?: XOR<XOR<statusUpdateToOneWithWhereWithoutEmployeeInput, statusUpdateWithoutEmployeeInput>, statusUncheckedUpdateWithoutEmployeeInput>
  }

  export type mekanikUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<mekanikCreateWithoutEmployeeInput, mekanikUncheckedCreateWithoutEmployeeInput> | mekanikCreateWithoutEmployeeInput[] | mekanikUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: mekanikCreateOrConnectWithoutEmployeeInput | mekanikCreateOrConnectWithoutEmployeeInput[]
    upsert?: mekanikUpsertWithWhereUniqueWithoutEmployeeInput | mekanikUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: mekanikCreateManyEmployeeInputEnvelope
    set?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
    disconnect?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
    delete?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
    connect?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
    update?: mekanikUpdateWithWhereUniqueWithoutEmployeeInput | mekanikUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: mekanikUpdateManyWithWhereWithoutEmployeeInput | mekanikUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: mekanikScalarWhereInput | mekanikScalarWhereInput[]
  }

  export type mekanikUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<mekanikCreateWithoutEmployeeInput, mekanikUncheckedCreateWithoutEmployeeInput> | mekanikCreateWithoutEmployeeInput[] | mekanikUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: mekanikCreateOrConnectWithoutEmployeeInput | mekanikCreateOrConnectWithoutEmployeeInput[]
    upsert?: mekanikUpsertWithWhereUniqueWithoutEmployeeInput | mekanikUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: mekanikCreateManyEmployeeInputEnvelope
    set?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
    disconnect?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
    delete?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
    connect?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
    update?: mekanikUpdateWithWhereUniqueWithoutEmployeeInput | mekanikUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: mekanikUpdateManyWithWhereWithoutEmployeeInput | mekanikUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: mekanikScalarWhereInput | mekanikScalarWhereInput[]
  }

  export type barangCreateNestedOneWithoutInventoryInput = {
    create?: XOR<barangCreateWithoutInventoryInput, barangUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: barangCreateOrConnectWithoutInventoryInput
    connect?: barangWhereUniqueInput
  }

  export type warehouse_inventoryCreateNestedOneWithoutInventoryInput = {
    create?: XOR<warehouse_inventoryCreateWithoutInventoryInput, warehouse_inventoryUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: warehouse_inventoryCreateOrConnectWithoutInventoryInput
    connect?: warehouse_inventoryWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type barangUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<barangCreateWithoutInventoryInput, barangUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: barangCreateOrConnectWithoutInventoryInput
    upsert?: barangUpsertWithoutInventoryInput
    connect?: barangWhereUniqueInput
    update?: XOR<XOR<barangUpdateToOneWithWhereWithoutInventoryInput, barangUpdateWithoutInventoryInput>, barangUncheckedUpdateWithoutInventoryInput>
  }

  export type warehouse_inventoryUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<warehouse_inventoryCreateWithoutInventoryInput, warehouse_inventoryUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: warehouse_inventoryCreateOrConnectWithoutInventoryInput
    upsert?: warehouse_inventoryUpsertWithoutInventoryInput
    connect?: warehouse_inventoryWhereUniqueInput
    update?: XOR<XOR<warehouse_inventoryUpdateToOneWithWhereWithoutInventoryInput, warehouse_inventoryUpdateWithoutInventoryInput>, warehouse_inventoryUncheckedUpdateWithoutInventoryInput>
  }

  export type warehouseCreateNestedManyWithoutLevelInput = {
    create?: XOR<warehouseCreateWithoutLevelInput, warehouseUncheckedCreateWithoutLevelInput> | warehouseCreateWithoutLevelInput[] | warehouseUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: warehouseCreateOrConnectWithoutLevelInput | warehouseCreateOrConnectWithoutLevelInput[]
    createMany?: warehouseCreateManyLevelInputEnvelope
    connect?: warehouseWhereUniqueInput | warehouseWhereUniqueInput[]
  }

  export type warehouseUncheckedCreateNestedManyWithoutLevelInput = {
    create?: XOR<warehouseCreateWithoutLevelInput, warehouseUncheckedCreateWithoutLevelInput> | warehouseCreateWithoutLevelInput[] | warehouseUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: warehouseCreateOrConnectWithoutLevelInput | warehouseCreateOrConnectWithoutLevelInput[]
    createMany?: warehouseCreateManyLevelInputEnvelope
    connect?: warehouseWhereUniqueInput | warehouseWhereUniqueInput[]
  }

  export type warehouseUpdateManyWithoutLevelNestedInput = {
    create?: XOR<warehouseCreateWithoutLevelInput, warehouseUncheckedCreateWithoutLevelInput> | warehouseCreateWithoutLevelInput[] | warehouseUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: warehouseCreateOrConnectWithoutLevelInput | warehouseCreateOrConnectWithoutLevelInput[]
    upsert?: warehouseUpsertWithWhereUniqueWithoutLevelInput | warehouseUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: warehouseCreateManyLevelInputEnvelope
    set?: warehouseWhereUniqueInput | warehouseWhereUniqueInput[]
    disconnect?: warehouseWhereUniqueInput | warehouseWhereUniqueInput[]
    delete?: warehouseWhereUniqueInput | warehouseWhereUniqueInput[]
    connect?: warehouseWhereUniqueInput | warehouseWhereUniqueInput[]
    update?: warehouseUpdateWithWhereUniqueWithoutLevelInput | warehouseUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: warehouseUpdateManyWithWhereWithoutLevelInput | warehouseUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: warehouseScalarWhereInput | warehouseScalarWhereInput[]
  }

  export type warehouseUncheckedUpdateManyWithoutLevelNestedInput = {
    create?: XOR<warehouseCreateWithoutLevelInput, warehouseUncheckedCreateWithoutLevelInput> | warehouseCreateWithoutLevelInput[] | warehouseUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: warehouseCreateOrConnectWithoutLevelInput | warehouseCreateOrConnectWithoutLevelInput[]
    upsert?: warehouseUpsertWithWhereUniqueWithoutLevelInput | warehouseUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: warehouseCreateManyLevelInputEnvelope
    set?: warehouseWhereUniqueInput | warehouseWhereUniqueInput[]
    disconnect?: warehouseWhereUniqueInput | warehouseWhereUniqueInput[]
    delete?: warehouseWhereUniqueInput | warehouseWhereUniqueInput[]
    connect?: warehouseWhereUniqueInput | warehouseWhereUniqueInput[]
    update?: warehouseUpdateWithWhereUniqueWithoutLevelInput | warehouseUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: warehouseUpdateManyWithWhereWithoutLevelInput | warehouseUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: warehouseScalarWhereInput | warehouseScalarWhereInput[]
  }

  export type employeeCreateNestedOneWithoutMekanikInput = {
    create?: XOR<employeeCreateWithoutMekanikInput, employeeUncheckedCreateWithoutMekanikInput>
    connectOrCreate?: employeeCreateOrConnectWithoutMekanikInput
    connect?: employeeWhereUniqueInput
  }

  export type warehouseCreateNestedOneWithoutMekanikInput = {
    create?: XOR<warehouseCreateWithoutMekanikInput, warehouseUncheckedCreateWithoutMekanikInput>
    connectOrCreate?: warehouseCreateOrConnectWithoutMekanikInput
    connect?: warehouseWhereUniqueInput
  }

  export type transaksiCreateNestedManyWithoutMekanikInput = {
    create?: XOR<transaksiCreateWithoutMekanikInput, transaksiUncheckedCreateWithoutMekanikInput> | transaksiCreateWithoutMekanikInput[] | transaksiUncheckedCreateWithoutMekanikInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutMekanikInput | transaksiCreateOrConnectWithoutMekanikInput[]
    createMany?: transaksiCreateManyMekanikInputEnvelope
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
  }

  export type transaksiUncheckedCreateNestedManyWithoutMekanikInput = {
    create?: XOR<transaksiCreateWithoutMekanikInput, transaksiUncheckedCreateWithoutMekanikInput> | transaksiCreateWithoutMekanikInput[] | transaksiUncheckedCreateWithoutMekanikInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutMekanikInput | transaksiCreateOrConnectWithoutMekanikInput[]
    createMany?: transaksiCreateManyMekanikInputEnvelope
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
  }

  export type employeeUpdateOneRequiredWithoutMekanikNestedInput = {
    create?: XOR<employeeCreateWithoutMekanikInput, employeeUncheckedCreateWithoutMekanikInput>
    connectOrCreate?: employeeCreateOrConnectWithoutMekanikInput
    upsert?: employeeUpsertWithoutMekanikInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutMekanikInput, employeeUpdateWithoutMekanikInput>, employeeUncheckedUpdateWithoutMekanikInput>
  }

  export type warehouseUpdateOneRequiredWithoutMekanikNestedInput = {
    create?: XOR<warehouseCreateWithoutMekanikInput, warehouseUncheckedCreateWithoutMekanikInput>
    connectOrCreate?: warehouseCreateOrConnectWithoutMekanikInput
    upsert?: warehouseUpsertWithoutMekanikInput
    connect?: warehouseWhereUniqueInput
    update?: XOR<XOR<warehouseUpdateToOneWithWhereWithoutMekanikInput, warehouseUpdateWithoutMekanikInput>, warehouseUncheckedUpdateWithoutMekanikInput>
  }

  export type transaksiUpdateManyWithoutMekanikNestedInput = {
    create?: XOR<transaksiCreateWithoutMekanikInput, transaksiUncheckedCreateWithoutMekanikInput> | transaksiCreateWithoutMekanikInput[] | transaksiUncheckedCreateWithoutMekanikInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutMekanikInput | transaksiCreateOrConnectWithoutMekanikInput[]
    upsert?: transaksiUpsertWithWhereUniqueWithoutMekanikInput | transaksiUpsertWithWhereUniqueWithoutMekanikInput[]
    createMany?: transaksiCreateManyMekanikInputEnvelope
    set?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    disconnect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    delete?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    update?: transaksiUpdateWithWhereUniqueWithoutMekanikInput | transaksiUpdateWithWhereUniqueWithoutMekanikInput[]
    updateMany?: transaksiUpdateManyWithWhereWithoutMekanikInput | transaksiUpdateManyWithWhereWithoutMekanikInput[]
    deleteMany?: transaksiScalarWhereInput | transaksiScalarWhereInput[]
  }

  export type transaksiUncheckedUpdateManyWithoutMekanikNestedInput = {
    create?: XOR<transaksiCreateWithoutMekanikInput, transaksiUncheckedCreateWithoutMekanikInput> | transaksiCreateWithoutMekanikInput[] | transaksiUncheckedCreateWithoutMekanikInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutMekanikInput | transaksiCreateOrConnectWithoutMekanikInput[]
    upsert?: transaksiUpsertWithWhereUniqueWithoutMekanikInput | transaksiUpsertWithWhereUniqueWithoutMekanikInput[]
    createMany?: transaksiCreateManyMekanikInputEnvelope
    set?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    disconnect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    delete?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    update?: transaksiUpdateWithWhereUniqueWithoutMekanikInput | transaksiUpdateWithWhereUniqueWithoutMekanikInput[]
    updateMany?: transaksiUpdateManyWithWhereWithoutMekanikInput | transaksiUpdateManyWithWhereWithoutMekanikInput[]
    deleteMany?: transaksiScalarWhereInput | transaksiScalarWhereInput[]
  }

  export type usersCreateNestedManyWithoutMemberInput = {
    create?: XOR<usersCreateWithoutMemberInput, usersUncheckedCreateWithoutMemberInput> | usersCreateWithoutMemberInput[] | usersUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: usersCreateOrConnectWithoutMemberInput | usersCreateOrConnectWithoutMemberInput[]
    createMany?: usersCreateManyMemberInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<usersCreateWithoutMemberInput, usersUncheckedCreateWithoutMemberInput> | usersCreateWithoutMemberInput[] | usersUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: usersCreateOrConnectWithoutMemberInput | usersCreateOrConnectWithoutMemberInput[]
    createMany?: usersCreateManyMemberInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUpdateManyWithoutMemberNestedInput = {
    create?: XOR<usersCreateWithoutMemberInput, usersUncheckedCreateWithoutMemberInput> | usersCreateWithoutMemberInput[] | usersUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: usersCreateOrConnectWithoutMemberInput | usersCreateOrConnectWithoutMemberInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutMemberInput | usersUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: usersCreateManyMemberInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutMemberInput | usersUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: usersUpdateManyWithWhereWithoutMemberInput | usersUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<usersCreateWithoutMemberInput, usersUncheckedCreateWithoutMemberInput> | usersCreateWithoutMemberInput[] | usersUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: usersCreateOrConnectWithoutMemberInput | usersCreateOrConnectWithoutMemberInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutMemberInput | usersUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: usersCreateManyMemberInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutMemberInput | usersUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: usersUpdateManyWithWhereWithoutMemberInput | usersUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type warehouseCreateNestedOneWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput = {
    create?: XOR<warehouseCreateWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput, warehouseUncheckedCreateWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput>
    connectOrCreate?: warehouseCreateOrConnectWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput
    connect?: warehouseWhereUniqueInput
  }

  export type warehouseCreateNestedOneWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput = {
    create?: XOR<warehouseCreateWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput, warehouseUncheckedCreateWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput>
    connectOrCreate?: warehouseCreateOrConnectWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput
    connect?: warehouseWhereUniqueInput
  }

  export type order_barang_detailCreateNestedManyWithoutOrder_barangInput = {
    create?: XOR<order_barang_detailCreateWithoutOrder_barangInput, order_barang_detailUncheckedCreateWithoutOrder_barangInput> | order_barang_detailCreateWithoutOrder_barangInput[] | order_barang_detailUncheckedCreateWithoutOrder_barangInput[]
    connectOrCreate?: order_barang_detailCreateOrConnectWithoutOrder_barangInput | order_barang_detailCreateOrConnectWithoutOrder_barangInput[]
    createMany?: order_barang_detailCreateManyOrder_barangInputEnvelope
    connect?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
  }

  export type order_barang_detailUncheckedCreateNestedManyWithoutOrder_barangInput = {
    create?: XOR<order_barang_detailCreateWithoutOrder_barangInput, order_barang_detailUncheckedCreateWithoutOrder_barangInput> | order_barang_detailCreateWithoutOrder_barangInput[] | order_barang_detailUncheckedCreateWithoutOrder_barangInput[]
    connectOrCreate?: order_barang_detailCreateOrConnectWithoutOrder_barangInput | order_barang_detailCreateOrConnectWithoutOrder_barangInput[]
    createMany?: order_barang_detailCreateManyOrder_barangInputEnvelope
    connect?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
  }

  export type warehouseUpdateOneRequiredWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseNestedInput = {
    create?: XOR<warehouseCreateWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput, warehouseUncheckedCreateWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput>
    connectOrCreate?: warehouseCreateOrConnectWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput
    upsert?: warehouseUpsertWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput
    connect?: warehouseWhereUniqueInput
    update?: XOR<XOR<warehouseUpdateToOneWithWhereWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput, warehouseUpdateWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput>, warehouseUncheckedUpdateWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput>
  }

  export type warehouseUpdateOneRequiredWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseNestedInput = {
    create?: XOR<warehouseCreateWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput, warehouseUncheckedCreateWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput>
    connectOrCreate?: warehouseCreateOrConnectWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput
    upsert?: warehouseUpsertWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput
    connect?: warehouseWhereUniqueInput
    update?: XOR<XOR<warehouseUpdateToOneWithWhereWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput, warehouseUpdateWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput>, warehouseUncheckedUpdateWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput>
  }

  export type order_barang_detailUpdateManyWithoutOrder_barangNestedInput = {
    create?: XOR<order_barang_detailCreateWithoutOrder_barangInput, order_barang_detailUncheckedCreateWithoutOrder_barangInput> | order_barang_detailCreateWithoutOrder_barangInput[] | order_barang_detailUncheckedCreateWithoutOrder_barangInput[]
    connectOrCreate?: order_barang_detailCreateOrConnectWithoutOrder_barangInput | order_barang_detailCreateOrConnectWithoutOrder_barangInput[]
    upsert?: order_barang_detailUpsertWithWhereUniqueWithoutOrder_barangInput | order_barang_detailUpsertWithWhereUniqueWithoutOrder_barangInput[]
    createMany?: order_barang_detailCreateManyOrder_barangInputEnvelope
    set?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
    disconnect?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
    delete?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
    connect?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
    update?: order_barang_detailUpdateWithWhereUniqueWithoutOrder_barangInput | order_barang_detailUpdateWithWhereUniqueWithoutOrder_barangInput[]
    updateMany?: order_barang_detailUpdateManyWithWhereWithoutOrder_barangInput | order_barang_detailUpdateManyWithWhereWithoutOrder_barangInput[]
    deleteMany?: order_barang_detailScalarWhereInput | order_barang_detailScalarWhereInput[]
  }

  export type order_barang_detailUncheckedUpdateManyWithoutOrder_barangNestedInput = {
    create?: XOR<order_barang_detailCreateWithoutOrder_barangInput, order_barang_detailUncheckedCreateWithoutOrder_barangInput> | order_barang_detailCreateWithoutOrder_barangInput[] | order_barang_detailUncheckedCreateWithoutOrder_barangInput[]
    connectOrCreate?: order_barang_detailCreateOrConnectWithoutOrder_barangInput | order_barang_detailCreateOrConnectWithoutOrder_barangInput[]
    upsert?: order_barang_detailUpsertWithWhereUniqueWithoutOrder_barangInput | order_barang_detailUpsertWithWhereUniqueWithoutOrder_barangInput[]
    createMany?: order_barang_detailCreateManyOrder_barangInputEnvelope
    set?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
    disconnect?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
    delete?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
    connect?: order_barang_detailWhereUniqueInput | order_barang_detailWhereUniqueInput[]
    update?: order_barang_detailUpdateWithWhereUniqueWithoutOrder_barangInput | order_barang_detailUpdateWithWhereUniqueWithoutOrder_barangInput[]
    updateMany?: order_barang_detailUpdateManyWithWhereWithoutOrder_barangInput | order_barang_detailUpdateManyWithWhereWithoutOrder_barangInput[]
    deleteMany?: order_barang_detailScalarWhereInput | order_barang_detailScalarWhereInput[]
  }

  export type barangCreateNestedOneWithoutOrder_barang_detailInput = {
    create?: XOR<barangCreateWithoutOrder_barang_detailInput, barangUncheckedCreateWithoutOrder_barang_detailInput>
    connectOrCreate?: barangCreateOrConnectWithoutOrder_barang_detailInput
    connect?: barangWhereUniqueInput
  }

  export type order_barangCreateNestedOneWithoutOrder_barang_detailInput = {
    create?: XOR<order_barangCreateWithoutOrder_barang_detailInput, order_barangUncheckedCreateWithoutOrder_barang_detailInput>
    connectOrCreate?: order_barangCreateOrConnectWithoutOrder_barang_detailInput
    connect?: order_barangWhereUniqueInput
  }

  export type barangUpdateOneRequiredWithoutOrder_barang_detailNestedInput = {
    create?: XOR<barangCreateWithoutOrder_barang_detailInput, barangUncheckedCreateWithoutOrder_barang_detailInput>
    connectOrCreate?: barangCreateOrConnectWithoutOrder_barang_detailInput
    upsert?: barangUpsertWithoutOrder_barang_detailInput
    connect?: barangWhereUniqueInput
    update?: XOR<XOR<barangUpdateToOneWithWhereWithoutOrder_barang_detailInput, barangUpdateWithoutOrder_barang_detailInput>, barangUncheckedUpdateWithoutOrder_barang_detailInput>
  }

  export type order_barangUpdateOneRequiredWithoutOrder_barang_detailNestedInput = {
    create?: XOR<order_barangCreateWithoutOrder_barang_detailInput, order_barangUncheckedCreateWithoutOrder_barang_detailInput>
    connectOrCreate?: order_barangCreateOrConnectWithoutOrder_barang_detailInput
    upsert?: order_barangUpsertWithoutOrder_barang_detailInput
    connect?: order_barangWhereUniqueInput
    update?: XOR<XOR<order_barangUpdateToOneWithWhereWithoutOrder_barang_detailInput, order_barangUpdateWithoutOrder_barang_detailInput>, order_barangUncheckedUpdateWithoutOrder_barang_detailInput>
  }

  export type employeeCreateNestedManyWithoutStatusInput = {
    create?: XOR<employeeCreateWithoutStatusInput, employeeUncheckedCreateWithoutStatusInput> | employeeCreateWithoutStatusInput[] | employeeUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutStatusInput | employeeCreateOrConnectWithoutStatusInput[]
    createMany?: employeeCreateManyStatusInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type usersCreateNestedManyWithoutStatusInput = {
    create?: XOR<usersCreateWithoutStatusInput, usersUncheckedCreateWithoutStatusInput> | usersCreateWithoutStatusInput[] | usersUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: usersCreateOrConnectWithoutStatusInput | usersCreateOrConnectWithoutStatusInput[]
    createMany?: usersCreateManyStatusInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type employeeUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<employeeCreateWithoutStatusInput, employeeUncheckedCreateWithoutStatusInput> | employeeCreateWithoutStatusInput[] | employeeUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutStatusInput | employeeCreateOrConnectWithoutStatusInput[]
    createMany?: employeeCreateManyStatusInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<usersCreateWithoutStatusInput, usersUncheckedCreateWithoutStatusInput> | usersCreateWithoutStatusInput[] | usersUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: usersCreateOrConnectWithoutStatusInput | usersCreateOrConnectWithoutStatusInput[]
    createMany?: usersCreateManyStatusInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type employeeUpdateManyWithoutStatusNestedInput = {
    create?: XOR<employeeCreateWithoutStatusInput, employeeUncheckedCreateWithoutStatusInput> | employeeCreateWithoutStatusInput[] | employeeUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutStatusInput | employeeCreateOrConnectWithoutStatusInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutStatusInput | employeeUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: employeeCreateManyStatusInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutStatusInput | employeeUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutStatusInput | employeeUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type usersUpdateManyWithoutStatusNestedInput = {
    create?: XOR<usersCreateWithoutStatusInput, usersUncheckedCreateWithoutStatusInput> | usersCreateWithoutStatusInput[] | usersUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: usersCreateOrConnectWithoutStatusInput | usersCreateOrConnectWithoutStatusInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutStatusInput | usersUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: usersCreateManyStatusInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutStatusInput | usersUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: usersUpdateManyWithWhereWithoutStatusInput | usersUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type employeeUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<employeeCreateWithoutStatusInput, employeeUncheckedCreateWithoutStatusInput> | employeeCreateWithoutStatusInput[] | employeeUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutStatusInput | employeeCreateOrConnectWithoutStatusInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutStatusInput | employeeUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: employeeCreateManyStatusInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutStatusInput | employeeUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutStatusInput | employeeUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<usersCreateWithoutStatusInput, usersUncheckedCreateWithoutStatusInput> | usersCreateWithoutStatusInput[] | usersUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: usersCreateOrConnectWithoutStatusInput | usersCreateOrConnectWithoutStatusInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutStatusInput | usersUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: usersCreateManyStatusInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutStatusInput | usersUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: usersUpdateManyWithWhereWithoutStatusInput | usersUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type mekanikCreateNestedOneWithoutTransaksiInput = {
    create?: XOR<mekanikCreateWithoutTransaksiInput, mekanikUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: mekanikCreateOrConnectWithoutTransaksiInput
    connect?: mekanikWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutTransaksiInput = {
    create?: XOR<usersCreateWithoutTransaksiInput, usersUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: usersCreateOrConnectWithoutTransaksiInput
    connect?: usersWhereUniqueInput
  }

  export type warehouseCreateNestedOneWithoutTransaksiInput = {
    create?: XOR<warehouseCreateWithoutTransaksiInput, warehouseUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: warehouseCreateOrConnectWithoutTransaksiInput
    connect?: warehouseWhereUniqueInput
  }

  export type transaksi_detailCreateNestedManyWithoutTransaksiInput = {
    create?: XOR<transaksi_detailCreateWithoutTransaksiInput, transaksi_detailUncheckedCreateWithoutTransaksiInput> | transaksi_detailCreateWithoutTransaksiInput[] | transaksi_detailUncheckedCreateWithoutTransaksiInput[]
    connectOrCreate?: transaksi_detailCreateOrConnectWithoutTransaksiInput | transaksi_detailCreateOrConnectWithoutTransaksiInput[]
    createMany?: transaksi_detailCreateManyTransaksiInputEnvelope
    connect?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
  }

  export type transaksi_detailUncheckedCreateNestedManyWithoutTransaksiInput = {
    create?: XOR<transaksi_detailCreateWithoutTransaksiInput, transaksi_detailUncheckedCreateWithoutTransaksiInput> | transaksi_detailCreateWithoutTransaksiInput[] | transaksi_detailUncheckedCreateWithoutTransaksiInput[]
    connectOrCreate?: transaksi_detailCreateOrConnectWithoutTransaksiInput | transaksi_detailCreateOrConnectWithoutTransaksiInput[]
    createMany?: transaksi_detailCreateManyTransaksiInputEnvelope
    connect?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
  }

  export type mekanikUpdateOneRequiredWithoutTransaksiNestedInput = {
    create?: XOR<mekanikCreateWithoutTransaksiInput, mekanikUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: mekanikCreateOrConnectWithoutTransaksiInput
    upsert?: mekanikUpsertWithoutTransaksiInput
    connect?: mekanikWhereUniqueInput
    update?: XOR<XOR<mekanikUpdateToOneWithWhereWithoutTransaksiInput, mekanikUpdateWithoutTransaksiInput>, mekanikUncheckedUpdateWithoutTransaksiInput>
  }

  export type usersUpdateOneRequiredWithoutTransaksiNestedInput = {
    create?: XOR<usersCreateWithoutTransaksiInput, usersUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: usersCreateOrConnectWithoutTransaksiInput
    upsert?: usersUpsertWithoutTransaksiInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTransaksiInput, usersUpdateWithoutTransaksiInput>, usersUncheckedUpdateWithoutTransaksiInput>
  }

  export type warehouseUpdateOneRequiredWithoutTransaksiNestedInput = {
    create?: XOR<warehouseCreateWithoutTransaksiInput, warehouseUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: warehouseCreateOrConnectWithoutTransaksiInput
    upsert?: warehouseUpsertWithoutTransaksiInput
    connect?: warehouseWhereUniqueInput
    update?: XOR<XOR<warehouseUpdateToOneWithWhereWithoutTransaksiInput, warehouseUpdateWithoutTransaksiInput>, warehouseUncheckedUpdateWithoutTransaksiInput>
  }

  export type transaksi_detailUpdateManyWithoutTransaksiNestedInput = {
    create?: XOR<transaksi_detailCreateWithoutTransaksiInput, transaksi_detailUncheckedCreateWithoutTransaksiInput> | transaksi_detailCreateWithoutTransaksiInput[] | transaksi_detailUncheckedCreateWithoutTransaksiInput[]
    connectOrCreate?: transaksi_detailCreateOrConnectWithoutTransaksiInput | transaksi_detailCreateOrConnectWithoutTransaksiInput[]
    upsert?: transaksi_detailUpsertWithWhereUniqueWithoutTransaksiInput | transaksi_detailUpsertWithWhereUniqueWithoutTransaksiInput[]
    createMany?: transaksi_detailCreateManyTransaksiInputEnvelope
    set?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
    disconnect?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
    delete?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
    connect?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
    update?: transaksi_detailUpdateWithWhereUniqueWithoutTransaksiInput | transaksi_detailUpdateWithWhereUniqueWithoutTransaksiInput[]
    updateMany?: transaksi_detailUpdateManyWithWhereWithoutTransaksiInput | transaksi_detailUpdateManyWithWhereWithoutTransaksiInput[]
    deleteMany?: transaksi_detailScalarWhereInput | transaksi_detailScalarWhereInput[]
  }

  export type transaksi_detailUncheckedUpdateManyWithoutTransaksiNestedInput = {
    create?: XOR<transaksi_detailCreateWithoutTransaksiInput, transaksi_detailUncheckedCreateWithoutTransaksiInput> | transaksi_detailCreateWithoutTransaksiInput[] | transaksi_detailUncheckedCreateWithoutTransaksiInput[]
    connectOrCreate?: transaksi_detailCreateOrConnectWithoutTransaksiInput | transaksi_detailCreateOrConnectWithoutTransaksiInput[]
    upsert?: transaksi_detailUpsertWithWhereUniqueWithoutTransaksiInput | transaksi_detailUpsertWithWhereUniqueWithoutTransaksiInput[]
    createMany?: transaksi_detailCreateManyTransaksiInputEnvelope
    set?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
    disconnect?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
    delete?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
    connect?: transaksi_detailWhereUniqueInput | transaksi_detailWhereUniqueInput[]
    update?: transaksi_detailUpdateWithWhereUniqueWithoutTransaksiInput | transaksi_detailUpdateWithWhereUniqueWithoutTransaksiInput[]
    updateMany?: transaksi_detailUpdateManyWithWhereWithoutTransaksiInput | transaksi_detailUpdateManyWithWhereWithoutTransaksiInput[]
    deleteMany?: transaksi_detailScalarWhereInput | transaksi_detailScalarWhereInput[]
  }

  export type barangCreateNestedOneWithoutTransaksi_detailInput = {
    create?: XOR<barangCreateWithoutTransaksi_detailInput, barangUncheckedCreateWithoutTransaksi_detailInput>
    connectOrCreate?: barangCreateOrConnectWithoutTransaksi_detailInput
    connect?: barangWhereUniqueInput
  }

  export type transaksiCreateNestedOneWithoutTransaksi_detailInput = {
    create?: XOR<transaksiCreateWithoutTransaksi_detailInput, transaksiUncheckedCreateWithoutTransaksi_detailInput>
    connectOrCreate?: transaksiCreateOrConnectWithoutTransaksi_detailInput
    connect?: transaksiWhereUniqueInput
  }

  export type barangUpdateOneRequiredWithoutTransaksi_detailNestedInput = {
    create?: XOR<barangCreateWithoutTransaksi_detailInput, barangUncheckedCreateWithoutTransaksi_detailInput>
    connectOrCreate?: barangCreateOrConnectWithoutTransaksi_detailInput
    upsert?: barangUpsertWithoutTransaksi_detailInput
    connect?: barangWhereUniqueInput
    update?: XOR<XOR<barangUpdateToOneWithWhereWithoutTransaksi_detailInput, barangUpdateWithoutTransaksi_detailInput>, barangUncheckedUpdateWithoutTransaksi_detailInput>
  }

  export type transaksiUpdateOneRequiredWithoutTransaksi_detailNestedInput = {
    create?: XOR<transaksiCreateWithoutTransaksi_detailInput, transaksiUncheckedCreateWithoutTransaksi_detailInput>
    connectOrCreate?: transaksiCreateOrConnectWithoutTransaksi_detailInput
    upsert?: transaksiUpsertWithoutTransaksi_detailInput
    connect?: transaksiWhereUniqueInput
    update?: XOR<XOR<transaksiUpdateToOneWithWhereWithoutTransaksi_detailInput, transaksiUpdateWithoutTransaksi_detailInput>, transaksiUncheckedUpdateWithoutTransaksi_detailInput>
  }

  export type transaksiCreateNestedManyWithoutUsersInput = {
    create?: XOR<transaksiCreateWithoutUsersInput, transaksiUncheckedCreateWithoutUsersInput> | transaksiCreateWithoutUsersInput[] | transaksiUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutUsersInput | transaksiCreateOrConnectWithoutUsersInput[]
    createMany?: transaksiCreateManyUsersInputEnvelope
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
  }

  export type memberCreateNestedOneWithoutUsersInput = {
    create?: XOR<memberCreateWithoutUsersInput, memberUncheckedCreateWithoutUsersInput>
    connectOrCreate?: memberCreateOrConnectWithoutUsersInput
    connect?: memberWhereUniqueInput
  }

  export type statusCreateNestedOneWithoutUsersInput = {
    create?: XOR<statusCreateWithoutUsersInput, statusUncheckedCreateWithoutUsersInput>
    connectOrCreate?: statusCreateOrConnectWithoutUsersInput
    connect?: statusWhereUniqueInput
  }

  export type vehicle_merkCreateNestedOneWithoutUsersInput = {
    create?: XOR<vehicle_merkCreateWithoutUsersInput, vehicle_merkUncheckedCreateWithoutUsersInput>
    connectOrCreate?: vehicle_merkCreateOrConnectWithoutUsersInput
    connect?: vehicle_merkWhereUniqueInput
  }

  export type vehicle_yearCreateNestedOneWithoutUsersInput = {
    create?: XOR<vehicle_yearCreateWithoutUsersInput, vehicle_yearUncheckedCreateWithoutUsersInput>
    connectOrCreate?: vehicle_yearCreateOrConnectWithoutUsersInput
    connect?: vehicle_yearWhereUniqueInput
  }

  export type vehicle_typeCreateNestedOneWithoutUsersInput = {
    create?: XOR<vehicle_typeCreateWithoutUsersInput, vehicle_typeUncheckedCreateWithoutUsersInput>
    connectOrCreate?: vehicle_typeCreateOrConnectWithoutUsersInput
    connect?: vehicle_typeWhereUniqueInput
  }

  export type transaksiUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<transaksiCreateWithoutUsersInput, transaksiUncheckedCreateWithoutUsersInput> | transaksiCreateWithoutUsersInput[] | transaksiUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutUsersInput | transaksiCreateOrConnectWithoutUsersInput[]
    createMany?: transaksiCreateManyUsersInputEnvelope
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
  }

  export type transaksiUpdateManyWithoutUsersNestedInput = {
    create?: XOR<transaksiCreateWithoutUsersInput, transaksiUncheckedCreateWithoutUsersInput> | transaksiCreateWithoutUsersInput[] | transaksiUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutUsersInput | transaksiCreateOrConnectWithoutUsersInput[]
    upsert?: transaksiUpsertWithWhereUniqueWithoutUsersInput | transaksiUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: transaksiCreateManyUsersInputEnvelope
    set?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    disconnect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    delete?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    update?: transaksiUpdateWithWhereUniqueWithoutUsersInput | transaksiUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: transaksiUpdateManyWithWhereWithoutUsersInput | transaksiUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: transaksiScalarWhereInput | transaksiScalarWhereInput[]
  }

  export type memberUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<memberCreateWithoutUsersInput, memberUncheckedCreateWithoutUsersInput>
    connectOrCreate?: memberCreateOrConnectWithoutUsersInput
    upsert?: memberUpsertWithoutUsersInput
    connect?: memberWhereUniqueInput
    update?: XOR<XOR<memberUpdateToOneWithWhereWithoutUsersInput, memberUpdateWithoutUsersInput>, memberUncheckedUpdateWithoutUsersInput>
  }

  export type statusUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<statusCreateWithoutUsersInput, statusUncheckedCreateWithoutUsersInput>
    connectOrCreate?: statusCreateOrConnectWithoutUsersInput
    upsert?: statusUpsertWithoutUsersInput
    connect?: statusWhereUniqueInput
    update?: XOR<XOR<statusUpdateToOneWithWhereWithoutUsersInput, statusUpdateWithoutUsersInput>, statusUncheckedUpdateWithoutUsersInput>
  }

  export type vehicle_merkUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<vehicle_merkCreateWithoutUsersInput, vehicle_merkUncheckedCreateWithoutUsersInput>
    connectOrCreate?: vehicle_merkCreateOrConnectWithoutUsersInput
    upsert?: vehicle_merkUpsertWithoutUsersInput
    connect?: vehicle_merkWhereUniqueInput
    update?: XOR<XOR<vehicle_merkUpdateToOneWithWhereWithoutUsersInput, vehicle_merkUpdateWithoutUsersInput>, vehicle_merkUncheckedUpdateWithoutUsersInput>
  }

  export type vehicle_yearUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<vehicle_yearCreateWithoutUsersInput, vehicle_yearUncheckedCreateWithoutUsersInput>
    connectOrCreate?: vehicle_yearCreateOrConnectWithoutUsersInput
    upsert?: vehicle_yearUpsertWithoutUsersInput
    connect?: vehicle_yearWhereUniqueInput
    update?: XOR<XOR<vehicle_yearUpdateToOneWithWhereWithoutUsersInput, vehicle_yearUpdateWithoutUsersInput>, vehicle_yearUncheckedUpdateWithoutUsersInput>
  }

  export type vehicle_typeUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<vehicle_typeCreateWithoutUsersInput, vehicle_typeUncheckedCreateWithoutUsersInput>
    connectOrCreate?: vehicle_typeCreateOrConnectWithoutUsersInput
    upsert?: vehicle_typeUpsertWithoutUsersInput
    connect?: vehicle_typeWhereUniqueInput
    update?: XOR<XOR<vehicle_typeUpdateToOneWithWhereWithoutUsersInput, vehicle_typeUpdateWithoutUsersInput>, vehicle_typeUncheckedUpdateWithoutUsersInput>
  }

  export type transaksiUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<transaksiCreateWithoutUsersInput, transaksiUncheckedCreateWithoutUsersInput> | transaksiCreateWithoutUsersInput[] | transaksiUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutUsersInput | transaksiCreateOrConnectWithoutUsersInput[]
    upsert?: transaksiUpsertWithWhereUniqueWithoutUsersInput | transaksiUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: transaksiCreateManyUsersInputEnvelope
    set?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    disconnect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    delete?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    update?: transaksiUpdateWithWhereUniqueWithoutUsersInput | transaksiUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: transaksiUpdateManyWithWhereWithoutUsersInput | transaksiUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: transaksiScalarWhereInput | transaksiScalarWhereInput[]
  }

  export type barangCreateNestedManyWithoutVehicle_categoryInput = {
    create?: XOR<barangCreateWithoutVehicle_categoryInput, barangUncheckedCreateWithoutVehicle_categoryInput> | barangCreateWithoutVehicle_categoryInput[] | barangUncheckedCreateWithoutVehicle_categoryInput[]
    connectOrCreate?: barangCreateOrConnectWithoutVehicle_categoryInput | barangCreateOrConnectWithoutVehicle_categoryInput[]
    createMany?: barangCreateManyVehicle_categoryInputEnvelope
    connect?: barangWhereUniqueInput | barangWhereUniqueInput[]
  }

  export type vehicle_typeCreateNestedManyWithoutVehicle_categoryInput = {
    create?: XOR<vehicle_typeCreateWithoutVehicle_categoryInput, vehicle_typeUncheckedCreateWithoutVehicle_categoryInput> | vehicle_typeCreateWithoutVehicle_categoryInput[] | vehicle_typeUncheckedCreateWithoutVehicle_categoryInput[]
    connectOrCreate?: vehicle_typeCreateOrConnectWithoutVehicle_categoryInput | vehicle_typeCreateOrConnectWithoutVehicle_categoryInput[]
    createMany?: vehicle_typeCreateManyVehicle_categoryInputEnvelope
    connect?: vehicle_typeWhereUniqueInput | vehicle_typeWhereUniqueInput[]
  }

  export type barangUncheckedCreateNestedManyWithoutVehicle_categoryInput = {
    create?: XOR<barangCreateWithoutVehicle_categoryInput, barangUncheckedCreateWithoutVehicle_categoryInput> | barangCreateWithoutVehicle_categoryInput[] | barangUncheckedCreateWithoutVehicle_categoryInput[]
    connectOrCreate?: barangCreateOrConnectWithoutVehicle_categoryInput | barangCreateOrConnectWithoutVehicle_categoryInput[]
    createMany?: barangCreateManyVehicle_categoryInputEnvelope
    connect?: barangWhereUniqueInput | barangWhereUniqueInput[]
  }

  export type vehicle_typeUncheckedCreateNestedManyWithoutVehicle_categoryInput = {
    create?: XOR<vehicle_typeCreateWithoutVehicle_categoryInput, vehicle_typeUncheckedCreateWithoutVehicle_categoryInput> | vehicle_typeCreateWithoutVehicle_categoryInput[] | vehicle_typeUncheckedCreateWithoutVehicle_categoryInput[]
    connectOrCreate?: vehicle_typeCreateOrConnectWithoutVehicle_categoryInput | vehicle_typeCreateOrConnectWithoutVehicle_categoryInput[]
    createMany?: vehicle_typeCreateManyVehicle_categoryInputEnvelope
    connect?: vehicle_typeWhereUniqueInput | vehicle_typeWhereUniqueInput[]
  }

  export type barangUpdateManyWithoutVehicle_categoryNestedInput = {
    create?: XOR<barangCreateWithoutVehicle_categoryInput, barangUncheckedCreateWithoutVehicle_categoryInput> | barangCreateWithoutVehicle_categoryInput[] | barangUncheckedCreateWithoutVehicle_categoryInput[]
    connectOrCreate?: barangCreateOrConnectWithoutVehicle_categoryInput | barangCreateOrConnectWithoutVehicle_categoryInput[]
    upsert?: barangUpsertWithWhereUniqueWithoutVehicle_categoryInput | barangUpsertWithWhereUniqueWithoutVehicle_categoryInput[]
    createMany?: barangCreateManyVehicle_categoryInputEnvelope
    set?: barangWhereUniqueInput | barangWhereUniqueInput[]
    disconnect?: barangWhereUniqueInput | barangWhereUniqueInput[]
    delete?: barangWhereUniqueInput | barangWhereUniqueInput[]
    connect?: barangWhereUniqueInput | barangWhereUniqueInput[]
    update?: barangUpdateWithWhereUniqueWithoutVehicle_categoryInput | barangUpdateWithWhereUniqueWithoutVehicle_categoryInput[]
    updateMany?: barangUpdateManyWithWhereWithoutVehicle_categoryInput | barangUpdateManyWithWhereWithoutVehicle_categoryInput[]
    deleteMany?: barangScalarWhereInput | barangScalarWhereInput[]
  }

  export type vehicle_typeUpdateManyWithoutVehicle_categoryNestedInput = {
    create?: XOR<vehicle_typeCreateWithoutVehicle_categoryInput, vehicle_typeUncheckedCreateWithoutVehicle_categoryInput> | vehicle_typeCreateWithoutVehicle_categoryInput[] | vehicle_typeUncheckedCreateWithoutVehicle_categoryInput[]
    connectOrCreate?: vehicle_typeCreateOrConnectWithoutVehicle_categoryInput | vehicle_typeCreateOrConnectWithoutVehicle_categoryInput[]
    upsert?: vehicle_typeUpsertWithWhereUniqueWithoutVehicle_categoryInput | vehicle_typeUpsertWithWhereUniqueWithoutVehicle_categoryInput[]
    createMany?: vehicle_typeCreateManyVehicle_categoryInputEnvelope
    set?: vehicle_typeWhereUniqueInput | vehicle_typeWhereUniqueInput[]
    disconnect?: vehicle_typeWhereUniqueInput | vehicle_typeWhereUniqueInput[]
    delete?: vehicle_typeWhereUniqueInput | vehicle_typeWhereUniqueInput[]
    connect?: vehicle_typeWhereUniqueInput | vehicle_typeWhereUniqueInput[]
    update?: vehicle_typeUpdateWithWhereUniqueWithoutVehicle_categoryInput | vehicle_typeUpdateWithWhereUniqueWithoutVehicle_categoryInput[]
    updateMany?: vehicle_typeUpdateManyWithWhereWithoutVehicle_categoryInput | vehicle_typeUpdateManyWithWhereWithoutVehicle_categoryInput[]
    deleteMany?: vehicle_typeScalarWhereInput | vehicle_typeScalarWhereInput[]
  }

  export type barangUncheckedUpdateManyWithoutVehicle_categoryNestedInput = {
    create?: XOR<barangCreateWithoutVehicle_categoryInput, barangUncheckedCreateWithoutVehicle_categoryInput> | barangCreateWithoutVehicle_categoryInput[] | barangUncheckedCreateWithoutVehicle_categoryInput[]
    connectOrCreate?: barangCreateOrConnectWithoutVehicle_categoryInput | barangCreateOrConnectWithoutVehicle_categoryInput[]
    upsert?: barangUpsertWithWhereUniqueWithoutVehicle_categoryInput | barangUpsertWithWhereUniqueWithoutVehicle_categoryInput[]
    createMany?: barangCreateManyVehicle_categoryInputEnvelope
    set?: barangWhereUniqueInput | barangWhereUniqueInput[]
    disconnect?: barangWhereUniqueInput | barangWhereUniqueInput[]
    delete?: barangWhereUniqueInput | barangWhereUniqueInput[]
    connect?: barangWhereUniqueInput | barangWhereUniqueInput[]
    update?: barangUpdateWithWhereUniqueWithoutVehicle_categoryInput | barangUpdateWithWhereUniqueWithoutVehicle_categoryInput[]
    updateMany?: barangUpdateManyWithWhereWithoutVehicle_categoryInput | barangUpdateManyWithWhereWithoutVehicle_categoryInput[]
    deleteMany?: barangScalarWhereInput | barangScalarWhereInput[]
  }

  export type vehicle_typeUncheckedUpdateManyWithoutVehicle_categoryNestedInput = {
    create?: XOR<vehicle_typeCreateWithoutVehicle_categoryInput, vehicle_typeUncheckedCreateWithoutVehicle_categoryInput> | vehicle_typeCreateWithoutVehicle_categoryInput[] | vehicle_typeUncheckedCreateWithoutVehicle_categoryInput[]
    connectOrCreate?: vehicle_typeCreateOrConnectWithoutVehicle_categoryInput | vehicle_typeCreateOrConnectWithoutVehicle_categoryInput[]
    upsert?: vehicle_typeUpsertWithWhereUniqueWithoutVehicle_categoryInput | vehicle_typeUpsertWithWhereUniqueWithoutVehicle_categoryInput[]
    createMany?: vehicle_typeCreateManyVehicle_categoryInputEnvelope
    set?: vehicle_typeWhereUniqueInput | vehicle_typeWhereUniqueInput[]
    disconnect?: vehicle_typeWhereUniqueInput | vehicle_typeWhereUniqueInput[]
    delete?: vehicle_typeWhereUniqueInput | vehicle_typeWhereUniqueInput[]
    connect?: vehicle_typeWhereUniqueInput | vehicle_typeWhereUniqueInput[]
    update?: vehicle_typeUpdateWithWhereUniqueWithoutVehicle_categoryInput | vehicle_typeUpdateWithWhereUniqueWithoutVehicle_categoryInput[]
    updateMany?: vehicle_typeUpdateManyWithWhereWithoutVehicle_categoryInput | vehicle_typeUpdateManyWithWhereWithoutVehicle_categoryInput[]
    deleteMany?: vehicle_typeScalarWhereInput | vehicle_typeScalarWhereInput[]
  }

  export type usersCreateNestedManyWithoutVehicle_merkInput = {
    create?: XOR<usersCreateWithoutVehicle_merkInput, usersUncheckedCreateWithoutVehicle_merkInput> | usersCreateWithoutVehicle_merkInput[] | usersUncheckedCreateWithoutVehicle_merkInput[]
    connectOrCreate?: usersCreateOrConnectWithoutVehicle_merkInput | usersCreateOrConnectWithoutVehicle_merkInput[]
    createMany?: usersCreateManyVehicle_merkInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutVehicle_merkInput = {
    create?: XOR<usersCreateWithoutVehicle_merkInput, usersUncheckedCreateWithoutVehicle_merkInput> | usersCreateWithoutVehicle_merkInput[] | usersUncheckedCreateWithoutVehicle_merkInput[]
    connectOrCreate?: usersCreateOrConnectWithoutVehicle_merkInput | usersCreateOrConnectWithoutVehicle_merkInput[]
    createMany?: usersCreateManyVehicle_merkInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUpdateManyWithoutVehicle_merkNestedInput = {
    create?: XOR<usersCreateWithoutVehicle_merkInput, usersUncheckedCreateWithoutVehicle_merkInput> | usersCreateWithoutVehicle_merkInput[] | usersUncheckedCreateWithoutVehicle_merkInput[]
    connectOrCreate?: usersCreateOrConnectWithoutVehicle_merkInput | usersCreateOrConnectWithoutVehicle_merkInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutVehicle_merkInput | usersUpsertWithWhereUniqueWithoutVehicle_merkInput[]
    createMany?: usersCreateManyVehicle_merkInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutVehicle_merkInput | usersUpdateWithWhereUniqueWithoutVehicle_merkInput[]
    updateMany?: usersUpdateManyWithWhereWithoutVehicle_merkInput | usersUpdateManyWithWhereWithoutVehicle_merkInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutVehicle_merkNestedInput = {
    create?: XOR<usersCreateWithoutVehicle_merkInput, usersUncheckedCreateWithoutVehicle_merkInput> | usersCreateWithoutVehicle_merkInput[] | usersUncheckedCreateWithoutVehicle_merkInput[]
    connectOrCreate?: usersCreateOrConnectWithoutVehicle_merkInput | usersCreateOrConnectWithoutVehicle_merkInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutVehicle_merkInput | usersUpsertWithWhereUniqueWithoutVehicle_merkInput[]
    createMany?: usersCreateManyVehicle_merkInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutVehicle_merkInput | usersUpdateWithWhereUniqueWithoutVehicle_merkInput[]
    updateMany?: usersUpdateManyWithWhereWithoutVehicle_merkInput | usersUpdateManyWithWhereWithoutVehicle_merkInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersCreateNestedManyWithoutVehicle_typeInput = {
    create?: XOR<usersCreateWithoutVehicle_typeInput, usersUncheckedCreateWithoutVehicle_typeInput> | usersCreateWithoutVehicle_typeInput[] | usersUncheckedCreateWithoutVehicle_typeInput[]
    connectOrCreate?: usersCreateOrConnectWithoutVehicle_typeInput | usersCreateOrConnectWithoutVehicle_typeInput[]
    createMany?: usersCreateManyVehicle_typeInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type vehicle_categoryCreateNestedOneWithoutVehicle_typeInput = {
    create?: XOR<vehicle_categoryCreateWithoutVehicle_typeInput, vehicle_categoryUncheckedCreateWithoutVehicle_typeInput>
    connectOrCreate?: vehicle_categoryCreateOrConnectWithoutVehicle_typeInput
    connect?: vehicle_categoryWhereUniqueInput
  }

  export type usersUncheckedCreateNestedManyWithoutVehicle_typeInput = {
    create?: XOR<usersCreateWithoutVehicle_typeInput, usersUncheckedCreateWithoutVehicle_typeInput> | usersCreateWithoutVehicle_typeInput[] | usersUncheckedCreateWithoutVehicle_typeInput[]
    connectOrCreate?: usersCreateOrConnectWithoutVehicle_typeInput | usersCreateOrConnectWithoutVehicle_typeInput[]
    createMany?: usersCreateManyVehicle_typeInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUpdateManyWithoutVehicle_typeNestedInput = {
    create?: XOR<usersCreateWithoutVehicle_typeInput, usersUncheckedCreateWithoutVehicle_typeInput> | usersCreateWithoutVehicle_typeInput[] | usersUncheckedCreateWithoutVehicle_typeInput[]
    connectOrCreate?: usersCreateOrConnectWithoutVehicle_typeInput | usersCreateOrConnectWithoutVehicle_typeInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutVehicle_typeInput | usersUpsertWithWhereUniqueWithoutVehicle_typeInput[]
    createMany?: usersCreateManyVehicle_typeInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutVehicle_typeInput | usersUpdateWithWhereUniqueWithoutVehicle_typeInput[]
    updateMany?: usersUpdateManyWithWhereWithoutVehicle_typeInput | usersUpdateManyWithWhereWithoutVehicle_typeInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type vehicle_categoryUpdateOneRequiredWithoutVehicle_typeNestedInput = {
    create?: XOR<vehicle_categoryCreateWithoutVehicle_typeInput, vehicle_categoryUncheckedCreateWithoutVehicle_typeInput>
    connectOrCreate?: vehicle_categoryCreateOrConnectWithoutVehicle_typeInput
    upsert?: vehicle_categoryUpsertWithoutVehicle_typeInput
    connect?: vehicle_categoryWhereUniqueInput
    update?: XOR<XOR<vehicle_categoryUpdateToOneWithWhereWithoutVehicle_typeInput, vehicle_categoryUpdateWithoutVehicle_typeInput>, vehicle_categoryUncheckedUpdateWithoutVehicle_typeInput>
  }

  export type usersUncheckedUpdateManyWithoutVehicle_typeNestedInput = {
    create?: XOR<usersCreateWithoutVehicle_typeInput, usersUncheckedCreateWithoutVehicle_typeInput> | usersCreateWithoutVehicle_typeInput[] | usersUncheckedCreateWithoutVehicle_typeInput[]
    connectOrCreate?: usersCreateOrConnectWithoutVehicle_typeInput | usersCreateOrConnectWithoutVehicle_typeInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutVehicle_typeInput | usersUpsertWithWhereUniqueWithoutVehicle_typeInput[]
    createMany?: usersCreateManyVehicle_typeInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutVehicle_typeInput | usersUpdateWithWhereUniqueWithoutVehicle_typeInput[]
    updateMany?: usersUpdateManyWithWhereWithoutVehicle_typeInput | usersUpdateManyWithWhereWithoutVehicle_typeInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersCreateNestedManyWithoutVehicle_yearInput = {
    create?: XOR<usersCreateWithoutVehicle_yearInput, usersUncheckedCreateWithoutVehicle_yearInput> | usersCreateWithoutVehicle_yearInput[] | usersUncheckedCreateWithoutVehicle_yearInput[]
    connectOrCreate?: usersCreateOrConnectWithoutVehicle_yearInput | usersCreateOrConnectWithoutVehicle_yearInput[]
    createMany?: usersCreateManyVehicle_yearInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutVehicle_yearInput = {
    create?: XOR<usersCreateWithoutVehicle_yearInput, usersUncheckedCreateWithoutVehicle_yearInput> | usersCreateWithoutVehicle_yearInput[] | usersUncheckedCreateWithoutVehicle_yearInput[]
    connectOrCreate?: usersCreateOrConnectWithoutVehicle_yearInput | usersCreateOrConnectWithoutVehicle_yearInput[]
    createMany?: usersCreateManyVehicle_yearInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUpdateManyWithoutVehicle_yearNestedInput = {
    create?: XOR<usersCreateWithoutVehicle_yearInput, usersUncheckedCreateWithoutVehicle_yearInput> | usersCreateWithoutVehicle_yearInput[] | usersUncheckedCreateWithoutVehicle_yearInput[]
    connectOrCreate?: usersCreateOrConnectWithoutVehicle_yearInput | usersCreateOrConnectWithoutVehicle_yearInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutVehicle_yearInput | usersUpsertWithWhereUniqueWithoutVehicle_yearInput[]
    createMany?: usersCreateManyVehicle_yearInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutVehicle_yearInput | usersUpdateWithWhereUniqueWithoutVehicle_yearInput[]
    updateMany?: usersUpdateManyWithWhereWithoutVehicle_yearInput | usersUpdateManyWithWhereWithoutVehicle_yearInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutVehicle_yearNestedInput = {
    create?: XOR<usersCreateWithoutVehicle_yearInput, usersUncheckedCreateWithoutVehicle_yearInput> | usersCreateWithoutVehicle_yearInput[] | usersUncheckedCreateWithoutVehicle_yearInput[]
    connectOrCreate?: usersCreateOrConnectWithoutVehicle_yearInput | usersCreateOrConnectWithoutVehicle_yearInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutVehicle_yearInput | usersUpsertWithWhereUniqueWithoutVehicle_yearInput[]
    createMany?: usersCreateManyVehicle_yearInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutVehicle_yearInput | usersUpdateWithWhereUniqueWithoutVehicle_yearInput[]
    updateMany?: usersUpdateManyWithWhereWithoutVehicle_yearInput | usersUpdateManyWithWhereWithoutVehicle_yearInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type mekanikCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<mekanikCreateWithoutWarehouseInput, mekanikUncheckedCreateWithoutWarehouseInput> | mekanikCreateWithoutWarehouseInput[] | mekanikUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: mekanikCreateOrConnectWithoutWarehouseInput | mekanikCreateOrConnectWithoutWarehouseInput[]
    createMany?: mekanikCreateManyWarehouseInputEnvelope
    connect?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
  }

  export type order_barangCreateNestedManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput = {
    create?: XOR<order_barangCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput, order_barangUncheckedCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput> | order_barangCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput[] | order_barangUncheckedCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput[]
    connectOrCreate?: order_barangCreateOrConnectWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput | order_barangCreateOrConnectWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput[]
    createMany?: order_barangCreateManyWarehouse_order_barang_from_warehouse_idTowarehouseInputEnvelope
    connect?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
  }

  export type order_barangCreateNestedManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput = {
    create?: XOR<order_barangCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput, order_barangUncheckedCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput> | order_barangCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput[] | order_barangUncheckedCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput[]
    connectOrCreate?: order_barangCreateOrConnectWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput | order_barangCreateOrConnectWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput[]
    createMany?: order_barangCreateManyWarehouse_order_barang_to_warehouse_idTowarehouseInputEnvelope
    connect?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
  }

  export type transaksiCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<transaksiCreateWithoutWarehouseInput, transaksiUncheckedCreateWithoutWarehouseInput> | transaksiCreateWithoutWarehouseInput[] | transaksiUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutWarehouseInput | transaksiCreateOrConnectWithoutWarehouseInput[]
    createMany?: transaksiCreateManyWarehouseInputEnvelope
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
  }

  export type levelCreateNestedOneWithoutWarehouseInput = {
    create?: XOR<levelCreateWithoutWarehouseInput, levelUncheckedCreateWithoutWarehouseInput>
    connectOrCreate?: levelCreateOrConnectWithoutWarehouseInput
    connect?: levelWhereUniqueInput
  }

  export type warehouse_inventoryCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<warehouse_inventoryCreateWithoutWarehouseInput, warehouse_inventoryUncheckedCreateWithoutWarehouseInput> | warehouse_inventoryCreateWithoutWarehouseInput[] | warehouse_inventoryUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: warehouse_inventoryCreateOrConnectWithoutWarehouseInput | warehouse_inventoryCreateOrConnectWithoutWarehouseInput[]
    createMany?: warehouse_inventoryCreateManyWarehouseInputEnvelope
    connect?: warehouse_inventoryWhereUniqueInput | warehouse_inventoryWhereUniqueInput[]
  }

  export type mekanikUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<mekanikCreateWithoutWarehouseInput, mekanikUncheckedCreateWithoutWarehouseInput> | mekanikCreateWithoutWarehouseInput[] | mekanikUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: mekanikCreateOrConnectWithoutWarehouseInput | mekanikCreateOrConnectWithoutWarehouseInput[]
    createMany?: mekanikCreateManyWarehouseInputEnvelope
    connect?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
  }

  export type order_barangUncheckedCreateNestedManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput = {
    create?: XOR<order_barangCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput, order_barangUncheckedCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput> | order_barangCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput[] | order_barangUncheckedCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput[]
    connectOrCreate?: order_barangCreateOrConnectWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput | order_barangCreateOrConnectWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput[]
    createMany?: order_barangCreateManyWarehouse_order_barang_from_warehouse_idTowarehouseInputEnvelope
    connect?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
  }

  export type order_barangUncheckedCreateNestedManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput = {
    create?: XOR<order_barangCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput, order_barangUncheckedCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput> | order_barangCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput[] | order_barangUncheckedCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput[]
    connectOrCreate?: order_barangCreateOrConnectWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput | order_barangCreateOrConnectWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput[]
    createMany?: order_barangCreateManyWarehouse_order_barang_to_warehouse_idTowarehouseInputEnvelope
    connect?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
  }

  export type transaksiUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<transaksiCreateWithoutWarehouseInput, transaksiUncheckedCreateWithoutWarehouseInput> | transaksiCreateWithoutWarehouseInput[] | transaksiUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutWarehouseInput | transaksiCreateOrConnectWithoutWarehouseInput[]
    createMany?: transaksiCreateManyWarehouseInputEnvelope
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
  }

  export type warehouse_inventoryUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<warehouse_inventoryCreateWithoutWarehouseInput, warehouse_inventoryUncheckedCreateWithoutWarehouseInput> | warehouse_inventoryCreateWithoutWarehouseInput[] | warehouse_inventoryUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: warehouse_inventoryCreateOrConnectWithoutWarehouseInput | warehouse_inventoryCreateOrConnectWithoutWarehouseInput[]
    createMany?: warehouse_inventoryCreateManyWarehouseInputEnvelope
    connect?: warehouse_inventoryWhereUniqueInput | warehouse_inventoryWhereUniqueInput[]
  }

  export type mekanikUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<mekanikCreateWithoutWarehouseInput, mekanikUncheckedCreateWithoutWarehouseInput> | mekanikCreateWithoutWarehouseInput[] | mekanikUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: mekanikCreateOrConnectWithoutWarehouseInput | mekanikCreateOrConnectWithoutWarehouseInput[]
    upsert?: mekanikUpsertWithWhereUniqueWithoutWarehouseInput | mekanikUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: mekanikCreateManyWarehouseInputEnvelope
    set?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
    disconnect?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
    delete?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
    connect?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
    update?: mekanikUpdateWithWhereUniqueWithoutWarehouseInput | mekanikUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: mekanikUpdateManyWithWhereWithoutWarehouseInput | mekanikUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: mekanikScalarWhereInput | mekanikScalarWhereInput[]
  }

  export type order_barangUpdateManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseNestedInput = {
    create?: XOR<order_barangCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput, order_barangUncheckedCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput> | order_barangCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput[] | order_barangUncheckedCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput[]
    connectOrCreate?: order_barangCreateOrConnectWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput | order_barangCreateOrConnectWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput[]
    upsert?: order_barangUpsertWithWhereUniqueWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput | order_barangUpsertWithWhereUniqueWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput[]
    createMany?: order_barangCreateManyWarehouse_order_barang_from_warehouse_idTowarehouseInputEnvelope
    set?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
    disconnect?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
    delete?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
    connect?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
    update?: order_barangUpdateWithWhereUniqueWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput | order_barangUpdateWithWhereUniqueWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput[]
    updateMany?: order_barangUpdateManyWithWhereWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput | order_barangUpdateManyWithWhereWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput[]
    deleteMany?: order_barangScalarWhereInput | order_barangScalarWhereInput[]
  }

  export type order_barangUpdateManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseNestedInput = {
    create?: XOR<order_barangCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput, order_barangUncheckedCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput> | order_barangCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput[] | order_barangUncheckedCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput[]
    connectOrCreate?: order_barangCreateOrConnectWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput | order_barangCreateOrConnectWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput[]
    upsert?: order_barangUpsertWithWhereUniqueWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput | order_barangUpsertWithWhereUniqueWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput[]
    createMany?: order_barangCreateManyWarehouse_order_barang_to_warehouse_idTowarehouseInputEnvelope
    set?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
    disconnect?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
    delete?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
    connect?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
    update?: order_barangUpdateWithWhereUniqueWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput | order_barangUpdateWithWhereUniqueWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput[]
    updateMany?: order_barangUpdateManyWithWhereWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput | order_barangUpdateManyWithWhereWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput[]
    deleteMany?: order_barangScalarWhereInput | order_barangScalarWhereInput[]
  }

  export type transaksiUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<transaksiCreateWithoutWarehouseInput, transaksiUncheckedCreateWithoutWarehouseInput> | transaksiCreateWithoutWarehouseInput[] | transaksiUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutWarehouseInput | transaksiCreateOrConnectWithoutWarehouseInput[]
    upsert?: transaksiUpsertWithWhereUniqueWithoutWarehouseInput | transaksiUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: transaksiCreateManyWarehouseInputEnvelope
    set?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    disconnect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    delete?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    update?: transaksiUpdateWithWhereUniqueWithoutWarehouseInput | transaksiUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: transaksiUpdateManyWithWhereWithoutWarehouseInput | transaksiUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: transaksiScalarWhereInput | transaksiScalarWhereInput[]
  }

  export type levelUpdateOneRequiredWithoutWarehouseNestedInput = {
    create?: XOR<levelCreateWithoutWarehouseInput, levelUncheckedCreateWithoutWarehouseInput>
    connectOrCreate?: levelCreateOrConnectWithoutWarehouseInput
    upsert?: levelUpsertWithoutWarehouseInput
    connect?: levelWhereUniqueInput
    update?: XOR<XOR<levelUpdateToOneWithWhereWithoutWarehouseInput, levelUpdateWithoutWarehouseInput>, levelUncheckedUpdateWithoutWarehouseInput>
  }

  export type warehouse_inventoryUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<warehouse_inventoryCreateWithoutWarehouseInput, warehouse_inventoryUncheckedCreateWithoutWarehouseInput> | warehouse_inventoryCreateWithoutWarehouseInput[] | warehouse_inventoryUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: warehouse_inventoryCreateOrConnectWithoutWarehouseInput | warehouse_inventoryCreateOrConnectWithoutWarehouseInput[]
    upsert?: warehouse_inventoryUpsertWithWhereUniqueWithoutWarehouseInput | warehouse_inventoryUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: warehouse_inventoryCreateManyWarehouseInputEnvelope
    set?: warehouse_inventoryWhereUniqueInput | warehouse_inventoryWhereUniqueInput[]
    disconnect?: warehouse_inventoryWhereUniqueInput | warehouse_inventoryWhereUniqueInput[]
    delete?: warehouse_inventoryWhereUniqueInput | warehouse_inventoryWhereUniqueInput[]
    connect?: warehouse_inventoryWhereUniqueInput | warehouse_inventoryWhereUniqueInput[]
    update?: warehouse_inventoryUpdateWithWhereUniqueWithoutWarehouseInput | warehouse_inventoryUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: warehouse_inventoryUpdateManyWithWhereWithoutWarehouseInput | warehouse_inventoryUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: warehouse_inventoryScalarWhereInput | warehouse_inventoryScalarWhereInput[]
  }

  export type mekanikUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<mekanikCreateWithoutWarehouseInput, mekanikUncheckedCreateWithoutWarehouseInput> | mekanikCreateWithoutWarehouseInput[] | mekanikUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: mekanikCreateOrConnectWithoutWarehouseInput | mekanikCreateOrConnectWithoutWarehouseInput[]
    upsert?: mekanikUpsertWithWhereUniqueWithoutWarehouseInput | mekanikUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: mekanikCreateManyWarehouseInputEnvelope
    set?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
    disconnect?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
    delete?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
    connect?: mekanikWhereUniqueInput | mekanikWhereUniqueInput[]
    update?: mekanikUpdateWithWhereUniqueWithoutWarehouseInput | mekanikUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: mekanikUpdateManyWithWhereWithoutWarehouseInput | mekanikUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: mekanikScalarWhereInput | mekanikScalarWhereInput[]
  }

  export type order_barangUncheckedUpdateManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseNestedInput = {
    create?: XOR<order_barangCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput, order_barangUncheckedCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput> | order_barangCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput[] | order_barangUncheckedCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput[]
    connectOrCreate?: order_barangCreateOrConnectWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput | order_barangCreateOrConnectWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput[]
    upsert?: order_barangUpsertWithWhereUniqueWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput | order_barangUpsertWithWhereUniqueWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput[]
    createMany?: order_barangCreateManyWarehouse_order_barang_from_warehouse_idTowarehouseInputEnvelope
    set?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
    disconnect?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
    delete?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
    connect?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
    update?: order_barangUpdateWithWhereUniqueWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput | order_barangUpdateWithWhereUniqueWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput[]
    updateMany?: order_barangUpdateManyWithWhereWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput | order_barangUpdateManyWithWhereWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput[]
    deleteMany?: order_barangScalarWhereInput | order_barangScalarWhereInput[]
  }

  export type order_barangUncheckedUpdateManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseNestedInput = {
    create?: XOR<order_barangCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput, order_barangUncheckedCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput> | order_barangCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput[] | order_barangUncheckedCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput[]
    connectOrCreate?: order_barangCreateOrConnectWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput | order_barangCreateOrConnectWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput[]
    upsert?: order_barangUpsertWithWhereUniqueWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput | order_barangUpsertWithWhereUniqueWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput[]
    createMany?: order_barangCreateManyWarehouse_order_barang_to_warehouse_idTowarehouseInputEnvelope
    set?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
    disconnect?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
    delete?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
    connect?: order_barangWhereUniqueInput | order_barangWhereUniqueInput[]
    update?: order_barangUpdateWithWhereUniqueWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput | order_barangUpdateWithWhereUniqueWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput[]
    updateMany?: order_barangUpdateManyWithWhereWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput | order_barangUpdateManyWithWhereWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput[]
    deleteMany?: order_barangScalarWhereInput | order_barangScalarWhereInput[]
  }

  export type transaksiUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<transaksiCreateWithoutWarehouseInput, transaksiUncheckedCreateWithoutWarehouseInput> | transaksiCreateWithoutWarehouseInput[] | transaksiUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutWarehouseInput | transaksiCreateOrConnectWithoutWarehouseInput[]
    upsert?: transaksiUpsertWithWhereUniqueWithoutWarehouseInput | transaksiUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: transaksiCreateManyWarehouseInputEnvelope
    set?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    disconnect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    delete?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    update?: transaksiUpdateWithWhereUniqueWithoutWarehouseInput | transaksiUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: transaksiUpdateManyWithWhereWithoutWarehouseInput | transaksiUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: transaksiScalarWhereInput | transaksiScalarWhereInput[]
  }

  export type warehouse_inventoryUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<warehouse_inventoryCreateWithoutWarehouseInput, warehouse_inventoryUncheckedCreateWithoutWarehouseInput> | warehouse_inventoryCreateWithoutWarehouseInput[] | warehouse_inventoryUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: warehouse_inventoryCreateOrConnectWithoutWarehouseInput | warehouse_inventoryCreateOrConnectWithoutWarehouseInput[]
    upsert?: warehouse_inventoryUpsertWithWhereUniqueWithoutWarehouseInput | warehouse_inventoryUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: warehouse_inventoryCreateManyWarehouseInputEnvelope
    set?: warehouse_inventoryWhereUniqueInput | warehouse_inventoryWhereUniqueInput[]
    disconnect?: warehouse_inventoryWhereUniqueInput | warehouse_inventoryWhereUniqueInput[]
    delete?: warehouse_inventoryWhereUniqueInput | warehouse_inventoryWhereUniqueInput[]
    connect?: warehouse_inventoryWhereUniqueInput | warehouse_inventoryWhereUniqueInput[]
    update?: warehouse_inventoryUpdateWithWhereUniqueWithoutWarehouseInput | warehouse_inventoryUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: warehouse_inventoryUpdateManyWithWhereWithoutWarehouseInput | warehouse_inventoryUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: warehouse_inventoryScalarWhereInput | warehouse_inventoryScalarWhereInput[]
  }

  export type inventoryCreateNestedManyWithoutWarehouse_inventoryInput = {
    create?: XOR<inventoryCreateWithoutWarehouse_inventoryInput, inventoryUncheckedCreateWithoutWarehouse_inventoryInput> | inventoryCreateWithoutWarehouse_inventoryInput[] | inventoryUncheckedCreateWithoutWarehouse_inventoryInput[]
    connectOrCreate?: inventoryCreateOrConnectWithoutWarehouse_inventoryInput | inventoryCreateOrConnectWithoutWarehouse_inventoryInput[]
    createMany?: inventoryCreateManyWarehouse_inventoryInputEnvelope
    connect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
  }

  export type warehouseCreateNestedOneWithoutWarehouse_inventoryInput = {
    create?: XOR<warehouseCreateWithoutWarehouse_inventoryInput, warehouseUncheckedCreateWithoutWarehouse_inventoryInput>
    connectOrCreate?: warehouseCreateOrConnectWithoutWarehouse_inventoryInput
    connect?: warehouseWhereUniqueInput
  }

  export type inventoryUncheckedCreateNestedManyWithoutWarehouse_inventoryInput = {
    create?: XOR<inventoryCreateWithoutWarehouse_inventoryInput, inventoryUncheckedCreateWithoutWarehouse_inventoryInput> | inventoryCreateWithoutWarehouse_inventoryInput[] | inventoryUncheckedCreateWithoutWarehouse_inventoryInput[]
    connectOrCreate?: inventoryCreateOrConnectWithoutWarehouse_inventoryInput | inventoryCreateOrConnectWithoutWarehouse_inventoryInput[]
    createMany?: inventoryCreateManyWarehouse_inventoryInputEnvelope
    connect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
  }

  export type inventoryUpdateManyWithoutWarehouse_inventoryNestedInput = {
    create?: XOR<inventoryCreateWithoutWarehouse_inventoryInput, inventoryUncheckedCreateWithoutWarehouse_inventoryInput> | inventoryCreateWithoutWarehouse_inventoryInput[] | inventoryUncheckedCreateWithoutWarehouse_inventoryInput[]
    connectOrCreate?: inventoryCreateOrConnectWithoutWarehouse_inventoryInput | inventoryCreateOrConnectWithoutWarehouse_inventoryInput[]
    upsert?: inventoryUpsertWithWhereUniqueWithoutWarehouse_inventoryInput | inventoryUpsertWithWhereUniqueWithoutWarehouse_inventoryInput[]
    createMany?: inventoryCreateManyWarehouse_inventoryInputEnvelope
    set?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    disconnect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    delete?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    connect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    update?: inventoryUpdateWithWhereUniqueWithoutWarehouse_inventoryInput | inventoryUpdateWithWhereUniqueWithoutWarehouse_inventoryInput[]
    updateMany?: inventoryUpdateManyWithWhereWithoutWarehouse_inventoryInput | inventoryUpdateManyWithWhereWithoutWarehouse_inventoryInput[]
    deleteMany?: inventoryScalarWhereInput | inventoryScalarWhereInput[]
  }

  export type warehouseUpdateOneRequiredWithoutWarehouse_inventoryNestedInput = {
    create?: XOR<warehouseCreateWithoutWarehouse_inventoryInput, warehouseUncheckedCreateWithoutWarehouse_inventoryInput>
    connectOrCreate?: warehouseCreateOrConnectWithoutWarehouse_inventoryInput
    upsert?: warehouseUpsertWithoutWarehouse_inventoryInput
    connect?: warehouseWhereUniqueInput
    update?: XOR<XOR<warehouseUpdateToOneWithWhereWithoutWarehouse_inventoryInput, warehouseUpdateWithoutWarehouse_inventoryInput>, warehouseUncheckedUpdateWithoutWarehouse_inventoryInput>
  }

  export type inventoryUncheckedUpdateManyWithoutWarehouse_inventoryNestedInput = {
    create?: XOR<inventoryCreateWithoutWarehouse_inventoryInput, inventoryUncheckedCreateWithoutWarehouse_inventoryInput> | inventoryCreateWithoutWarehouse_inventoryInput[] | inventoryUncheckedCreateWithoutWarehouse_inventoryInput[]
    connectOrCreate?: inventoryCreateOrConnectWithoutWarehouse_inventoryInput | inventoryCreateOrConnectWithoutWarehouse_inventoryInput[]
    upsert?: inventoryUpsertWithWhereUniqueWithoutWarehouse_inventoryInput | inventoryUpsertWithWhereUniqueWithoutWarehouse_inventoryInput[]
    createMany?: inventoryCreateManyWarehouse_inventoryInputEnvelope
    set?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    disconnect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    delete?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    connect?: inventoryWhereUniqueInput | inventoryWhereUniqueInput[]
    update?: inventoryUpdateWithWhereUniqueWithoutWarehouse_inventoryInput | inventoryUpdateWithWhereUniqueWithoutWarehouse_inventoryInput[]
    updateMany?: inventoryUpdateManyWithWhereWithoutWarehouse_inventoryInput | inventoryUpdateManyWithWhereWithoutWarehouse_inventoryInput[]
    deleteMany?: inventoryScalarWhereInput | inventoryScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type vehicle_categoryCreateWithoutBarangInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    vehicle_type?: vehicle_typeCreateNestedManyWithoutVehicle_categoryInput
  }

  export type vehicle_categoryUncheckedCreateWithoutBarangInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    vehicle_type?: vehicle_typeUncheckedCreateNestedManyWithoutVehicle_categoryInput
  }

  export type vehicle_categoryCreateOrConnectWithoutBarangInput = {
    where: vehicle_categoryWhereUniqueInput
    create: XOR<vehicle_categoryCreateWithoutBarangInput, vehicle_categoryUncheckedCreateWithoutBarangInput>
  }

  export type inventoryCreateWithoutBarangInput = {
    id: string
    qty?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    warehouse_inventory: warehouse_inventoryCreateNestedOneWithoutInventoryInput
  }

  export type inventoryUncheckedCreateWithoutBarangInput = {
    id: string
    warehouse_inventory_id: string
    qty?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type inventoryCreateOrConnectWithoutBarangInput = {
    where: inventoryWhereUniqueInput
    create: XOR<inventoryCreateWithoutBarangInput, inventoryUncheckedCreateWithoutBarangInput>
  }

  export type inventoryCreateManyBarangInputEnvelope = {
    data: inventoryCreateManyBarangInput | inventoryCreateManyBarangInput[]
    skipDuplicates?: boolean
  }

  export type order_barang_detailCreateWithoutBarangInput = {
    id: string
    qty: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    order_barang: order_barangCreateNestedOneWithoutOrder_barang_detailInput
  }

  export type order_barang_detailUncheckedCreateWithoutBarangInput = {
    id: string
    order_barang_id: string
    qty: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type order_barang_detailCreateOrConnectWithoutBarangInput = {
    where: order_barang_detailWhereUniqueInput
    create: XOR<order_barang_detailCreateWithoutBarangInput, order_barang_detailUncheckedCreateWithoutBarangInput>
  }

  export type order_barang_detailCreateManyBarangInputEnvelope = {
    data: order_barang_detailCreateManyBarangInput | order_barang_detailCreateManyBarangInput[]
    skipDuplicates?: boolean
  }

  export type transaksi_detailCreateWithoutBarangInput = {
    id: string
    qty: number
    sub_total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    transaksi: transaksiCreateNestedOneWithoutTransaksi_detailInput
  }

  export type transaksi_detailUncheckedCreateWithoutBarangInput = {
    id: string
    transaksi_id: string
    qty: number
    sub_total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type transaksi_detailCreateOrConnectWithoutBarangInput = {
    where: transaksi_detailWhereUniqueInput
    create: XOR<transaksi_detailCreateWithoutBarangInput, transaksi_detailUncheckedCreateWithoutBarangInput>
  }

  export type transaksi_detailCreateManyBarangInputEnvelope = {
    data: transaksi_detailCreateManyBarangInput | transaksi_detailCreateManyBarangInput[]
    skipDuplicates?: boolean
  }

  export type vehicle_categoryUpsertWithoutBarangInput = {
    update: XOR<vehicle_categoryUpdateWithoutBarangInput, vehicle_categoryUncheckedUpdateWithoutBarangInput>
    create: XOR<vehicle_categoryCreateWithoutBarangInput, vehicle_categoryUncheckedCreateWithoutBarangInput>
    where?: vehicle_categoryWhereInput
  }

  export type vehicle_categoryUpdateToOneWithWhereWithoutBarangInput = {
    where?: vehicle_categoryWhereInput
    data: XOR<vehicle_categoryUpdateWithoutBarangInput, vehicle_categoryUncheckedUpdateWithoutBarangInput>
  }

  export type vehicle_categoryUpdateWithoutBarangInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicle_type?: vehicle_typeUpdateManyWithoutVehicle_categoryNestedInput
  }

  export type vehicle_categoryUncheckedUpdateWithoutBarangInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicle_type?: vehicle_typeUncheckedUpdateManyWithoutVehicle_categoryNestedInput
  }

  export type inventoryUpsertWithWhereUniqueWithoutBarangInput = {
    where: inventoryWhereUniqueInput
    update: XOR<inventoryUpdateWithoutBarangInput, inventoryUncheckedUpdateWithoutBarangInput>
    create: XOR<inventoryCreateWithoutBarangInput, inventoryUncheckedCreateWithoutBarangInput>
  }

  export type inventoryUpdateWithWhereUniqueWithoutBarangInput = {
    where: inventoryWhereUniqueInput
    data: XOR<inventoryUpdateWithoutBarangInput, inventoryUncheckedUpdateWithoutBarangInput>
  }

  export type inventoryUpdateManyWithWhereWithoutBarangInput = {
    where: inventoryScalarWhereInput
    data: XOR<inventoryUpdateManyMutationInput, inventoryUncheckedUpdateManyWithoutBarangInput>
  }

  export type inventoryScalarWhereInput = {
    AND?: inventoryScalarWhereInput | inventoryScalarWhereInput[]
    OR?: inventoryScalarWhereInput[]
    NOT?: inventoryScalarWhereInput | inventoryScalarWhereInput[]
    id?: StringFilter<"inventory"> | string
    warehouse_inventory_id?: StringFilter<"inventory"> | string
    barang_id?: StringFilter<"inventory"> | string
    qty?: IntFilter<"inventory"> | number
    createdAt?: DateTimeNullableFilter<"inventory"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"inventory"> | Date | string | null
  }

  export type order_barang_detailUpsertWithWhereUniqueWithoutBarangInput = {
    where: order_barang_detailWhereUniqueInput
    update: XOR<order_barang_detailUpdateWithoutBarangInput, order_barang_detailUncheckedUpdateWithoutBarangInput>
    create: XOR<order_barang_detailCreateWithoutBarangInput, order_barang_detailUncheckedCreateWithoutBarangInput>
  }

  export type order_barang_detailUpdateWithWhereUniqueWithoutBarangInput = {
    where: order_barang_detailWhereUniqueInput
    data: XOR<order_barang_detailUpdateWithoutBarangInput, order_barang_detailUncheckedUpdateWithoutBarangInput>
  }

  export type order_barang_detailUpdateManyWithWhereWithoutBarangInput = {
    where: order_barang_detailScalarWhereInput
    data: XOR<order_barang_detailUpdateManyMutationInput, order_barang_detailUncheckedUpdateManyWithoutBarangInput>
  }

  export type order_barang_detailScalarWhereInput = {
    AND?: order_barang_detailScalarWhereInput | order_barang_detailScalarWhereInput[]
    OR?: order_barang_detailScalarWhereInput[]
    NOT?: order_barang_detailScalarWhereInput | order_barang_detailScalarWhereInput[]
    id?: StringFilter<"order_barang_detail"> | string
    order_barang_id?: StringFilter<"order_barang_detail"> | string
    barang_id?: StringFilter<"order_barang_detail"> | string
    qty?: IntFilter<"order_barang_detail"> | number
    createdAt?: DateTimeNullableFilter<"order_barang_detail"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"order_barang_detail"> | Date | string | null
  }

  export type transaksi_detailUpsertWithWhereUniqueWithoutBarangInput = {
    where: transaksi_detailWhereUniqueInput
    update: XOR<transaksi_detailUpdateWithoutBarangInput, transaksi_detailUncheckedUpdateWithoutBarangInput>
    create: XOR<transaksi_detailCreateWithoutBarangInput, transaksi_detailUncheckedCreateWithoutBarangInput>
  }

  export type transaksi_detailUpdateWithWhereUniqueWithoutBarangInput = {
    where: transaksi_detailWhereUniqueInput
    data: XOR<transaksi_detailUpdateWithoutBarangInput, transaksi_detailUncheckedUpdateWithoutBarangInput>
  }

  export type transaksi_detailUpdateManyWithWhereWithoutBarangInput = {
    where: transaksi_detailScalarWhereInput
    data: XOR<transaksi_detailUpdateManyMutationInput, transaksi_detailUncheckedUpdateManyWithoutBarangInput>
  }

  export type transaksi_detailScalarWhereInput = {
    AND?: transaksi_detailScalarWhereInput | transaksi_detailScalarWhereInput[]
    OR?: transaksi_detailScalarWhereInput[]
    NOT?: transaksi_detailScalarWhereInput | transaksi_detailScalarWhereInput[]
    id?: StringFilter<"transaksi_detail"> | string
    transaksi_id?: StringFilter<"transaksi_detail"> | string
    barang_id?: StringFilter<"transaksi_detail"> | string
    qty?: IntFilter<"transaksi_detail"> | number
    sub_total?: DecimalFilter<"transaksi_detail"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeNullableFilter<"transaksi_detail"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"transaksi_detail"> | Date | string | null
  }

  export type statusCreateWithoutEmployeeInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    users?: usersCreateNestedManyWithoutStatusInput
  }

  export type statusUncheckedCreateWithoutEmployeeInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    users?: usersUncheckedCreateNestedManyWithoutStatusInput
  }

  export type statusCreateOrConnectWithoutEmployeeInput = {
    where: statusWhereUniqueInput
    create: XOR<statusCreateWithoutEmployeeInput, statusUncheckedCreateWithoutEmployeeInput>
  }

  export type mekanikCreateWithoutEmployeeInput = {
    id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    warehouse: warehouseCreateNestedOneWithoutMekanikInput
    transaksi?: transaksiCreateNestedManyWithoutMekanikInput
  }

  export type mekanikUncheckedCreateWithoutEmployeeInput = {
    id: string
    warehouse_id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    transaksi?: transaksiUncheckedCreateNestedManyWithoutMekanikInput
  }

  export type mekanikCreateOrConnectWithoutEmployeeInput = {
    where: mekanikWhereUniqueInput
    create: XOR<mekanikCreateWithoutEmployeeInput, mekanikUncheckedCreateWithoutEmployeeInput>
  }

  export type mekanikCreateManyEmployeeInputEnvelope = {
    data: mekanikCreateManyEmployeeInput | mekanikCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type statusUpsertWithoutEmployeeInput = {
    update: XOR<statusUpdateWithoutEmployeeInput, statusUncheckedUpdateWithoutEmployeeInput>
    create: XOR<statusCreateWithoutEmployeeInput, statusUncheckedCreateWithoutEmployeeInput>
    where?: statusWhereInput
  }

  export type statusUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: statusWhereInput
    data: XOR<statusUpdateWithoutEmployeeInput, statusUncheckedUpdateWithoutEmployeeInput>
  }

  export type statusUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateManyWithoutStatusNestedInput
  }

  export type statusUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type mekanikUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: mekanikWhereUniqueInput
    update: XOR<mekanikUpdateWithoutEmployeeInput, mekanikUncheckedUpdateWithoutEmployeeInput>
    create: XOR<mekanikCreateWithoutEmployeeInput, mekanikUncheckedCreateWithoutEmployeeInput>
  }

  export type mekanikUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: mekanikWhereUniqueInput
    data: XOR<mekanikUpdateWithoutEmployeeInput, mekanikUncheckedUpdateWithoutEmployeeInput>
  }

  export type mekanikUpdateManyWithWhereWithoutEmployeeInput = {
    where: mekanikScalarWhereInput
    data: XOR<mekanikUpdateManyMutationInput, mekanikUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type mekanikScalarWhereInput = {
    AND?: mekanikScalarWhereInput | mekanikScalarWhereInput[]
    OR?: mekanikScalarWhereInput[]
    NOT?: mekanikScalarWhereInput | mekanikScalarWhereInput[]
    id?: StringFilter<"mekanik"> | string
    employee_id?: StringFilter<"mekanik"> | string
    warehouse_id?: StringFilter<"mekanik"> | string
    createdAt?: DateTimeNullableFilter<"mekanik"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"mekanik"> | Date | string | null
  }

  export type barangCreateWithoutInventoryInput = {
    id: string
    name_barang: string
    description_barang?: string | null
    price: Decimal | DecimalJsLike | number | string
    point?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    vehicle_category: vehicle_categoryCreateNestedOneWithoutBarangInput
    order_barang_detail?: order_barang_detailCreateNestedManyWithoutBarangInput
    transaksi_detail?: transaksi_detailCreateNestedManyWithoutBarangInput
  }

  export type barangUncheckedCreateWithoutInventoryInput = {
    id: string
    category_vehicle_id: string
    name_barang: string
    description_barang?: string | null
    price: Decimal | DecimalJsLike | number | string
    point?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    order_barang_detail?: order_barang_detailUncheckedCreateNestedManyWithoutBarangInput
    transaksi_detail?: transaksi_detailUncheckedCreateNestedManyWithoutBarangInput
  }

  export type barangCreateOrConnectWithoutInventoryInput = {
    where: barangWhereUniqueInput
    create: XOR<barangCreateWithoutInventoryInput, barangUncheckedCreateWithoutInventoryInput>
  }

  export type warehouse_inventoryCreateWithoutInventoryInput = {
    id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    warehouse: warehouseCreateNestedOneWithoutWarehouse_inventoryInput
  }

  export type warehouse_inventoryUncheckedCreateWithoutInventoryInput = {
    id: string
    warehouse_id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type warehouse_inventoryCreateOrConnectWithoutInventoryInput = {
    where: warehouse_inventoryWhereUniqueInput
    create: XOR<warehouse_inventoryCreateWithoutInventoryInput, warehouse_inventoryUncheckedCreateWithoutInventoryInput>
  }

  export type barangUpsertWithoutInventoryInput = {
    update: XOR<barangUpdateWithoutInventoryInput, barangUncheckedUpdateWithoutInventoryInput>
    create: XOR<barangCreateWithoutInventoryInput, barangUncheckedCreateWithoutInventoryInput>
    where?: barangWhereInput
  }

  export type barangUpdateToOneWithWhereWithoutInventoryInput = {
    where?: barangWhereInput
    data: XOR<barangUpdateWithoutInventoryInput, barangUncheckedUpdateWithoutInventoryInput>
  }

  export type barangUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_barang?: StringFieldUpdateOperationsInput | string
    description_barang?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicle_category?: vehicle_categoryUpdateOneRequiredWithoutBarangNestedInput
    order_barang_detail?: order_barang_detailUpdateManyWithoutBarangNestedInput
    transaksi_detail?: transaksi_detailUpdateManyWithoutBarangNestedInput
  }

  export type barangUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_vehicle_id?: StringFieldUpdateOperationsInput | string
    name_barang?: StringFieldUpdateOperationsInput | string
    description_barang?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order_barang_detail?: order_barang_detailUncheckedUpdateManyWithoutBarangNestedInput
    transaksi_detail?: transaksi_detailUncheckedUpdateManyWithoutBarangNestedInput
  }

  export type warehouse_inventoryUpsertWithoutInventoryInput = {
    update: XOR<warehouse_inventoryUpdateWithoutInventoryInput, warehouse_inventoryUncheckedUpdateWithoutInventoryInput>
    create: XOR<warehouse_inventoryCreateWithoutInventoryInput, warehouse_inventoryUncheckedCreateWithoutInventoryInput>
    where?: warehouse_inventoryWhereInput
  }

  export type warehouse_inventoryUpdateToOneWithWhereWithoutInventoryInput = {
    where?: warehouse_inventoryWhereInput
    data: XOR<warehouse_inventoryUpdateWithoutInventoryInput, warehouse_inventoryUncheckedUpdateWithoutInventoryInput>
  }

  export type warehouse_inventoryUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse?: warehouseUpdateOneRequiredWithoutWarehouse_inventoryNestedInput
  }

  export type warehouse_inventoryUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouse_id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type warehouseCreateWithoutLevelInput = {
    id: string
    name_warehouse: string
    username: string
    password: string
    warehouse_address: string
    phone_number_warehouse?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    mekanik?: mekanikCreateNestedManyWithoutWarehouseInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangCreateNestedManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangCreateNestedManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput
    transaksi?: transaksiCreateNestedManyWithoutWarehouseInput
    warehouse_inventory?: warehouse_inventoryCreateNestedManyWithoutWarehouseInput
  }

  export type warehouseUncheckedCreateWithoutLevelInput = {
    id: string
    name_warehouse: string
    username: string
    password: string
    warehouse_address: string
    phone_number_warehouse?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    mekanik?: mekanikUncheckedCreateNestedManyWithoutWarehouseInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangUncheckedCreateNestedManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangUncheckedCreateNestedManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutWarehouseInput
    warehouse_inventory?: warehouse_inventoryUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type warehouseCreateOrConnectWithoutLevelInput = {
    where: warehouseWhereUniqueInput
    create: XOR<warehouseCreateWithoutLevelInput, warehouseUncheckedCreateWithoutLevelInput>
  }

  export type warehouseCreateManyLevelInputEnvelope = {
    data: warehouseCreateManyLevelInput | warehouseCreateManyLevelInput[]
    skipDuplicates?: boolean
  }

  export type warehouseUpsertWithWhereUniqueWithoutLevelInput = {
    where: warehouseWhereUniqueInput
    update: XOR<warehouseUpdateWithoutLevelInput, warehouseUncheckedUpdateWithoutLevelInput>
    create: XOR<warehouseCreateWithoutLevelInput, warehouseUncheckedCreateWithoutLevelInput>
  }

  export type warehouseUpdateWithWhereUniqueWithoutLevelInput = {
    where: warehouseWhereUniqueInput
    data: XOR<warehouseUpdateWithoutLevelInput, warehouseUncheckedUpdateWithoutLevelInput>
  }

  export type warehouseUpdateManyWithWhereWithoutLevelInput = {
    where: warehouseScalarWhereInput
    data: XOR<warehouseUpdateManyMutationInput, warehouseUncheckedUpdateManyWithoutLevelInput>
  }

  export type warehouseScalarWhereInput = {
    AND?: warehouseScalarWhereInput | warehouseScalarWhereInput[]
    OR?: warehouseScalarWhereInput[]
    NOT?: warehouseScalarWhereInput | warehouseScalarWhereInput[]
    id?: StringFilter<"warehouse"> | string
    level_id?: StringFilter<"warehouse"> | string
    name_warehouse?: StringFilter<"warehouse"> | string
    username?: StringFilter<"warehouse"> | string
    password?: StringFilter<"warehouse"> | string
    warehouse_address?: StringFilter<"warehouse"> | string
    phone_number_warehouse?: StringNullableFilter<"warehouse"> | string | null
    createdAt?: DateTimeNullableFilter<"warehouse"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"warehouse"> | Date | string | null
  }

  export type employeeCreateWithoutMekanikInput = {
    id: string
    name: string
    point?: number | null
    address?: string | null
    phone_number?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    status: statusCreateNestedOneWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutMekanikInput = {
    id: string
    status_id: string
    name: string
    point?: number | null
    address?: string | null
    phone_number?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type employeeCreateOrConnectWithoutMekanikInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutMekanikInput, employeeUncheckedCreateWithoutMekanikInput>
  }

  export type warehouseCreateWithoutMekanikInput = {
    id: string
    name_warehouse: string
    username: string
    password: string
    warehouse_address: string
    phone_number_warehouse?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangCreateNestedManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangCreateNestedManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput
    transaksi?: transaksiCreateNestedManyWithoutWarehouseInput
    level: levelCreateNestedOneWithoutWarehouseInput
    warehouse_inventory?: warehouse_inventoryCreateNestedManyWithoutWarehouseInput
  }

  export type warehouseUncheckedCreateWithoutMekanikInput = {
    id: string
    level_id: string
    name_warehouse: string
    username: string
    password: string
    warehouse_address: string
    phone_number_warehouse?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangUncheckedCreateNestedManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangUncheckedCreateNestedManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutWarehouseInput
    warehouse_inventory?: warehouse_inventoryUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type warehouseCreateOrConnectWithoutMekanikInput = {
    where: warehouseWhereUniqueInput
    create: XOR<warehouseCreateWithoutMekanikInput, warehouseUncheckedCreateWithoutMekanikInput>
  }

  export type transaksiCreateWithoutMekanikInput = {
    id: string
    point?: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    users: usersCreateNestedOneWithoutTransaksiInput
    warehouse: warehouseCreateNestedOneWithoutTransaksiInput
    transaksi_detail?: transaksi_detailCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiUncheckedCreateWithoutMekanikInput = {
    id: string
    users_id: string
    warehouse_id: string
    point?: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    transaksi_detail?: transaksi_detailUncheckedCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiCreateOrConnectWithoutMekanikInput = {
    where: transaksiWhereUniqueInput
    create: XOR<transaksiCreateWithoutMekanikInput, transaksiUncheckedCreateWithoutMekanikInput>
  }

  export type transaksiCreateManyMekanikInputEnvelope = {
    data: transaksiCreateManyMekanikInput | transaksiCreateManyMekanikInput[]
    skipDuplicates?: boolean
  }

  export type employeeUpsertWithoutMekanikInput = {
    update: XOR<employeeUpdateWithoutMekanikInput, employeeUncheckedUpdateWithoutMekanikInput>
    create: XOR<employeeCreateWithoutMekanikInput, employeeUncheckedCreateWithoutMekanikInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutMekanikInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutMekanikInput, employeeUncheckedUpdateWithoutMekanikInput>
  }

  export type employeeUpdateWithoutMekanikInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: statusUpdateOneRequiredWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutMekanikInput = {
    id?: StringFieldUpdateOperationsInput | string
    status_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type warehouseUpsertWithoutMekanikInput = {
    update: XOR<warehouseUpdateWithoutMekanikInput, warehouseUncheckedUpdateWithoutMekanikInput>
    create: XOR<warehouseCreateWithoutMekanikInput, warehouseUncheckedCreateWithoutMekanikInput>
    where?: warehouseWhereInput
  }

  export type warehouseUpdateToOneWithWhereWithoutMekanikInput = {
    where?: warehouseWhereInput
    data: XOR<warehouseUpdateWithoutMekanikInput, warehouseUncheckedUpdateWithoutMekanikInput>
  }

  export type warehouseUpdateWithoutMekanikInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_warehouse?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    warehouse_address?: StringFieldUpdateOperationsInput | string
    phone_number_warehouse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangUpdateManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseNestedInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangUpdateManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseNestedInput
    transaksi?: transaksiUpdateManyWithoutWarehouseNestedInput
    level?: levelUpdateOneRequiredWithoutWarehouseNestedInput
    warehouse_inventory?: warehouse_inventoryUpdateManyWithoutWarehouseNestedInput
  }

  export type warehouseUncheckedUpdateWithoutMekanikInput = {
    id?: StringFieldUpdateOperationsInput | string
    level_id?: StringFieldUpdateOperationsInput | string
    name_warehouse?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    warehouse_address?: StringFieldUpdateOperationsInput | string
    phone_number_warehouse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangUncheckedUpdateManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseNestedInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangUncheckedUpdateManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutWarehouseNestedInput
    warehouse_inventory?: warehouse_inventoryUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type transaksiUpsertWithWhereUniqueWithoutMekanikInput = {
    where: transaksiWhereUniqueInput
    update: XOR<transaksiUpdateWithoutMekanikInput, transaksiUncheckedUpdateWithoutMekanikInput>
    create: XOR<transaksiCreateWithoutMekanikInput, transaksiUncheckedCreateWithoutMekanikInput>
  }

  export type transaksiUpdateWithWhereUniqueWithoutMekanikInput = {
    where: transaksiWhereUniqueInput
    data: XOR<transaksiUpdateWithoutMekanikInput, transaksiUncheckedUpdateWithoutMekanikInput>
  }

  export type transaksiUpdateManyWithWhereWithoutMekanikInput = {
    where: transaksiScalarWhereInput
    data: XOR<transaksiUpdateManyMutationInput, transaksiUncheckedUpdateManyWithoutMekanikInput>
  }

  export type transaksiScalarWhereInput = {
    AND?: transaksiScalarWhereInput | transaksiScalarWhereInput[]
    OR?: transaksiScalarWhereInput[]
    NOT?: transaksiScalarWhereInput | transaksiScalarWhereInput[]
    id?: StringFilter<"transaksi"> | string
    users_id?: StringFilter<"transaksi"> | string
    mekanik_id?: StringFilter<"transaksi"> | string
    warehouse_id?: StringFilter<"transaksi"> | string
    point?: IntFilter<"transaksi"> | number
    total?: DecimalFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeNullableFilter<"transaksi"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"transaksi"> | Date | string | null
  }

  export type usersCreateWithoutMemberInput = {
    id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    transaksi?: transaksiCreateNestedManyWithoutUsersInput
    status: statusCreateNestedOneWithoutUsersInput
    vehicle_merk: vehicle_merkCreateNestedOneWithoutUsersInput
    vehicle_year: vehicle_yearCreateNestedOneWithoutUsersInput
    vehicle_type: vehicle_typeCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutMemberInput = {
    id: string
    status_id: string
    vehicle_year_id: string
    vehicle_merk_id: string
    vehicle_type_id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    transaksi?: transaksiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutMemberInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutMemberInput, usersUncheckedCreateWithoutMemberInput>
  }

  export type usersCreateManyMemberInputEnvelope = {
    data: usersCreateManyMemberInput | usersCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithWhereUniqueWithoutMemberInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutMemberInput, usersUncheckedUpdateWithoutMemberInput>
    create: XOR<usersCreateWithoutMemberInput, usersUncheckedCreateWithoutMemberInput>
  }

  export type usersUpdateWithWhereUniqueWithoutMemberInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutMemberInput, usersUncheckedUpdateWithoutMemberInput>
  }

  export type usersUpdateManyWithWhereWithoutMemberInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutMemberInput>
  }

  export type usersScalarWhereInput = {
    AND?: usersScalarWhereInput | usersScalarWhereInput[]
    OR?: usersScalarWhereInput[]
    NOT?: usersScalarWhereInput | usersScalarWhereInput[]
    id?: StringFilter<"users"> | string
    status_id?: StringFilter<"users"> | string
    member_id?: StringFilter<"users"> | string
    vehicle_year_id?: StringFilter<"users"> | string
    vehicle_merk_id?: StringFilter<"users"> | string
    vehicle_type_id?: StringFilter<"users"> | string
    no_police?: StringFilter<"users"> | string
    name?: StringNullableFilter<"users"> | string | null
    point?: IntNullableFilter<"users"> | number | null
    address?: StringNullableFilter<"users"> | string | null
    phone_number?: StringFilter<"users"> | string
    createdAt?: DateTimeNullableFilter<"users"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"users"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"users"> | Date | string | null
  }

  export type warehouseCreateWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput = {
    id: string
    name_warehouse: string
    username: string
    password: string
    warehouse_address: string
    phone_number_warehouse?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    mekanik?: mekanikCreateNestedManyWithoutWarehouseInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangCreateNestedManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput
    transaksi?: transaksiCreateNestedManyWithoutWarehouseInput
    level: levelCreateNestedOneWithoutWarehouseInput
    warehouse_inventory?: warehouse_inventoryCreateNestedManyWithoutWarehouseInput
  }

  export type warehouseUncheckedCreateWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput = {
    id: string
    level_id: string
    name_warehouse: string
    username: string
    password: string
    warehouse_address: string
    phone_number_warehouse?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    mekanik?: mekanikUncheckedCreateNestedManyWithoutWarehouseInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangUncheckedCreateNestedManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutWarehouseInput
    warehouse_inventory?: warehouse_inventoryUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type warehouseCreateOrConnectWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput = {
    where: warehouseWhereUniqueInput
    create: XOR<warehouseCreateWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput, warehouseUncheckedCreateWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput>
  }

  export type warehouseCreateWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput = {
    id: string
    name_warehouse: string
    username: string
    password: string
    warehouse_address: string
    phone_number_warehouse?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    mekanik?: mekanikCreateNestedManyWithoutWarehouseInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangCreateNestedManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput
    transaksi?: transaksiCreateNestedManyWithoutWarehouseInput
    level: levelCreateNestedOneWithoutWarehouseInput
    warehouse_inventory?: warehouse_inventoryCreateNestedManyWithoutWarehouseInput
  }

  export type warehouseUncheckedCreateWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput = {
    id: string
    level_id: string
    name_warehouse: string
    username: string
    password: string
    warehouse_address: string
    phone_number_warehouse?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    mekanik?: mekanikUncheckedCreateNestedManyWithoutWarehouseInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangUncheckedCreateNestedManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutWarehouseInput
    warehouse_inventory?: warehouse_inventoryUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type warehouseCreateOrConnectWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput = {
    where: warehouseWhereUniqueInput
    create: XOR<warehouseCreateWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput, warehouseUncheckedCreateWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput>
  }

  export type order_barang_detailCreateWithoutOrder_barangInput = {
    id: string
    qty: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    barang: barangCreateNestedOneWithoutOrder_barang_detailInput
  }

  export type order_barang_detailUncheckedCreateWithoutOrder_barangInput = {
    id: string
    barang_id: string
    qty: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type order_barang_detailCreateOrConnectWithoutOrder_barangInput = {
    where: order_barang_detailWhereUniqueInput
    create: XOR<order_barang_detailCreateWithoutOrder_barangInput, order_barang_detailUncheckedCreateWithoutOrder_barangInput>
  }

  export type order_barang_detailCreateManyOrder_barangInputEnvelope = {
    data: order_barang_detailCreateManyOrder_barangInput | order_barang_detailCreateManyOrder_barangInput[]
    skipDuplicates?: boolean
  }

  export type warehouseUpsertWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput = {
    update: XOR<warehouseUpdateWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput, warehouseUncheckedUpdateWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput>
    create: XOR<warehouseCreateWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput, warehouseUncheckedCreateWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput>
    where?: warehouseWhereInput
  }

  export type warehouseUpdateToOneWithWhereWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput = {
    where?: warehouseWhereInput
    data: XOR<warehouseUpdateWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput, warehouseUncheckedUpdateWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput>
  }

  export type warehouseUpdateWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_warehouse?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    warehouse_address?: StringFieldUpdateOperationsInput | string
    phone_number_warehouse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mekanik?: mekanikUpdateManyWithoutWarehouseNestedInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangUpdateManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseNestedInput
    transaksi?: transaksiUpdateManyWithoutWarehouseNestedInput
    level?: levelUpdateOneRequiredWithoutWarehouseNestedInput
    warehouse_inventory?: warehouse_inventoryUpdateManyWithoutWarehouseNestedInput
  }

  export type warehouseUncheckedUpdateWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    level_id?: StringFieldUpdateOperationsInput | string
    name_warehouse?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    warehouse_address?: StringFieldUpdateOperationsInput | string
    phone_number_warehouse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mekanik?: mekanikUncheckedUpdateManyWithoutWarehouseNestedInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangUncheckedUpdateManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutWarehouseNestedInput
    warehouse_inventory?: warehouse_inventoryUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type warehouseUpsertWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput = {
    update: XOR<warehouseUpdateWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput, warehouseUncheckedUpdateWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput>
    create: XOR<warehouseCreateWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput, warehouseUncheckedCreateWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput>
    where?: warehouseWhereInput
  }

  export type warehouseUpdateToOneWithWhereWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput = {
    where?: warehouseWhereInput
    data: XOR<warehouseUpdateWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput, warehouseUncheckedUpdateWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput>
  }

  export type warehouseUpdateWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_warehouse?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    warehouse_address?: StringFieldUpdateOperationsInput | string
    phone_number_warehouse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mekanik?: mekanikUpdateManyWithoutWarehouseNestedInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangUpdateManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseNestedInput
    transaksi?: transaksiUpdateManyWithoutWarehouseNestedInput
    level?: levelUpdateOneRequiredWithoutWarehouseNestedInput
    warehouse_inventory?: warehouse_inventoryUpdateManyWithoutWarehouseNestedInput
  }

  export type warehouseUncheckedUpdateWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    level_id?: StringFieldUpdateOperationsInput | string
    name_warehouse?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    warehouse_address?: StringFieldUpdateOperationsInput | string
    phone_number_warehouse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mekanik?: mekanikUncheckedUpdateManyWithoutWarehouseNestedInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangUncheckedUpdateManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutWarehouseNestedInput
    warehouse_inventory?: warehouse_inventoryUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type order_barang_detailUpsertWithWhereUniqueWithoutOrder_barangInput = {
    where: order_barang_detailWhereUniqueInput
    update: XOR<order_barang_detailUpdateWithoutOrder_barangInput, order_barang_detailUncheckedUpdateWithoutOrder_barangInput>
    create: XOR<order_barang_detailCreateWithoutOrder_barangInput, order_barang_detailUncheckedCreateWithoutOrder_barangInput>
  }

  export type order_barang_detailUpdateWithWhereUniqueWithoutOrder_barangInput = {
    where: order_barang_detailWhereUniqueInput
    data: XOR<order_barang_detailUpdateWithoutOrder_barangInput, order_barang_detailUncheckedUpdateWithoutOrder_barangInput>
  }

  export type order_barang_detailUpdateManyWithWhereWithoutOrder_barangInput = {
    where: order_barang_detailScalarWhereInput
    data: XOR<order_barang_detailUpdateManyMutationInput, order_barang_detailUncheckedUpdateManyWithoutOrder_barangInput>
  }

  export type barangCreateWithoutOrder_barang_detailInput = {
    id: string
    name_barang: string
    description_barang?: string | null
    price: Decimal | DecimalJsLike | number | string
    point?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    vehicle_category: vehicle_categoryCreateNestedOneWithoutBarangInput
    inventory?: inventoryCreateNestedManyWithoutBarangInput
    transaksi_detail?: transaksi_detailCreateNestedManyWithoutBarangInput
  }

  export type barangUncheckedCreateWithoutOrder_barang_detailInput = {
    id: string
    category_vehicle_id: string
    name_barang: string
    description_barang?: string | null
    price: Decimal | DecimalJsLike | number | string
    point?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    inventory?: inventoryUncheckedCreateNestedManyWithoutBarangInput
    transaksi_detail?: transaksi_detailUncheckedCreateNestedManyWithoutBarangInput
  }

  export type barangCreateOrConnectWithoutOrder_barang_detailInput = {
    where: barangWhereUniqueInput
    create: XOR<barangCreateWithoutOrder_barang_detailInput, barangUncheckedCreateWithoutOrder_barang_detailInput>
  }

  export type order_barangCreateWithoutOrder_barang_detailInput = {
    id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    warehouse_order_barang_from_warehouse_idTowarehouse: warehouseCreateNestedOneWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput
    warehouse_order_barang_to_warehouse_idTowarehouse: warehouseCreateNestedOneWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput
  }

  export type order_barangUncheckedCreateWithoutOrder_barang_detailInput = {
    id: string
    from_warehouse_id: string
    to_warehouse_id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type order_barangCreateOrConnectWithoutOrder_barang_detailInput = {
    where: order_barangWhereUniqueInput
    create: XOR<order_barangCreateWithoutOrder_barang_detailInput, order_barangUncheckedCreateWithoutOrder_barang_detailInput>
  }

  export type barangUpsertWithoutOrder_barang_detailInput = {
    update: XOR<barangUpdateWithoutOrder_barang_detailInput, barangUncheckedUpdateWithoutOrder_barang_detailInput>
    create: XOR<barangCreateWithoutOrder_barang_detailInput, barangUncheckedCreateWithoutOrder_barang_detailInput>
    where?: barangWhereInput
  }

  export type barangUpdateToOneWithWhereWithoutOrder_barang_detailInput = {
    where?: barangWhereInput
    data: XOR<barangUpdateWithoutOrder_barang_detailInput, barangUncheckedUpdateWithoutOrder_barang_detailInput>
  }

  export type barangUpdateWithoutOrder_barang_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_barang?: StringFieldUpdateOperationsInput | string
    description_barang?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicle_category?: vehicle_categoryUpdateOneRequiredWithoutBarangNestedInput
    inventory?: inventoryUpdateManyWithoutBarangNestedInput
    transaksi_detail?: transaksi_detailUpdateManyWithoutBarangNestedInput
  }

  export type barangUncheckedUpdateWithoutOrder_barang_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_vehicle_id?: StringFieldUpdateOperationsInput | string
    name_barang?: StringFieldUpdateOperationsInput | string
    description_barang?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventory?: inventoryUncheckedUpdateManyWithoutBarangNestedInput
    transaksi_detail?: transaksi_detailUncheckedUpdateManyWithoutBarangNestedInput
  }

  export type order_barangUpsertWithoutOrder_barang_detailInput = {
    update: XOR<order_barangUpdateWithoutOrder_barang_detailInput, order_barangUncheckedUpdateWithoutOrder_barang_detailInput>
    create: XOR<order_barangCreateWithoutOrder_barang_detailInput, order_barangUncheckedCreateWithoutOrder_barang_detailInput>
    where?: order_barangWhereInput
  }

  export type order_barangUpdateToOneWithWhereWithoutOrder_barang_detailInput = {
    where?: order_barangWhereInput
    data: XOR<order_barangUpdateWithoutOrder_barang_detailInput, order_barangUncheckedUpdateWithoutOrder_barang_detailInput>
  }

  export type order_barangUpdateWithoutOrder_barang_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse_order_barang_from_warehouse_idTowarehouse?: warehouseUpdateOneRequiredWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseNestedInput
    warehouse_order_barang_to_warehouse_idTowarehouse?: warehouseUpdateOneRequiredWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseNestedInput
  }

  export type order_barangUncheckedUpdateWithoutOrder_barang_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_warehouse_id?: StringFieldUpdateOperationsInput | string
    to_warehouse_id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type employeeCreateWithoutStatusInput = {
    id: string
    name: string
    point?: number | null
    address?: string | null
    phone_number?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    mekanik?: mekanikCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutStatusInput = {
    id: string
    name: string
    point?: number | null
    address?: string | null
    phone_number?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    mekanik?: mekanikUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutStatusInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutStatusInput, employeeUncheckedCreateWithoutStatusInput>
  }

  export type employeeCreateManyStatusInputEnvelope = {
    data: employeeCreateManyStatusInput | employeeCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutStatusInput = {
    id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    transaksi?: transaksiCreateNestedManyWithoutUsersInput
    member: memberCreateNestedOneWithoutUsersInput
    vehicle_merk: vehicle_merkCreateNestedOneWithoutUsersInput
    vehicle_year: vehicle_yearCreateNestedOneWithoutUsersInput
    vehicle_type: vehicle_typeCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutStatusInput = {
    id: string
    member_id: string
    vehicle_year_id: string
    vehicle_merk_id: string
    vehicle_type_id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    transaksi?: transaksiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutStatusInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutStatusInput, usersUncheckedCreateWithoutStatusInput>
  }

  export type usersCreateManyStatusInputEnvelope = {
    data: usersCreateManyStatusInput | usersCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type employeeUpsertWithWhereUniqueWithoutStatusInput = {
    where: employeeWhereUniqueInput
    update: XOR<employeeUpdateWithoutStatusInput, employeeUncheckedUpdateWithoutStatusInput>
    create: XOR<employeeCreateWithoutStatusInput, employeeUncheckedCreateWithoutStatusInput>
  }

  export type employeeUpdateWithWhereUniqueWithoutStatusInput = {
    where: employeeWhereUniqueInput
    data: XOR<employeeUpdateWithoutStatusInput, employeeUncheckedUpdateWithoutStatusInput>
  }

  export type employeeUpdateManyWithWhereWithoutStatusInput = {
    where: employeeScalarWhereInput
    data: XOR<employeeUpdateManyMutationInput, employeeUncheckedUpdateManyWithoutStatusInput>
  }

  export type employeeScalarWhereInput = {
    AND?: employeeScalarWhereInput | employeeScalarWhereInput[]
    OR?: employeeScalarWhereInput[]
    NOT?: employeeScalarWhereInput | employeeScalarWhereInput[]
    id?: StringFilter<"employee"> | string
    status_id?: StringFilter<"employee"> | string
    name?: StringFilter<"employee"> | string
    point?: IntNullableFilter<"employee"> | number | null
    address?: StringNullableFilter<"employee"> | string | null
    phone_number?: StringNullableFilter<"employee"> | string | null
    createdAt?: DateTimeNullableFilter<"employee"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"employee"> | Date | string | null
  }

  export type usersUpsertWithWhereUniqueWithoutStatusInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutStatusInput, usersUncheckedUpdateWithoutStatusInput>
    create: XOR<usersCreateWithoutStatusInput, usersUncheckedCreateWithoutStatusInput>
  }

  export type usersUpdateWithWhereUniqueWithoutStatusInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutStatusInput, usersUncheckedUpdateWithoutStatusInput>
  }

  export type usersUpdateManyWithWhereWithoutStatusInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutStatusInput>
  }

  export type mekanikCreateWithoutTransaksiInput = {
    id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employee: employeeCreateNestedOneWithoutMekanikInput
    warehouse: warehouseCreateNestedOneWithoutMekanikInput
  }

  export type mekanikUncheckedCreateWithoutTransaksiInput = {
    id: string
    employee_id: string
    warehouse_id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type mekanikCreateOrConnectWithoutTransaksiInput = {
    where: mekanikWhereUniqueInput
    create: XOR<mekanikCreateWithoutTransaksiInput, mekanikUncheckedCreateWithoutTransaksiInput>
  }

  export type usersCreateWithoutTransaksiInput = {
    id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    member: memberCreateNestedOneWithoutUsersInput
    status: statusCreateNestedOneWithoutUsersInput
    vehicle_merk: vehicle_merkCreateNestedOneWithoutUsersInput
    vehicle_year: vehicle_yearCreateNestedOneWithoutUsersInput
    vehicle_type: vehicle_typeCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTransaksiInput = {
    id: string
    status_id: string
    member_id: string
    vehicle_year_id: string
    vehicle_merk_id: string
    vehicle_type_id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type usersCreateOrConnectWithoutTransaksiInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTransaksiInput, usersUncheckedCreateWithoutTransaksiInput>
  }

  export type warehouseCreateWithoutTransaksiInput = {
    id: string
    name_warehouse: string
    username: string
    password: string
    warehouse_address: string
    phone_number_warehouse?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    mekanik?: mekanikCreateNestedManyWithoutWarehouseInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangCreateNestedManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangCreateNestedManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput
    level: levelCreateNestedOneWithoutWarehouseInput
    warehouse_inventory?: warehouse_inventoryCreateNestedManyWithoutWarehouseInput
  }

  export type warehouseUncheckedCreateWithoutTransaksiInput = {
    id: string
    level_id: string
    name_warehouse: string
    username: string
    password: string
    warehouse_address: string
    phone_number_warehouse?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    mekanik?: mekanikUncheckedCreateNestedManyWithoutWarehouseInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangUncheckedCreateNestedManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangUncheckedCreateNestedManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput
    warehouse_inventory?: warehouse_inventoryUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type warehouseCreateOrConnectWithoutTransaksiInput = {
    where: warehouseWhereUniqueInput
    create: XOR<warehouseCreateWithoutTransaksiInput, warehouseUncheckedCreateWithoutTransaksiInput>
  }

  export type transaksi_detailCreateWithoutTransaksiInput = {
    id: string
    qty: number
    sub_total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    barang: barangCreateNestedOneWithoutTransaksi_detailInput
  }

  export type transaksi_detailUncheckedCreateWithoutTransaksiInput = {
    id: string
    barang_id: string
    qty: number
    sub_total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type transaksi_detailCreateOrConnectWithoutTransaksiInput = {
    where: transaksi_detailWhereUniqueInput
    create: XOR<transaksi_detailCreateWithoutTransaksiInput, transaksi_detailUncheckedCreateWithoutTransaksiInput>
  }

  export type transaksi_detailCreateManyTransaksiInputEnvelope = {
    data: transaksi_detailCreateManyTransaksiInput | transaksi_detailCreateManyTransaksiInput[]
    skipDuplicates?: boolean
  }

  export type mekanikUpsertWithoutTransaksiInput = {
    update: XOR<mekanikUpdateWithoutTransaksiInput, mekanikUncheckedUpdateWithoutTransaksiInput>
    create: XOR<mekanikCreateWithoutTransaksiInput, mekanikUncheckedCreateWithoutTransaksiInput>
    where?: mekanikWhereInput
  }

  export type mekanikUpdateToOneWithWhereWithoutTransaksiInput = {
    where?: mekanikWhereInput
    data: XOR<mekanikUpdateWithoutTransaksiInput, mekanikUncheckedUpdateWithoutTransaksiInput>
  }

  export type mekanikUpdateWithoutTransaksiInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: employeeUpdateOneRequiredWithoutMekanikNestedInput
    warehouse?: warehouseUpdateOneRequiredWithoutMekanikNestedInput
  }

  export type mekanikUncheckedUpdateWithoutTransaksiInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    warehouse_id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUpsertWithoutTransaksiInput = {
    update: XOR<usersUpdateWithoutTransaksiInput, usersUncheckedUpdateWithoutTransaksiInput>
    create: XOR<usersCreateWithoutTransaksiInput, usersUncheckedCreateWithoutTransaksiInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTransaksiInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTransaksiInput, usersUncheckedUpdateWithoutTransaksiInput>
  }

  export type usersUpdateWithoutTransaksiInput = {
    id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    member?: memberUpdateOneRequiredWithoutUsersNestedInput
    status?: statusUpdateOneRequiredWithoutUsersNestedInput
    vehicle_merk?: vehicle_merkUpdateOneRequiredWithoutUsersNestedInput
    vehicle_year?: vehicle_yearUpdateOneRequiredWithoutUsersNestedInput
    vehicle_type?: vehicle_typeUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTransaksiInput = {
    id?: StringFieldUpdateOperationsInput | string
    status_id?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
    vehicle_year_id?: StringFieldUpdateOperationsInput | string
    vehicle_merk_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type warehouseUpsertWithoutTransaksiInput = {
    update: XOR<warehouseUpdateWithoutTransaksiInput, warehouseUncheckedUpdateWithoutTransaksiInput>
    create: XOR<warehouseCreateWithoutTransaksiInput, warehouseUncheckedCreateWithoutTransaksiInput>
    where?: warehouseWhereInput
  }

  export type warehouseUpdateToOneWithWhereWithoutTransaksiInput = {
    where?: warehouseWhereInput
    data: XOR<warehouseUpdateWithoutTransaksiInput, warehouseUncheckedUpdateWithoutTransaksiInput>
  }

  export type warehouseUpdateWithoutTransaksiInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_warehouse?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    warehouse_address?: StringFieldUpdateOperationsInput | string
    phone_number_warehouse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mekanik?: mekanikUpdateManyWithoutWarehouseNestedInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangUpdateManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseNestedInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangUpdateManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseNestedInput
    level?: levelUpdateOneRequiredWithoutWarehouseNestedInput
    warehouse_inventory?: warehouse_inventoryUpdateManyWithoutWarehouseNestedInput
  }

  export type warehouseUncheckedUpdateWithoutTransaksiInput = {
    id?: StringFieldUpdateOperationsInput | string
    level_id?: StringFieldUpdateOperationsInput | string
    name_warehouse?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    warehouse_address?: StringFieldUpdateOperationsInput | string
    phone_number_warehouse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mekanik?: mekanikUncheckedUpdateManyWithoutWarehouseNestedInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangUncheckedUpdateManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseNestedInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangUncheckedUpdateManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseNestedInput
    warehouse_inventory?: warehouse_inventoryUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type transaksi_detailUpsertWithWhereUniqueWithoutTransaksiInput = {
    where: transaksi_detailWhereUniqueInput
    update: XOR<transaksi_detailUpdateWithoutTransaksiInput, transaksi_detailUncheckedUpdateWithoutTransaksiInput>
    create: XOR<transaksi_detailCreateWithoutTransaksiInput, transaksi_detailUncheckedCreateWithoutTransaksiInput>
  }

  export type transaksi_detailUpdateWithWhereUniqueWithoutTransaksiInput = {
    where: transaksi_detailWhereUniqueInput
    data: XOR<transaksi_detailUpdateWithoutTransaksiInput, transaksi_detailUncheckedUpdateWithoutTransaksiInput>
  }

  export type transaksi_detailUpdateManyWithWhereWithoutTransaksiInput = {
    where: transaksi_detailScalarWhereInput
    data: XOR<transaksi_detailUpdateManyMutationInput, transaksi_detailUncheckedUpdateManyWithoutTransaksiInput>
  }

  export type barangCreateWithoutTransaksi_detailInput = {
    id: string
    name_barang: string
    description_barang?: string | null
    price: Decimal | DecimalJsLike | number | string
    point?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    vehicle_category: vehicle_categoryCreateNestedOneWithoutBarangInput
    inventory?: inventoryCreateNestedManyWithoutBarangInput
    order_barang_detail?: order_barang_detailCreateNestedManyWithoutBarangInput
  }

  export type barangUncheckedCreateWithoutTransaksi_detailInput = {
    id: string
    category_vehicle_id: string
    name_barang: string
    description_barang?: string | null
    price: Decimal | DecimalJsLike | number | string
    point?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    inventory?: inventoryUncheckedCreateNestedManyWithoutBarangInput
    order_barang_detail?: order_barang_detailUncheckedCreateNestedManyWithoutBarangInput
  }

  export type barangCreateOrConnectWithoutTransaksi_detailInput = {
    where: barangWhereUniqueInput
    create: XOR<barangCreateWithoutTransaksi_detailInput, barangUncheckedCreateWithoutTransaksi_detailInput>
  }

  export type transaksiCreateWithoutTransaksi_detailInput = {
    id: string
    point?: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    mekanik: mekanikCreateNestedOneWithoutTransaksiInput
    users: usersCreateNestedOneWithoutTransaksiInput
    warehouse: warehouseCreateNestedOneWithoutTransaksiInput
  }

  export type transaksiUncheckedCreateWithoutTransaksi_detailInput = {
    id: string
    users_id: string
    mekanik_id: string
    warehouse_id: string
    point?: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type transaksiCreateOrConnectWithoutTransaksi_detailInput = {
    where: transaksiWhereUniqueInput
    create: XOR<transaksiCreateWithoutTransaksi_detailInput, transaksiUncheckedCreateWithoutTransaksi_detailInput>
  }

  export type barangUpsertWithoutTransaksi_detailInput = {
    update: XOR<barangUpdateWithoutTransaksi_detailInput, barangUncheckedUpdateWithoutTransaksi_detailInput>
    create: XOR<barangCreateWithoutTransaksi_detailInput, barangUncheckedCreateWithoutTransaksi_detailInput>
    where?: barangWhereInput
  }

  export type barangUpdateToOneWithWhereWithoutTransaksi_detailInput = {
    where?: barangWhereInput
    data: XOR<barangUpdateWithoutTransaksi_detailInput, barangUncheckedUpdateWithoutTransaksi_detailInput>
  }

  export type barangUpdateWithoutTransaksi_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_barang?: StringFieldUpdateOperationsInput | string
    description_barang?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicle_category?: vehicle_categoryUpdateOneRequiredWithoutBarangNestedInput
    inventory?: inventoryUpdateManyWithoutBarangNestedInput
    order_barang_detail?: order_barang_detailUpdateManyWithoutBarangNestedInput
  }

  export type barangUncheckedUpdateWithoutTransaksi_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_vehicle_id?: StringFieldUpdateOperationsInput | string
    name_barang?: StringFieldUpdateOperationsInput | string
    description_barang?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventory?: inventoryUncheckedUpdateManyWithoutBarangNestedInput
    order_barang_detail?: order_barang_detailUncheckedUpdateManyWithoutBarangNestedInput
  }

  export type transaksiUpsertWithoutTransaksi_detailInput = {
    update: XOR<transaksiUpdateWithoutTransaksi_detailInput, transaksiUncheckedUpdateWithoutTransaksi_detailInput>
    create: XOR<transaksiCreateWithoutTransaksi_detailInput, transaksiUncheckedCreateWithoutTransaksi_detailInput>
    where?: transaksiWhereInput
  }

  export type transaksiUpdateToOneWithWhereWithoutTransaksi_detailInput = {
    where?: transaksiWhereInput
    data: XOR<transaksiUpdateWithoutTransaksi_detailInput, transaksiUncheckedUpdateWithoutTransaksi_detailInput>
  }

  export type transaksiUpdateWithoutTransaksi_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mekanik?: mekanikUpdateOneRequiredWithoutTransaksiNestedInput
    users?: usersUpdateOneRequiredWithoutTransaksiNestedInput
    warehouse?: warehouseUpdateOneRequiredWithoutTransaksiNestedInput
  }

  export type transaksiUncheckedUpdateWithoutTransaksi_detailInput = {
    id?: StringFieldUpdateOperationsInput | string
    users_id?: StringFieldUpdateOperationsInput | string
    mekanik_id?: StringFieldUpdateOperationsInput | string
    warehouse_id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksiCreateWithoutUsersInput = {
    id: string
    point?: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    mekanik: mekanikCreateNestedOneWithoutTransaksiInput
    warehouse: warehouseCreateNestedOneWithoutTransaksiInput
    transaksi_detail?: transaksi_detailCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiUncheckedCreateWithoutUsersInput = {
    id: string
    mekanik_id: string
    warehouse_id: string
    point?: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    transaksi_detail?: transaksi_detailUncheckedCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiCreateOrConnectWithoutUsersInput = {
    where: transaksiWhereUniqueInput
    create: XOR<transaksiCreateWithoutUsersInput, transaksiUncheckedCreateWithoutUsersInput>
  }

  export type transaksiCreateManyUsersInputEnvelope = {
    data: transaksiCreateManyUsersInput | transaksiCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type memberCreateWithoutUsersInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type memberUncheckedCreateWithoutUsersInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type memberCreateOrConnectWithoutUsersInput = {
    where: memberWhereUniqueInput
    create: XOR<memberCreateWithoutUsersInput, memberUncheckedCreateWithoutUsersInput>
  }

  export type statusCreateWithoutUsersInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employee?: employeeCreateNestedManyWithoutStatusInput
  }

  export type statusUncheckedCreateWithoutUsersInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employee?: employeeUncheckedCreateNestedManyWithoutStatusInput
  }

  export type statusCreateOrConnectWithoutUsersInput = {
    where: statusWhereUniqueInput
    create: XOR<statusCreateWithoutUsersInput, statusUncheckedCreateWithoutUsersInput>
  }

  export type vehicle_merkCreateWithoutUsersInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type vehicle_merkUncheckedCreateWithoutUsersInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type vehicle_merkCreateOrConnectWithoutUsersInput = {
    where: vehicle_merkWhereUniqueInput
    create: XOR<vehicle_merkCreateWithoutUsersInput, vehicle_merkUncheckedCreateWithoutUsersInput>
  }

  export type vehicle_yearCreateWithoutUsersInput = {
    id: string
    year: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type vehicle_yearUncheckedCreateWithoutUsersInput = {
    id: string
    year: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type vehicle_yearCreateOrConnectWithoutUsersInput = {
    where: vehicle_yearWhereUniqueInput
    create: XOR<vehicle_yearCreateWithoutUsersInput, vehicle_yearUncheckedCreateWithoutUsersInput>
  }

  export type vehicle_typeCreateWithoutUsersInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    vehicle_category: vehicle_categoryCreateNestedOneWithoutVehicle_typeInput
  }

  export type vehicle_typeUncheckedCreateWithoutUsersInput = {
    id: string
    vehicle_category_id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type vehicle_typeCreateOrConnectWithoutUsersInput = {
    where: vehicle_typeWhereUniqueInput
    create: XOR<vehicle_typeCreateWithoutUsersInput, vehicle_typeUncheckedCreateWithoutUsersInput>
  }

  export type transaksiUpsertWithWhereUniqueWithoutUsersInput = {
    where: transaksiWhereUniqueInput
    update: XOR<transaksiUpdateWithoutUsersInput, transaksiUncheckedUpdateWithoutUsersInput>
    create: XOR<transaksiCreateWithoutUsersInput, transaksiUncheckedCreateWithoutUsersInput>
  }

  export type transaksiUpdateWithWhereUniqueWithoutUsersInput = {
    where: transaksiWhereUniqueInput
    data: XOR<transaksiUpdateWithoutUsersInput, transaksiUncheckedUpdateWithoutUsersInput>
  }

  export type transaksiUpdateManyWithWhereWithoutUsersInput = {
    where: transaksiScalarWhereInput
    data: XOR<transaksiUpdateManyMutationInput, transaksiUncheckedUpdateManyWithoutUsersInput>
  }

  export type memberUpsertWithoutUsersInput = {
    update: XOR<memberUpdateWithoutUsersInput, memberUncheckedUpdateWithoutUsersInput>
    create: XOR<memberCreateWithoutUsersInput, memberUncheckedCreateWithoutUsersInput>
    where?: memberWhereInput
  }

  export type memberUpdateToOneWithWhereWithoutUsersInput = {
    where?: memberWhereInput
    data: XOR<memberUpdateWithoutUsersInput, memberUncheckedUpdateWithoutUsersInput>
  }

  export type memberUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type memberUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type statusUpsertWithoutUsersInput = {
    update: XOR<statusUpdateWithoutUsersInput, statusUncheckedUpdateWithoutUsersInput>
    create: XOR<statusCreateWithoutUsersInput, statusUncheckedCreateWithoutUsersInput>
    where?: statusWhereInput
  }

  export type statusUpdateToOneWithWhereWithoutUsersInput = {
    where?: statusWhereInput
    data: XOR<statusUpdateWithoutUsersInput, statusUncheckedUpdateWithoutUsersInput>
  }

  export type statusUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: employeeUpdateManyWithoutStatusNestedInput
  }

  export type statusUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: employeeUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type vehicle_merkUpsertWithoutUsersInput = {
    update: XOR<vehicle_merkUpdateWithoutUsersInput, vehicle_merkUncheckedUpdateWithoutUsersInput>
    create: XOR<vehicle_merkCreateWithoutUsersInput, vehicle_merkUncheckedCreateWithoutUsersInput>
    where?: vehicle_merkWhereInput
  }

  export type vehicle_merkUpdateToOneWithWhereWithoutUsersInput = {
    where?: vehicle_merkWhereInput
    data: XOR<vehicle_merkUpdateWithoutUsersInput, vehicle_merkUncheckedUpdateWithoutUsersInput>
  }

  export type vehicle_merkUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehicle_merkUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehicle_yearUpsertWithoutUsersInput = {
    update: XOR<vehicle_yearUpdateWithoutUsersInput, vehicle_yearUncheckedUpdateWithoutUsersInput>
    create: XOR<vehicle_yearCreateWithoutUsersInput, vehicle_yearUncheckedCreateWithoutUsersInput>
    where?: vehicle_yearWhereInput
  }

  export type vehicle_yearUpdateToOneWithWhereWithoutUsersInput = {
    where?: vehicle_yearWhereInput
    data: XOR<vehicle_yearUpdateWithoutUsersInput, vehicle_yearUncheckedUpdateWithoutUsersInput>
  }

  export type vehicle_yearUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehicle_yearUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehicle_typeUpsertWithoutUsersInput = {
    update: XOR<vehicle_typeUpdateWithoutUsersInput, vehicle_typeUncheckedUpdateWithoutUsersInput>
    create: XOR<vehicle_typeCreateWithoutUsersInput, vehicle_typeUncheckedCreateWithoutUsersInput>
    where?: vehicle_typeWhereInput
  }

  export type vehicle_typeUpdateToOneWithWhereWithoutUsersInput = {
    where?: vehicle_typeWhereInput
    data: XOR<vehicle_typeUpdateWithoutUsersInput, vehicle_typeUncheckedUpdateWithoutUsersInput>
  }

  export type vehicle_typeUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicle_category?: vehicle_categoryUpdateOneRequiredWithoutVehicle_typeNestedInput
  }

  export type vehicle_typeUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicle_category_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type barangCreateWithoutVehicle_categoryInput = {
    id: string
    name_barang: string
    description_barang?: string | null
    price: Decimal | DecimalJsLike | number | string
    point?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    inventory?: inventoryCreateNestedManyWithoutBarangInput
    order_barang_detail?: order_barang_detailCreateNestedManyWithoutBarangInput
    transaksi_detail?: transaksi_detailCreateNestedManyWithoutBarangInput
  }

  export type barangUncheckedCreateWithoutVehicle_categoryInput = {
    id: string
    name_barang: string
    description_barang?: string | null
    price: Decimal | DecimalJsLike | number | string
    point?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    inventory?: inventoryUncheckedCreateNestedManyWithoutBarangInput
    order_barang_detail?: order_barang_detailUncheckedCreateNestedManyWithoutBarangInput
    transaksi_detail?: transaksi_detailUncheckedCreateNestedManyWithoutBarangInput
  }

  export type barangCreateOrConnectWithoutVehicle_categoryInput = {
    where: barangWhereUniqueInput
    create: XOR<barangCreateWithoutVehicle_categoryInput, barangUncheckedCreateWithoutVehicle_categoryInput>
  }

  export type barangCreateManyVehicle_categoryInputEnvelope = {
    data: barangCreateManyVehicle_categoryInput | barangCreateManyVehicle_categoryInput[]
    skipDuplicates?: boolean
  }

  export type vehicle_typeCreateWithoutVehicle_categoryInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    users?: usersCreateNestedManyWithoutVehicle_typeInput
  }

  export type vehicle_typeUncheckedCreateWithoutVehicle_categoryInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    users?: usersUncheckedCreateNestedManyWithoutVehicle_typeInput
  }

  export type vehicle_typeCreateOrConnectWithoutVehicle_categoryInput = {
    where: vehicle_typeWhereUniqueInput
    create: XOR<vehicle_typeCreateWithoutVehicle_categoryInput, vehicle_typeUncheckedCreateWithoutVehicle_categoryInput>
  }

  export type vehicle_typeCreateManyVehicle_categoryInputEnvelope = {
    data: vehicle_typeCreateManyVehicle_categoryInput | vehicle_typeCreateManyVehicle_categoryInput[]
    skipDuplicates?: boolean
  }

  export type barangUpsertWithWhereUniqueWithoutVehicle_categoryInput = {
    where: barangWhereUniqueInput
    update: XOR<barangUpdateWithoutVehicle_categoryInput, barangUncheckedUpdateWithoutVehicle_categoryInput>
    create: XOR<barangCreateWithoutVehicle_categoryInput, barangUncheckedCreateWithoutVehicle_categoryInput>
  }

  export type barangUpdateWithWhereUniqueWithoutVehicle_categoryInput = {
    where: barangWhereUniqueInput
    data: XOR<barangUpdateWithoutVehicle_categoryInput, barangUncheckedUpdateWithoutVehicle_categoryInput>
  }

  export type barangUpdateManyWithWhereWithoutVehicle_categoryInput = {
    where: barangScalarWhereInput
    data: XOR<barangUpdateManyMutationInput, barangUncheckedUpdateManyWithoutVehicle_categoryInput>
  }

  export type barangScalarWhereInput = {
    AND?: barangScalarWhereInput | barangScalarWhereInput[]
    OR?: barangScalarWhereInput[]
    NOT?: barangScalarWhereInput | barangScalarWhereInput[]
    id?: StringFilter<"barang"> | string
    category_vehicle_id?: StringFilter<"barang"> | string
    name_barang?: StringFilter<"barang"> | string
    description_barang?: StringNullableFilter<"barang"> | string | null
    price?: DecimalFilter<"barang"> | Decimal | DecimalJsLike | number | string
    point?: IntNullableFilter<"barang"> | number | null
    createdAt?: DateTimeNullableFilter<"barang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"barang"> | Date | string | null
  }

  export type vehicle_typeUpsertWithWhereUniqueWithoutVehicle_categoryInput = {
    where: vehicle_typeWhereUniqueInput
    update: XOR<vehicle_typeUpdateWithoutVehicle_categoryInput, vehicle_typeUncheckedUpdateWithoutVehicle_categoryInput>
    create: XOR<vehicle_typeCreateWithoutVehicle_categoryInput, vehicle_typeUncheckedCreateWithoutVehicle_categoryInput>
  }

  export type vehicle_typeUpdateWithWhereUniqueWithoutVehicle_categoryInput = {
    where: vehicle_typeWhereUniqueInput
    data: XOR<vehicle_typeUpdateWithoutVehicle_categoryInput, vehicle_typeUncheckedUpdateWithoutVehicle_categoryInput>
  }

  export type vehicle_typeUpdateManyWithWhereWithoutVehicle_categoryInput = {
    where: vehicle_typeScalarWhereInput
    data: XOR<vehicle_typeUpdateManyMutationInput, vehicle_typeUncheckedUpdateManyWithoutVehicle_categoryInput>
  }

  export type vehicle_typeScalarWhereInput = {
    AND?: vehicle_typeScalarWhereInput | vehicle_typeScalarWhereInput[]
    OR?: vehicle_typeScalarWhereInput[]
    NOT?: vehicle_typeScalarWhereInput | vehicle_typeScalarWhereInput[]
    id?: StringFilter<"vehicle_type"> | string
    vehicle_category_id?: StringFilter<"vehicle_type"> | string
    name?: StringFilter<"vehicle_type"> | string
    createdAt?: DateTimeNullableFilter<"vehicle_type"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"vehicle_type"> | Date | string | null
  }

  export type usersCreateWithoutVehicle_merkInput = {
    id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    transaksi?: transaksiCreateNestedManyWithoutUsersInput
    member: memberCreateNestedOneWithoutUsersInput
    status: statusCreateNestedOneWithoutUsersInput
    vehicle_year: vehicle_yearCreateNestedOneWithoutUsersInput
    vehicle_type: vehicle_typeCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutVehicle_merkInput = {
    id: string
    status_id: string
    member_id: string
    vehicle_year_id: string
    vehicle_type_id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    transaksi?: transaksiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutVehicle_merkInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutVehicle_merkInput, usersUncheckedCreateWithoutVehicle_merkInput>
  }

  export type usersCreateManyVehicle_merkInputEnvelope = {
    data: usersCreateManyVehicle_merkInput | usersCreateManyVehicle_merkInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithWhereUniqueWithoutVehicle_merkInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutVehicle_merkInput, usersUncheckedUpdateWithoutVehicle_merkInput>
    create: XOR<usersCreateWithoutVehicle_merkInput, usersUncheckedCreateWithoutVehicle_merkInput>
  }

  export type usersUpdateWithWhereUniqueWithoutVehicle_merkInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutVehicle_merkInput, usersUncheckedUpdateWithoutVehicle_merkInput>
  }

  export type usersUpdateManyWithWhereWithoutVehicle_merkInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutVehicle_merkInput>
  }

  export type usersCreateWithoutVehicle_typeInput = {
    id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    transaksi?: transaksiCreateNestedManyWithoutUsersInput
    member: memberCreateNestedOneWithoutUsersInput
    status: statusCreateNestedOneWithoutUsersInput
    vehicle_merk: vehicle_merkCreateNestedOneWithoutUsersInput
    vehicle_year: vehicle_yearCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutVehicle_typeInput = {
    id: string
    status_id: string
    member_id: string
    vehicle_year_id: string
    vehicle_merk_id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    transaksi?: transaksiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutVehicle_typeInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutVehicle_typeInput, usersUncheckedCreateWithoutVehicle_typeInput>
  }

  export type usersCreateManyVehicle_typeInputEnvelope = {
    data: usersCreateManyVehicle_typeInput | usersCreateManyVehicle_typeInput[]
    skipDuplicates?: boolean
  }

  export type vehicle_categoryCreateWithoutVehicle_typeInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    barang?: barangCreateNestedManyWithoutVehicle_categoryInput
  }

  export type vehicle_categoryUncheckedCreateWithoutVehicle_typeInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    barang?: barangUncheckedCreateNestedManyWithoutVehicle_categoryInput
  }

  export type vehicle_categoryCreateOrConnectWithoutVehicle_typeInput = {
    where: vehicle_categoryWhereUniqueInput
    create: XOR<vehicle_categoryCreateWithoutVehicle_typeInput, vehicle_categoryUncheckedCreateWithoutVehicle_typeInput>
  }

  export type usersUpsertWithWhereUniqueWithoutVehicle_typeInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutVehicle_typeInput, usersUncheckedUpdateWithoutVehicle_typeInput>
    create: XOR<usersCreateWithoutVehicle_typeInput, usersUncheckedCreateWithoutVehicle_typeInput>
  }

  export type usersUpdateWithWhereUniqueWithoutVehicle_typeInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutVehicle_typeInput, usersUncheckedUpdateWithoutVehicle_typeInput>
  }

  export type usersUpdateManyWithWhereWithoutVehicle_typeInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutVehicle_typeInput>
  }

  export type vehicle_categoryUpsertWithoutVehicle_typeInput = {
    update: XOR<vehicle_categoryUpdateWithoutVehicle_typeInput, vehicle_categoryUncheckedUpdateWithoutVehicle_typeInput>
    create: XOR<vehicle_categoryCreateWithoutVehicle_typeInput, vehicle_categoryUncheckedCreateWithoutVehicle_typeInput>
    where?: vehicle_categoryWhereInput
  }

  export type vehicle_categoryUpdateToOneWithWhereWithoutVehicle_typeInput = {
    where?: vehicle_categoryWhereInput
    data: XOR<vehicle_categoryUpdateWithoutVehicle_typeInput, vehicle_categoryUncheckedUpdateWithoutVehicle_typeInput>
  }

  export type vehicle_categoryUpdateWithoutVehicle_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    barang?: barangUpdateManyWithoutVehicle_categoryNestedInput
  }

  export type vehicle_categoryUncheckedUpdateWithoutVehicle_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    barang?: barangUncheckedUpdateManyWithoutVehicle_categoryNestedInput
  }

  export type usersCreateWithoutVehicle_yearInput = {
    id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    transaksi?: transaksiCreateNestedManyWithoutUsersInput
    member: memberCreateNestedOneWithoutUsersInput
    status: statusCreateNestedOneWithoutUsersInput
    vehicle_merk: vehicle_merkCreateNestedOneWithoutUsersInput
    vehicle_type: vehicle_typeCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutVehicle_yearInput = {
    id: string
    status_id: string
    member_id: string
    vehicle_merk_id: string
    vehicle_type_id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    transaksi?: transaksiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutVehicle_yearInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutVehicle_yearInput, usersUncheckedCreateWithoutVehicle_yearInput>
  }

  export type usersCreateManyVehicle_yearInputEnvelope = {
    data: usersCreateManyVehicle_yearInput | usersCreateManyVehicle_yearInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithWhereUniqueWithoutVehicle_yearInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutVehicle_yearInput, usersUncheckedUpdateWithoutVehicle_yearInput>
    create: XOR<usersCreateWithoutVehicle_yearInput, usersUncheckedCreateWithoutVehicle_yearInput>
  }

  export type usersUpdateWithWhereUniqueWithoutVehicle_yearInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutVehicle_yearInput, usersUncheckedUpdateWithoutVehicle_yearInput>
  }

  export type usersUpdateManyWithWhereWithoutVehicle_yearInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutVehicle_yearInput>
  }

  export type mekanikCreateWithoutWarehouseInput = {
    id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    employee: employeeCreateNestedOneWithoutMekanikInput
    transaksi?: transaksiCreateNestedManyWithoutMekanikInput
  }

  export type mekanikUncheckedCreateWithoutWarehouseInput = {
    id: string
    employee_id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    transaksi?: transaksiUncheckedCreateNestedManyWithoutMekanikInput
  }

  export type mekanikCreateOrConnectWithoutWarehouseInput = {
    where: mekanikWhereUniqueInput
    create: XOR<mekanikCreateWithoutWarehouseInput, mekanikUncheckedCreateWithoutWarehouseInput>
  }

  export type mekanikCreateManyWarehouseInputEnvelope = {
    data: mekanikCreateManyWarehouseInput | mekanikCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type order_barangCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput = {
    id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    warehouse_order_barang_to_warehouse_idTowarehouse: warehouseCreateNestedOneWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseInput
    order_barang_detail?: order_barang_detailCreateNestedManyWithoutOrder_barangInput
  }

  export type order_barangUncheckedCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput = {
    id: string
    to_warehouse_id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    order_barang_detail?: order_barang_detailUncheckedCreateNestedManyWithoutOrder_barangInput
  }

  export type order_barangCreateOrConnectWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput = {
    where: order_barangWhereUniqueInput
    create: XOR<order_barangCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput, order_barangUncheckedCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput>
  }

  export type order_barangCreateManyWarehouse_order_barang_from_warehouse_idTowarehouseInputEnvelope = {
    data: order_barangCreateManyWarehouse_order_barang_from_warehouse_idTowarehouseInput | order_barangCreateManyWarehouse_order_barang_from_warehouse_idTowarehouseInput[]
    skipDuplicates?: boolean
  }

  export type order_barangCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput = {
    id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    warehouse_order_barang_from_warehouse_idTowarehouse: warehouseCreateNestedOneWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseInput
    order_barang_detail?: order_barang_detailCreateNestedManyWithoutOrder_barangInput
  }

  export type order_barangUncheckedCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput = {
    id: string
    from_warehouse_id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    order_barang_detail?: order_barang_detailUncheckedCreateNestedManyWithoutOrder_barangInput
  }

  export type order_barangCreateOrConnectWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput = {
    where: order_barangWhereUniqueInput
    create: XOR<order_barangCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput, order_barangUncheckedCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput>
  }

  export type order_barangCreateManyWarehouse_order_barang_to_warehouse_idTowarehouseInputEnvelope = {
    data: order_barangCreateManyWarehouse_order_barang_to_warehouse_idTowarehouseInput | order_barangCreateManyWarehouse_order_barang_to_warehouse_idTowarehouseInput[]
    skipDuplicates?: boolean
  }

  export type transaksiCreateWithoutWarehouseInput = {
    id: string
    point?: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    mekanik: mekanikCreateNestedOneWithoutTransaksiInput
    users: usersCreateNestedOneWithoutTransaksiInput
    transaksi_detail?: transaksi_detailCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiUncheckedCreateWithoutWarehouseInput = {
    id: string
    users_id: string
    mekanik_id: string
    point?: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    transaksi_detail?: transaksi_detailUncheckedCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiCreateOrConnectWithoutWarehouseInput = {
    where: transaksiWhereUniqueInput
    create: XOR<transaksiCreateWithoutWarehouseInput, transaksiUncheckedCreateWithoutWarehouseInput>
  }

  export type transaksiCreateManyWarehouseInputEnvelope = {
    data: transaksiCreateManyWarehouseInput | transaksiCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type levelCreateWithoutWarehouseInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type levelUncheckedCreateWithoutWarehouseInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type levelCreateOrConnectWithoutWarehouseInput = {
    where: levelWhereUniqueInput
    create: XOR<levelCreateWithoutWarehouseInput, levelUncheckedCreateWithoutWarehouseInput>
  }

  export type warehouse_inventoryCreateWithoutWarehouseInput = {
    id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    inventory?: inventoryCreateNestedManyWithoutWarehouse_inventoryInput
  }

  export type warehouse_inventoryUncheckedCreateWithoutWarehouseInput = {
    id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    inventory?: inventoryUncheckedCreateNestedManyWithoutWarehouse_inventoryInput
  }

  export type warehouse_inventoryCreateOrConnectWithoutWarehouseInput = {
    where: warehouse_inventoryWhereUniqueInput
    create: XOR<warehouse_inventoryCreateWithoutWarehouseInput, warehouse_inventoryUncheckedCreateWithoutWarehouseInput>
  }

  export type warehouse_inventoryCreateManyWarehouseInputEnvelope = {
    data: warehouse_inventoryCreateManyWarehouseInput | warehouse_inventoryCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type mekanikUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: mekanikWhereUniqueInput
    update: XOR<mekanikUpdateWithoutWarehouseInput, mekanikUncheckedUpdateWithoutWarehouseInput>
    create: XOR<mekanikCreateWithoutWarehouseInput, mekanikUncheckedCreateWithoutWarehouseInput>
  }

  export type mekanikUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: mekanikWhereUniqueInput
    data: XOR<mekanikUpdateWithoutWarehouseInput, mekanikUncheckedUpdateWithoutWarehouseInput>
  }

  export type mekanikUpdateManyWithWhereWithoutWarehouseInput = {
    where: mekanikScalarWhereInput
    data: XOR<mekanikUpdateManyMutationInput, mekanikUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type order_barangUpsertWithWhereUniqueWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput = {
    where: order_barangWhereUniqueInput
    update: XOR<order_barangUpdateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput, order_barangUncheckedUpdateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput>
    create: XOR<order_barangCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput, order_barangUncheckedCreateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput>
  }

  export type order_barangUpdateWithWhereUniqueWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput = {
    where: order_barangWhereUniqueInput
    data: XOR<order_barangUpdateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput, order_barangUncheckedUpdateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput>
  }

  export type order_barangUpdateManyWithWhereWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput = {
    where: order_barangScalarWhereInput
    data: XOR<order_barangUpdateManyMutationInput, order_barangUncheckedUpdateManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput>
  }

  export type order_barangScalarWhereInput = {
    AND?: order_barangScalarWhereInput | order_barangScalarWhereInput[]
    OR?: order_barangScalarWhereInput[]
    NOT?: order_barangScalarWhereInput | order_barangScalarWhereInput[]
    id?: StringFilter<"order_barang"> | string
    from_warehouse_id?: StringFilter<"order_barang"> | string
    to_warehouse_id?: StringFilter<"order_barang"> | string
    createdAt?: DateTimeNullableFilter<"order_barang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"order_barang"> | Date | string | null
  }

  export type order_barangUpsertWithWhereUniqueWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput = {
    where: order_barangWhereUniqueInput
    update: XOR<order_barangUpdateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput, order_barangUncheckedUpdateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput>
    create: XOR<order_barangCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput, order_barangUncheckedCreateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput>
  }

  export type order_barangUpdateWithWhereUniqueWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput = {
    where: order_barangWhereUniqueInput
    data: XOR<order_barangUpdateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput, order_barangUncheckedUpdateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput>
  }

  export type order_barangUpdateManyWithWhereWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput = {
    where: order_barangScalarWhereInput
    data: XOR<order_barangUpdateManyMutationInput, order_barangUncheckedUpdateManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput>
  }

  export type transaksiUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: transaksiWhereUniqueInput
    update: XOR<transaksiUpdateWithoutWarehouseInput, transaksiUncheckedUpdateWithoutWarehouseInput>
    create: XOR<transaksiCreateWithoutWarehouseInput, transaksiUncheckedCreateWithoutWarehouseInput>
  }

  export type transaksiUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: transaksiWhereUniqueInput
    data: XOR<transaksiUpdateWithoutWarehouseInput, transaksiUncheckedUpdateWithoutWarehouseInput>
  }

  export type transaksiUpdateManyWithWhereWithoutWarehouseInput = {
    where: transaksiScalarWhereInput
    data: XOR<transaksiUpdateManyMutationInput, transaksiUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type levelUpsertWithoutWarehouseInput = {
    update: XOR<levelUpdateWithoutWarehouseInput, levelUncheckedUpdateWithoutWarehouseInput>
    create: XOR<levelCreateWithoutWarehouseInput, levelUncheckedCreateWithoutWarehouseInput>
    where?: levelWhereInput
  }

  export type levelUpdateToOneWithWhereWithoutWarehouseInput = {
    where?: levelWhereInput
    data: XOR<levelUpdateWithoutWarehouseInput, levelUncheckedUpdateWithoutWarehouseInput>
  }

  export type levelUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type levelUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type warehouse_inventoryUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: warehouse_inventoryWhereUniqueInput
    update: XOR<warehouse_inventoryUpdateWithoutWarehouseInput, warehouse_inventoryUncheckedUpdateWithoutWarehouseInput>
    create: XOR<warehouse_inventoryCreateWithoutWarehouseInput, warehouse_inventoryUncheckedCreateWithoutWarehouseInput>
  }

  export type warehouse_inventoryUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: warehouse_inventoryWhereUniqueInput
    data: XOR<warehouse_inventoryUpdateWithoutWarehouseInput, warehouse_inventoryUncheckedUpdateWithoutWarehouseInput>
  }

  export type warehouse_inventoryUpdateManyWithWhereWithoutWarehouseInput = {
    where: warehouse_inventoryScalarWhereInput
    data: XOR<warehouse_inventoryUpdateManyMutationInput, warehouse_inventoryUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type warehouse_inventoryScalarWhereInput = {
    AND?: warehouse_inventoryScalarWhereInput | warehouse_inventoryScalarWhereInput[]
    OR?: warehouse_inventoryScalarWhereInput[]
    NOT?: warehouse_inventoryScalarWhereInput | warehouse_inventoryScalarWhereInput[]
    id?: StringFilter<"warehouse_inventory"> | string
    warehouse_id?: StringFilter<"warehouse_inventory"> | string
    createdAt?: DateTimeNullableFilter<"warehouse_inventory"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"warehouse_inventory"> | Date | string | null
  }

  export type inventoryCreateWithoutWarehouse_inventoryInput = {
    id: string
    qty?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    barang: barangCreateNestedOneWithoutInventoryInput
  }

  export type inventoryUncheckedCreateWithoutWarehouse_inventoryInput = {
    id: string
    barang_id: string
    qty?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type inventoryCreateOrConnectWithoutWarehouse_inventoryInput = {
    where: inventoryWhereUniqueInput
    create: XOR<inventoryCreateWithoutWarehouse_inventoryInput, inventoryUncheckedCreateWithoutWarehouse_inventoryInput>
  }

  export type inventoryCreateManyWarehouse_inventoryInputEnvelope = {
    data: inventoryCreateManyWarehouse_inventoryInput | inventoryCreateManyWarehouse_inventoryInput[]
    skipDuplicates?: boolean
  }

  export type warehouseCreateWithoutWarehouse_inventoryInput = {
    id: string
    name_warehouse: string
    username: string
    password: string
    warehouse_address: string
    phone_number_warehouse?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    mekanik?: mekanikCreateNestedManyWithoutWarehouseInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangCreateNestedManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangCreateNestedManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput
    transaksi?: transaksiCreateNestedManyWithoutWarehouseInput
    level: levelCreateNestedOneWithoutWarehouseInput
  }

  export type warehouseUncheckedCreateWithoutWarehouse_inventoryInput = {
    id: string
    level_id: string
    name_warehouse: string
    username: string
    password: string
    warehouse_address: string
    phone_number_warehouse?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    mekanik?: mekanikUncheckedCreateNestedManyWithoutWarehouseInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangUncheckedCreateNestedManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangUncheckedCreateNestedManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type warehouseCreateOrConnectWithoutWarehouse_inventoryInput = {
    where: warehouseWhereUniqueInput
    create: XOR<warehouseCreateWithoutWarehouse_inventoryInput, warehouseUncheckedCreateWithoutWarehouse_inventoryInput>
  }

  export type inventoryUpsertWithWhereUniqueWithoutWarehouse_inventoryInput = {
    where: inventoryWhereUniqueInput
    update: XOR<inventoryUpdateWithoutWarehouse_inventoryInput, inventoryUncheckedUpdateWithoutWarehouse_inventoryInput>
    create: XOR<inventoryCreateWithoutWarehouse_inventoryInput, inventoryUncheckedCreateWithoutWarehouse_inventoryInput>
  }

  export type inventoryUpdateWithWhereUniqueWithoutWarehouse_inventoryInput = {
    where: inventoryWhereUniqueInput
    data: XOR<inventoryUpdateWithoutWarehouse_inventoryInput, inventoryUncheckedUpdateWithoutWarehouse_inventoryInput>
  }

  export type inventoryUpdateManyWithWhereWithoutWarehouse_inventoryInput = {
    where: inventoryScalarWhereInput
    data: XOR<inventoryUpdateManyMutationInput, inventoryUncheckedUpdateManyWithoutWarehouse_inventoryInput>
  }

  export type warehouseUpsertWithoutWarehouse_inventoryInput = {
    update: XOR<warehouseUpdateWithoutWarehouse_inventoryInput, warehouseUncheckedUpdateWithoutWarehouse_inventoryInput>
    create: XOR<warehouseCreateWithoutWarehouse_inventoryInput, warehouseUncheckedCreateWithoutWarehouse_inventoryInput>
    where?: warehouseWhereInput
  }

  export type warehouseUpdateToOneWithWhereWithoutWarehouse_inventoryInput = {
    where?: warehouseWhereInput
    data: XOR<warehouseUpdateWithoutWarehouse_inventoryInput, warehouseUncheckedUpdateWithoutWarehouse_inventoryInput>
  }

  export type warehouseUpdateWithoutWarehouse_inventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_warehouse?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    warehouse_address?: StringFieldUpdateOperationsInput | string
    phone_number_warehouse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mekanik?: mekanikUpdateManyWithoutWarehouseNestedInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangUpdateManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseNestedInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangUpdateManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseNestedInput
    transaksi?: transaksiUpdateManyWithoutWarehouseNestedInput
    level?: levelUpdateOneRequiredWithoutWarehouseNestedInput
  }

  export type warehouseUncheckedUpdateWithoutWarehouse_inventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    level_id?: StringFieldUpdateOperationsInput | string
    name_warehouse?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    warehouse_address?: StringFieldUpdateOperationsInput | string
    phone_number_warehouse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mekanik?: mekanikUncheckedUpdateManyWithoutWarehouseNestedInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangUncheckedUpdateManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseNestedInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangUncheckedUpdateManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type inventoryCreateManyBarangInput = {
    id: string
    warehouse_inventory_id: string
    qty?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type order_barang_detailCreateManyBarangInput = {
    id: string
    order_barang_id: string
    qty: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type transaksi_detailCreateManyBarangInput = {
    id: string
    transaksi_id: string
    qty: number
    sub_total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type inventoryUpdateWithoutBarangInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse_inventory?: warehouse_inventoryUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type inventoryUncheckedUpdateWithoutBarangInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouse_inventory_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inventoryUncheckedUpdateManyWithoutBarangInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouse_inventory_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type order_barang_detailUpdateWithoutBarangInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order_barang?: order_barangUpdateOneRequiredWithoutOrder_barang_detailNestedInput
  }

  export type order_barang_detailUncheckedUpdateWithoutBarangInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_barang_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type order_barang_detailUncheckedUpdateManyWithoutBarangInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_barang_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksi_detailUpdateWithoutBarangInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    sub_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUpdateOneRequiredWithoutTransaksi_detailNestedInput
  }

  export type transaksi_detailUncheckedUpdateWithoutBarangInput = {
    id?: StringFieldUpdateOperationsInput | string
    transaksi_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    sub_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksi_detailUncheckedUpdateManyWithoutBarangInput = {
    id?: StringFieldUpdateOperationsInput | string
    transaksi_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    sub_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mekanikCreateManyEmployeeInput = {
    id: string
    warehouse_id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type mekanikUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse?: warehouseUpdateOneRequiredWithoutMekanikNestedInput
    transaksi?: transaksiUpdateManyWithoutMekanikNestedInput
  }

  export type mekanikUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouse_id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUncheckedUpdateManyWithoutMekanikNestedInput
  }

  export type mekanikUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouse_id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type warehouseCreateManyLevelInput = {
    id: string
    name_warehouse: string
    username: string
    password: string
    warehouse_address: string
    phone_number_warehouse?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type warehouseUpdateWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_warehouse?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    warehouse_address?: StringFieldUpdateOperationsInput | string
    phone_number_warehouse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mekanik?: mekanikUpdateManyWithoutWarehouseNestedInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangUpdateManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseNestedInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangUpdateManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseNestedInput
    transaksi?: transaksiUpdateManyWithoutWarehouseNestedInput
    warehouse_inventory?: warehouse_inventoryUpdateManyWithoutWarehouseNestedInput
  }

  export type warehouseUncheckedUpdateWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_warehouse?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    warehouse_address?: StringFieldUpdateOperationsInput | string
    phone_number_warehouse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mekanik?: mekanikUncheckedUpdateManyWithoutWarehouseNestedInput
    order_barang_order_barang_from_warehouse_idTowarehouse?: order_barangUncheckedUpdateManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseNestedInput
    order_barang_order_barang_to_warehouse_idTowarehouse?: order_barangUncheckedUpdateManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutWarehouseNestedInput
    warehouse_inventory?: warehouse_inventoryUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type warehouseUncheckedUpdateManyWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_warehouse?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    warehouse_address?: StringFieldUpdateOperationsInput | string
    phone_number_warehouse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksiCreateManyMekanikInput = {
    id: string
    users_id: string
    warehouse_id: string
    point?: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type transaksiUpdateWithoutMekanikInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutTransaksiNestedInput
    warehouse?: warehouseUpdateOneRequiredWithoutTransaksiNestedInput
    transaksi_detail?: transaksi_detailUpdateManyWithoutTransaksiNestedInput
  }

  export type transaksiUncheckedUpdateWithoutMekanikInput = {
    id?: StringFieldUpdateOperationsInput | string
    users_id?: StringFieldUpdateOperationsInput | string
    warehouse_id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi_detail?: transaksi_detailUncheckedUpdateManyWithoutTransaksiNestedInput
  }

  export type transaksiUncheckedUpdateManyWithoutMekanikInput = {
    id?: StringFieldUpdateOperationsInput | string
    users_id?: StringFieldUpdateOperationsInput | string
    warehouse_id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateManyMemberInput = {
    id: string
    status_id: string
    vehicle_year_id: string
    vehicle_merk_id: string
    vehicle_type_id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type usersUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUpdateManyWithoutUsersNestedInput
    status?: statusUpdateOneRequiredWithoutUsersNestedInput
    vehicle_merk?: vehicle_merkUpdateOneRequiredWithoutUsersNestedInput
    vehicle_year?: vehicle_yearUpdateOneRequiredWithoutUsersNestedInput
    vehicle_type?: vehicle_typeUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    status_id?: StringFieldUpdateOperationsInput | string
    vehicle_year_id?: StringFieldUpdateOperationsInput | string
    vehicle_merk_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    status_id?: StringFieldUpdateOperationsInput | string
    vehicle_year_id?: StringFieldUpdateOperationsInput | string
    vehicle_merk_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type order_barang_detailCreateManyOrder_barangInput = {
    id: string
    barang_id: string
    qty: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type order_barang_detailUpdateWithoutOrder_barangInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    barang?: barangUpdateOneRequiredWithoutOrder_barang_detailNestedInput
  }

  export type order_barang_detailUncheckedUpdateWithoutOrder_barangInput = {
    id?: StringFieldUpdateOperationsInput | string
    barang_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type order_barang_detailUncheckedUpdateManyWithoutOrder_barangInput = {
    id?: StringFieldUpdateOperationsInput | string
    barang_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type employeeCreateManyStatusInput = {
    id: string
    name: string
    point?: number | null
    address?: string | null
    phone_number?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type usersCreateManyStatusInput = {
    id: string
    member_id: string
    vehicle_year_id: string
    vehicle_merk_id: string
    vehicle_type_id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type employeeUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mekanik?: mekanikUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mekanik?: mekanikUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateManyWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUpdateManyWithoutUsersNestedInput
    member?: memberUpdateOneRequiredWithoutUsersNestedInput
    vehicle_merk?: vehicle_merkUpdateOneRequiredWithoutUsersNestedInput
    vehicle_year?: vehicle_yearUpdateOneRequiredWithoutUsersNestedInput
    vehicle_type?: vehicle_typeUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
    vehicle_year_id?: StringFieldUpdateOperationsInput | string
    vehicle_merk_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
    vehicle_year_id?: StringFieldUpdateOperationsInput | string
    vehicle_merk_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksi_detailCreateManyTransaksiInput = {
    id: string
    barang_id: string
    qty: number
    sub_total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type transaksi_detailUpdateWithoutTransaksiInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    sub_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    barang?: barangUpdateOneRequiredWithoutTransaksi_detailNestedInput
  }

  export type transaksi_detailUncheckedUpdateWithoutTransaksiInput = {
    id?: StringFieldUpdateOperationsInput | string
    barang_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    sub_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksi_detailUncheckedUpdateManyWithoutTransaksiInput = {
    id?: StringFieldUpdateOperationsInput | string
    barang_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    sub_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksiCreateManyUsersInput = {
    id: string
    mekanik_id: string
    warehouse_id: string
    point?: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type transaksiUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mekanik?: mekanikUpdateOneRequiredWithoutTransaksiNestedInput
    warehouse?: warehouseUpdateOneRequiredWithoutTransaksiNestedInput
    transaksi_detail?: transaksi_detailUpdateManyWithoutTransaksiNestedInput
  }

  export type transaksiUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    mekanik_id?: StringFieldUpdateOperationsInput | string
    warehouse_id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi_detail?: transaksi_detailUncheckedUpdateManyWithoutTransaksiNestedInput
  }

  export type transaksiUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    mekanik_id?: StringFieldUpdateOperationsInput | string
    warehouse_id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type barangCreateManyVehicle_categoryInput = {
    id: string
    name_barang: string
    description_barang?: string | null
    price: Decimal | DecimalJsLike | number | string
    point?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type vehicle_typeCreateManyVehicle_categoryInput = {
    id: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type barangUpdateWithoutVehicle_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_barang?: StringFieldUpdateOperationsInput | string
    description_barang?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventory?: inventoryUpdateManyWithoutBarangNestedInput
    order_barang_detail?: order_barang_detailUpdateManyWithoutBarangNestedInput
    transaksi_detail?: transaksi_detailUpdateManyWithoutBarangNestedInput
  }

  export type barangUncheckedUpdateWithoutVehicle_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_barang?: StringFieldUpdateOperationsInput | string
    description_barang?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventory?: inventoryUncheckedUpdateManyWithoutBarangNestedInput
    order_barang_detail?: order_barang_detailUncheckedUpdateManyWithoutBarangNestedInput
    transaksi_detail?: transaksi_detailUncheckedUpdateManyWithoutBarangNestedInput
  }

  export type barangUncheckedUpdateManyWithoutVehicle_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_barang?: StringFieldUpdateOperationsInput | string
    description_barang?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    point?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehicle_typeUpdateWithoutVehicle_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateManyWithoutVehicle_typeNestedInput
  }

  export type vehicle_typeUncheckedUpdateWithoutVehicle_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUncheckedUpdateManyWithoutVehicle_typeNestedInput
  }

  export type vehicle_typeUncheckedUpdateManyWithoutVehicle_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateManyVehicle_merkInput = {
    id: string
    status_id: string
    member_id: string
    vehicle_year_id: string
    vehicle_type_id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type usersUpdateWithoutVehicle_merkInput = {
    id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUpdateManyWithoutUsersNestedInput
    member?: memberUpdateOneRequiredWithoutUsersNestedInput
    status?: statusUpdateOneRequiredWithoutUsersNestedInput
    vehicle_year?: vehicle_yearUpdateOneRequiredWithoutUsersNestedInput
    vehicle_type?: vehicle_typeUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutVehicle_merkInput = {
    id?: StringFieldUpdateOperationsInput | string
    status_id?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
    vehicle_year_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutVehicle_merkInput = {
    id?: StringFieldUpdateOperationsInput | string
    status_id?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
    vehicle_year_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateManyVehicle_typeInput = {
    id: string
    status_id: string
    member_id: string
    vehicle_year_id: string
    vehicle_merk_id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type usersUpdateWithoutVehicle_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUpdateManyWithoutUsersNestedInput
    member?: memberUpdateOneRequiredWithoutUsersNestedInput
    status?: statusUpdateOneRequiredWithoutUsersNestedInput
    vehicle_merk?: vehicle_merkUpdateOneRequiredWithoutUsersNestedInput
    vehicle_year?: vehicle_yearUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutVehicle_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status_id?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
    vehicle_year_id?: StringFieldUpdateOperationsInput | string
    vehicle_merk_id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutVehicle_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status_id?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
    vehicle_year_id?: StringFieldUpdateOperationsInput | string
    vehicle_merk_id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateManyVehicle_yearInput = {
    id: string
    status_id: string
    member_id: string
    vehicle_merk_id: string
    vehicle_type_id: string
    no_police: string
    name?: string | null
    point?: number | null
    address?: string | null
    phone_number: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type usersUpdateWithoutVehicle_yearInput = {
    id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUpdateManyWithoutUsersNestedInput
    member?: memberUpdateOneRequiredWithoutUsersNestedInput
    status?: statusUpdateOneRequiredWithoutUsersNestedInput
    vehicle_merk?: vehicle_merkUpdateOneRequiredWithoutUsersNestedInput
    vehicle_type?: vehicle_typeUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutVehicle_yearInput = {
    id?: StringFieldUpdateOperationsInput | string
    status_id?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
    vehicle_merk_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutVehicle_yearInput = {
    id?: StringFieldUpdateOperationsInput | string
    status_id?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
    vehicle_merk_id?: StringFieldUpdateOperationsInput | string
    vehicle_type_id?: StringFieldUpdateOperationsInput | string
    no_police?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableIntFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mekanikCreateManyWarehouseInput = {
    id: string
    employee_id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type order_barangCreateManyWarehouse_order_barang_from_warehouse_idTowarehouseInput = {
    id: string
    to_warehouse_id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type order_barangCreateManyWarehouse_order_barang_to_warehouse_idTowarehouseInput = {
    id: string
    from_warehouse_id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type transaksiCreateManyWarehouseInput = {
    id: string
    users_id: string
    mekanik_id: string
    point?: number
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type warehouse_inventoryCreateManyWarehouseInput = {
    id: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type mekanikUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: employeeUpdateOneRequiredWithoutMekanikNestedInput
    transaksi?: transaksiUpdateManyWithoutMekanikNestedInput
  }

  export type mekanikUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUncheckedUpdateManyWithoutMekanikNestedInput
  }

  export type mekanikUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type order_barangUpdateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse_order_barang_to_warehouse_idTowarehouse?: warehouseUpdateOneRequiredWithoutOrder_barang_order_barang_to_warehouse_idTowarehouseNestedInput
    order_barang_detail?: order_barang_detailUpdateManyWithoutOrder_barangNestedInput
  }

  export type order_barangUncheckedUpdateWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    to_warehouse_id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order_barang_detail?: order_barang_detailUncheckedUpdateManyWithoutOrder_barangNestedInput
  }

  export type order_barangUncheckedUpdateManyWithoutWarehouse_order_barang_from_warehouse_idTowarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    to_warehouse_id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type order_barangUpdateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warehouse_order_barang_from_warehouse_idTowarehouse?: warehouseUpdateOneRequiredWithoutOrder_barang_order_barang_from_warehouse_idTowarehouseNestedInput
    order_barang_detail?: order_barang_detailUpdateManyWithoutOrder_barangNestedInput
  }

  export type order_barangUncheckedUpdateWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_warehouse_id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order_barang_detail?: order_barang_detailUncheckedUpdateManyWithoutOrder_barangNestedInput
  }

  export type order_barangUncheckedUpdateManyWithoutWarehouse_order_barang_to_warehouse_idTowarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_warehouse_id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksiUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mekanik?: mekanikUpdateOneRequiredWithoutTransaksiNestedInput
    users?: usersUpdateOneRequiredWithoutTransaksiNestedInput
    transaksi_detail?: transaksi_detailUpdateManyWithoutTransaksiNestedInput
  }

  export type transaksiUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    users_id?: StringFieldUpdateOperationsInput | string
    mekanik_id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi_detail?: transaksi_detailUncheckedUpdateManyWithoutTransaksiNestedInput
  }

  export type transaksiUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    users_id?: StringFieldUpdateOperationsInput | string
    mekanik_id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type warehouse_inventoryUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventory?: inventoryUpdateManyWithoutWarehouse_inventoryNestedInput
  }

  export type warehouse_inventoryUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventory?: inventoryUncheckedUpdateManyWithoutWarehouse_inventoryNestedInput
  }

  export type warehouse_inventoryUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inventoryCreateManyWarehouse_inventoryInput = {
    id: string
    barang_id: string
    qty?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type inventoryUpdateWithoutWarehouse_inventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    barang?: barangUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type inventoryUncheckedUpdateWithoutWarehouse_inventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    barang_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inventoryUncheckedUpdateManyWithoutWarehouse_inventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    barang_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}